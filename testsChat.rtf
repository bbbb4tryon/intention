{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fmodern\fcharset0 Courier;\f2\froman\fcharset0 Times-Bold;
\f3\fmodern\fcharset0 Courier-Bold;\f4\froman\fcharset0 Times-Italic;\f5\froman\fcharset0 TimesNewRomanPSMT;
\f6\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\margl1440\margr1440\vieww22700\viewh16800\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
Make your UI test fast by launching with tiny timers. If 
\f1\fs26 TimerConfig.current
\f0\fs24  already reads a 
\f1\fs26 ProcessInfo
\f0\fs24  env var (recommended), the UI test will \'93just work.\'94 If not, add a small check in 
\f1\fs26 TimerConfig.current
\f0\fs24  to read 
\f1\fs26 TIMER_CHUNK_SECONDS
\f0\fs24  from 
\f1\fs26 ProcessInfo.processInfo.environment\
\
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 A) UI test (golden path)\
\pard\pardeftab720\sa240\partightenfactor0

\fs24 \cf0 File:
\f0\b0  
\f1\fs26 IntentionUITests/GoldenPathUITests.swift
\f0\fs24 \
import XCTest\
\
final class GoldenPathUITests: XCTestCase \{\
\
    override func setUp() \{\
        continueAfterFailure = false\
    \}\
\
    func test_FocusFlow_GoldenPath_Breathing_Recalibration_IncrementsStats() \{\
        let app = XCUIApplication()\
        // Make \'9320 min\'94 \uc0\u8776  3s for tests (adjust to what TimerConfig.current reads)\
        app.launchEnvironment["TIMER_CHUNK_SECONDS"] = "3"\
        app.launch()\
\
        // 1) Add two intentions\
        let textField = app.textFields.element(boundBy: 0)\
        XCTAssertTrue(textField.waitForExistence(timeout: 3), "Input field should appear")\
        textField.tap()\
        textField.typeText("Write outline")\
        app.buttons["Add"].tap()\
\
        // After first add, CTA still \'93Add\'94\
        XCTAssertTrue(app.buttons["Add"].exists)\
\
        textField.typeText("Draft section 1")\
        app.buttons["Add"].tap()\
\
        // After second add, CTA should swap to \'93Begin\'94\
        XCTAssertTrue(app.buttons["Begin"].waitForExistence(timeout: 1), "CTA should switch to Begin")\
\
        // 2) Begin the first tiny chunk\
        app.buttons["Begin"].tap()\
\
        // Countdown should appear briefly; we don\'92t need to assert its exact value.\
        // Wait for the first chunk to auto-finish (3s) and the flow to advance.\
        sleep(4) // chunk1 ~3s\
\
        // Let chunk2 auto-run too (another ~3s)\
        sleep(4)\
\
        // 3) Recalibration sheet should appear \'97 tap \'93Breathing\'94\
        // Your Recalibration sheet should have a \'93Breathing\'94 button/text somewhere.\
        let breathing = app.buttons["Breathing"]\
        XCTAssertTrue(breathing.waitForExistence(timeout: 3), "Recalibration sheet should show Breathing")\
        breathing.tap()\
\
        // 4) Verify Stats updated.\
        // Switch to Settings tab (3rd tab)\
        app.tabBars.buttons.element(boundBy: 2).tap()\
\
        // Expect the UI to reflect increments. We assert \'93Breathing\'94 exists and look for a nonzero number nearby.\
        // Keep it simple/robust (you can add accessibilityIdentifiers to be even stricter).\
        XCTAssertTrue(app.staticTexts["Breathing"].exists, "Breathing stat label should exist")\
        // Optional soft assertion for any nonzero number appearing somewhere:\
        let anyNumber = app.staticTexts.containing(NSPredicate(format: "label MATCHES %@", "^[1-9][0-9]*$")).firstMatch\
        XCTAssertTrue(anyNumber.exists, "Some stat value should be > 0 after a completed session")\
    \}\
\}\
\
\pard\pardeftab720\partightenfactor0
\cf0 If a label is hard to find, expose a few 
\f2\b accessibilityIdentifiers
\f0\b0  in your views (e.g., for the primary CTA, countdown, and Stats numbers) to make this bullet-proof.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 B) VM test 1 \'97 
\f3\fs39 FocusSessionVM
\f2\fs36  scenarios\
\pard\pardeftab720\sa240\partightenfactor0

\fs24 \cf0 File:
\f0\b0  
\f1\fs26 IntentionTests/FocusSessionVM_Scenarios.swift
\f0\fs24 \
import XCTest\
@testable import intention\
\
final class FocusSessionVM_Scenarios: XCTestCase \{\
\
    func makeVM(tinySeconds: Int = 3) -> FocusSessionVM \{\
        let tiny = TimerConfig(chunkDuration: tinySeconds)\
        return FocusSessionVM(previewMode: false, haptics: NoopHapticsClient(), config: tiny)\
    \}\
\
    func test_GivenEmpty_WhenAddTwoTiles_ThenCanPrimaryTogglesToBegin() async throws \{\
        let vm = makeVM()\
        XCTAssertFalse(vm.canPrimary, "Empty input should not enable primary")\
\
        vm.tileText = "Tile A"\
        try await vm.addTileAndPrepareForSession(vm.tileText)\
        XCTAssertTrue(vm.canPrimary, "After 1st tile, CTA should be Add (still enabled)")\
\
        vm.tileText = "Tile B"\
        try await vm.addTileAndPrepareForSession(vm.tileText)\
\
        // With 2 tiles, CTA must become Begin (phase .notStarted)\
        XCTAssertEqual(vm.tiles.count, 2)\
        XCTAssertTrue(vm.canPrimary, "CTA should now be Begin")\
        XCTAssertEqual(vm.phase, .notStarted)\
    \}\
\
    func test_WhenBeginOverallSession_ThenPhaseRunning_AndCountdownTicks() async throws \{\
        let vm = makeVM()\
        vm.tileText = "One"; try await vm.addTileAndPrepareForSession(vm.tileText)\
        vm.tileText = "Two"; try await vm.addTileAndPrepareForSession(vm.tileText)\
\
        try await vm.beginOverallSession()\
        XCTAssertEqual(vm.phase, .running)\
\
        let start = vm.countdownRemaining\
        try await Task.sleep(nanoseconds: 1_100_000_000) // ~1.1s\
        XCTAssertLessThan(vm.countdownRemaining, start, "Countdown should tick down")\
    \}\
\}\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 C) VM test 2 + persistence seam \'97 
\f3\fs39 HistoryVM
\f2\fs36  scenarios\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 This file exercises 
\f2\b move/undo
\f0\b0  (user-visible) and the 
\f2\b debounced save
\f0\b0  seam.\

\f2\b File:
\f0\b0  
\f1\fs26 IntentionTests/HistoryVM_Scenarios.swift
\f0\fs24 \
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf0 \
\
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 import XCTest\
@testable import intention\
\
// Minimal in-memory persistence for seam tests\
final actor InMemoryPersistence: Persistence \{\
    private var store: [String: Data] = [:]\
    let encoder = JSONEncoder()\
    let decoder = JSONDecoder()\
\
    // For counting/coalescing\
    private(set) var writeCount = 0\
    private(set) var lastKey: String?\
\
    func write<T: Codable>(_ object: T, to key: String) async throws \{\
        store[key] = try encoder.encode(object)\
        writeCount += 1\
        lastKey = key\
    \}\
\
    func readIfExists<T: Codable>(_ type: T.Type, from key: String) async throws -> T? \{\
        guard let data = store[key] else \{ return nil \}\
        return try decoder.decode(type, from: data)\
    \}\
\
    func clear(_ key: String) async \{\
        store.removeValue(forKey: key)\
    \}\
\}\
\
final class HistoryVM_Scenarios: XCTestCase \{\
\
    @MainActor func makeVM() -> (HistoryVM, InMemoryPersistence) \{\
        let mem = InMemoryPersistence()\
        let vm = HistoryVM(persistence: mem)\
        // Ensure built-ins exist\
        vm.reconcileAndEnsureBuiltIns()\
        return (vm, mem)\
    \}\
\
    @MainActor func test_MoveTile_SetsUndo_And_InsertsAtIndexZero() async throws \{\
        let (vm, _) = makeVM()\
        let general = vm.generalCategoryID\
        let archive = vm.archiveCategoryID\
\
        // Seed: put a couple tiles in General so there's something to move\
        vm.addToHistory(TileM(text: "A"), to: general)\
        vm.addToHistory(TileM(text: "B"), to: general)\
\
        // move the older tile (B is newest at index 0, so move A)\
        guard\
          let from = vm.categories.firstIndex(where: \{ $0.id == general \}),\
          let tileA = vm.categories[from].tiles.last\
        else \{ return XCTFail("Failed to seed") \}\
\
        try await vm.moveTileThrowing(tileA, from: general, to: archive)\
\
        // Undo toast info set\
        XCTAssertNotNil(vm.lastUndoableMove)\
\
        // Should insert at top (index 0) in the Archive\
        guard let to = vm.categories.firstIndex(where: \{ $0.id == archive \}) else \{\
            return XCTFail("Archive not found")\
        \}\
        XCTAssertEqual(vm.categories[to].tiles.first, tileA)\
\
        // Undo within 3s should return it\
        vm.undoLastMove()\
        // Give the undo Task a moment\
        try? await Task.sleep(nanoseconds: 200_000_000)\
        // Back in General at top\
        guard let from2 = vm.categories.firstIndex(where: \{ $0.id == general \}) else \{\
            return XCTFail("General not found after undo")\
        \}\
        XCTAssertEqual(vm.categories[from2].tiles.first, tileA)\
    \}\
\
    @MainActor func test_PersistenceSeam_DebounceAndFlush() async throws \{\
        let (vm, mem) = makeVM()\
\
        // Rapid calls should coalesce to ~1 write after the debounce window\
        vm.addToHistory(TileM(text: "X"), to: vm.generalCategoryID)\
        vm.saveHistory() // schedule debounced\
        vm.saveHistory() // schedule debounced (coalesced)\
        vm.saveHistory() // schedule debounced (coalesced)\
\
        // Wait slightly > 300ms (your VM's debounce)\
        try? await Task.sleep(nanoseconds: 500_000_000)\
        let writesAfterDebounce = await mem.writeCount\
        XCTAssertEqual(writesAfterDebounce, 1, "Debounced saves should coalesce")\
\
        // Calling flush should write immediately even if nothing changed\
        vm.flushPendingSaves()\
        // Allow the flush task to run\
        try? await Task.sleep(nanoseconds: 100_000_000)\
        let writesAfterFlush = await mem.writeCount\
        XCTAssertEqual(writesAfterFlush, 2, "flushPendingSaves should force an immediate write")\
    \}\
\}\

\f2\b Notes on robustness & marketing-friendly UX checks
\f0\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
UI test names are 
\f4\i descriptive
\f0\i0  and align with user expectations (what someone in the 21\'9660 demo would call success): add 
\f5 \uc0\u8594 
\f0  begin 
\f5 \uc0\u8594 
\f0  auto-finish 
\f5 \uc0\u8594 
\f0  breathe 
\f5 \uc0\u8594 
\f0  see stats go up.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Assertions focus on 
\f2\b visible state
\f0\b0  (button title swap, sheet presented, a stat visibly increments), not internals.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
To make these airtight, sprinkle 
\f3\b\fs26 accessibilityIdentifier
\f0\b0\fs24  on: the main CTA, the countdown label, and the Stats numbers (\'93stats.total\'94, \'93stats.breathing\'94, etc.).\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
In the toolbar, select 
\f2\b iPhone 15
\f0\b0  (Simulator).\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Unit tests
\f0\b0 : press the diamonds or 
\f6\fs26 \uc0\u8984 
\f1 U
\f0\fs24 .\
\ls2\ilvl0
\f2\b \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
UI tests
\f0\b0 : same, but they\'92ll launch your app.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0\cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
If you use a Test Plan, ensure 
\f2\b Destinations
\f0\b0  contains your simulator (not \'93Any iOS Device\'94).\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Keep your 
\f2\b iOS Deployment Target
\f0\b0  \uc0\u8804  the simulator\'92s OS.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
import XCTest\
\
final class KeyboardDismissUITests: XCTestCase \{\
  override func setUp() \{ continueAfterFailure = false \}\
\
  func test_KeyboardDismisses_WhenSwitchTabsAndReturn() \{\
    let app = XCUIApplication()\
    app.launchEnvironment["TIMER_CHUNK_SECONDS"] = "3"\
    app.launch()\
\
    let tf = app.textFields.element(boundBy: 0)\
    XCTAssertTrue(tf.waitForExistence(timeout: 3))\
    tf.tap(); tf.typeText("A")\
    app.buttons["Add"].tap()\
    tf.typeText("B")\
    app.buttons["Add"].tap()\
    app.buttons["Begin"].tap()\
\
    app.tabBars.buttons.element(boundBy: 2).tap() // Settings\
    app.tabBars.buttons.element(boundBy: 0).tap() // Focus\
\
    // Tap the text field (we drop focus on .running, so keyboard should not trap the view)\
    tf.tap()\
\
    // Try dismiss via Done if present; otherwise tap background element\
    if app.keyboards.buttons["Done"].waitForExistence(timeout: 1) \{\
      app.keyboards.buttons["Done"].tap()\
    \} else \{\
      app.otherElements.containing(NSPredicate(format: "identifier == %@", "primaryCTA")).element.tap()\
    \}\
\
    XCTAssertTrue(app.staticTexts["countdownLabel"].waitForExistence(timeout: 2))\
  \}\
\}\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
import XCTest\
@testable import intention\
\
final class FocusSessionVM_ValidationTests: XCTestCase \{\
\
  func makeVM() -> FocusSessionVM \{\
    FocusSessionVM(previewMode: false, haptics: NoopHapticsClient(), config: .shortDebug)\
  \}\
\
  func test_input_validation_rules() \{\
    let vm = makeVM()\
\
    // Empty / spaces \uc0\u8594  invalid\
    vm.tileText = ""\
    XCTAssertFalse(vm.canPrimary)\
    vm.tileText = "   "\
    XCTAssertFalse(vm.canPrimary)\
\
    // Valid short text\
    vm.tileText = "Write 3 lines"\
    XCTAssertTrue(vm.canPrimary)\
\
    // Over 200 chars \uc0\u8594  invalid\
    vm.tileText = String(repeating: "a", count: 201)\
    XCTAssertFalse(vm.canPrimary)\
\
    // Exactly 200 chars \uc0\u8594  valid\
    vm.tileText = String(repeating: "b", count: 200)\
    XCTAssertTrue(vm.canPrimary)\
  \}\
\
  func test_add_then_begin_gating() async throws \{\
    let vm = makeVM()\
    vm.enterIdleIfNeeded()\
\
    vm.tileText = "First"\
    _ = try await vm.handlePrimaryTap(validatedInput: nil) // adds first\
    XCTAssertEqual(vm.tiles.count, 1)\
    XCTAssertEqual(vm.phase, .idle)\
    XCTAssertEqual(vm.primaryCTATile, "Add")\
\
    vm.tileText = "Second"\
    _ = try await vm.handlePrimaryTap(validatedInput: nil) // adds second\
    XCTAssertEqual(vm.tiles.count, 2)\
    XCTAssertTrue(vm.canPrimary)\
    XCTAssertEqual(vm.primaryCTATile, "Begin")\
\
    // Start the countdown\
    _ = try await vm.handlePrimaryTap(validatedInput: nil)\
    XCTAssertEqual(vm.phase, .running)\
    XCTAssertFalse(vm.canPrimary) // disabled while running\
  \}\
\}\
}