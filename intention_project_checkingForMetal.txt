=== ./IntentionUITests/IntentionUITestsLaunchTests.swift ===
//
//  IntentionUITestsLaunchTests.swift
//  IntentionUITests
//
//  Created by Benjamin Tryon on 9/16/25.
//

//import XCTest
//
//final class IntentionUITestsLaunchTests: XCTestCase {
//
//    override class var runsForEachTargetApplicationUIConfiguration: Bool {
//        true
//    }
//
//    override func setUpWithError() throws {
//        continueAfterFailure = false
//    }
//
//    @MainActor
//    func testLaunch() throws {
//        let app = XCUIApplication()
//        app.launch()
//
//        // Insert steps here to perform after app launch but before taking a screenshot,
//        // such as logging into a test account or navigating somewhere in the app
//
//        let attachment = XCTAttachment(screenshot: app.screenshot())
//        attachment.name = "Launch Screen"
//        attachment.lifetime = .keepAlways
//        add(attachment)
//    }
//}
-e \n\n
=== ./IntentionUITests/IntentionUITests.swift ===
//
//  IntentionUITests.swift
//  IntentionUITests
//
//  Created by Benjamin Tryon on 9/16/25.
//

@testable import intention
import XCTest

final class IntentionUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it‚Äôs important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
-e \n\n
=== ./intention/App/intentionApp.swift ===
//
//  intentionApp.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

@main
struct intentionApp: App {
    /// Theme is the source of truth for colors at launch.
    // @StateObject var theme = ThemeManager() //FIXME: - don't need this
    
    init(){
        // Match launch color immediately
        UIWindow.appearance().backgroundColor = UIColor(named: "background")
    }
    var body: some Scene {
        WindowGroup {
            RootView()
                .background(Color("LaunchscreenTan").ignoresSafeArea())
        }
    }
}
-e \n\n
=== ./intention/App/RootView.swift ===
//
//  RootView.swift
//  intention
//
//  Created by Benjamin Tryon on 6/19/25.
//
//What‚Äôs happening (why it ‚Äúfinishes‚Äù)


import SwiftUI

// MARK: - FocusShell

/// Centralizes per-screen chrome (backgrounds, overlays, sheets)
/// Keep it under 15 lines: Swift won't yell and this avoids deep view chains
struct FocusShell<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    
    @ViewBuilder var content: Content
    
    var body: some View {
        let pal = theme.palette(for: screen)
        // card/surface under widgets
        let backgrounded = content.background(pal.surface)
        
        ZStack {
            if let g = pal.gradientBackground {
                LinearGradient(
                    colors: g.colors, startPoint: g.start, endPoint: g.end
                )
                    .ignoresSafeArea()
            } else {
                pal.background.ignoresSafeArea()
            }
            backgrounded
        }
    }
}

// MARK: - RootSheet

/// sheets presented from the root - Swift won't yell and this avoids deep view chains
enum RootSheet: Identifiable, Equatable {
    case legal, membership, terms, privacy, medical
    
    var id: String {
        switch self {
        case .legal: return "legal"
        case .membership: return "membership"
        case .terms: return "terms"
        case .privacy: return "privacy"
        case .medical: return "medical"
        }
    }
}

#if DEBUG
extension RootView {
    func _resetLegalGate() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
        activeSheet = .legal
    }
}
#endif


// MARK: Global AppErrorOverlayManager
// Use MainActor to ensure all state changes happen on the main thread safely.
@MainActor
final class AppOverlayManager: ObservableObject {
    @Published var debugErrorTitle: String = ""
    @Published var debugErrorMessage: String = ""
    @Published var isShowingDebugError = false
    
    init() {
        // This sets up the observer when the manager is initialized.
        NotificationCenter.default.addObserver(
            forName: .debugShowSampleError, object: nil, queue: nil // Ensures UI updates happen safely
        ) { [weak self] note in
            Task { @MainActor in
            guard let self = self else { return }
            // Extract the data payload + self.Update the state to trigger the overlay
            let userInfo = note.userInfo
                self.debugErrorTitle = userInfo?[DebugNotificationKey.errorTitle] as? String ?? "Debug Error"
                self.debugErrorMessage = userInfo?[DebugNotificationKey.errorMessage] as? String ?? "No debug message provided."
            self.isShowingDebugError = true
            }
        }
    }
}

/// App entry. Owns and wires shared VMs/actors. Presents paywall and legal.
/// Keeps single sources of truth at the root and centralizes scene handling.
struct RootView: View {
    
    // MARK: AppStorage (legal gate)
    // Last accepted legal version.
    @AppStorage(LegalKeys.acceptedVersion) private var acceptedVersion: Int = 0
    // Acceptance timestamp (epoch seconds).
    @AppStorage(LegalKeys.acceptedAtEpoch) private var acceptedAtEpoch: Double = 0
    
    // MARK: presentation
    // Which root-level sheet is visible (legal, membership, etc).
    @State private var activeSheet: RootSheet?
    @State private var isShowingMembershipDebug = false
    // Global "busy, Loading" overlay.
    @State private var isBusy = false
    
    // MARK: Injecting Global ErrorOverlay Manager
    @StateObject private var overlayManager = AppOverlayManager()
    
    // MARK: Scene
    /// Scene phase guardrail: pause timers, flush history, warms haptics.
    @Environment(\.scenePhase) private var scenePhase
    
    // MARK: Single sources of truth (owned here, injected downward)
    @StateObject private var theme: ThemeManager
    @StateObject private var memVM: MembershipVM
    @StateObject private var historyVM: HistoryVM
    @StateObject private var focusVM: FocusSessionVM
    @StateObject private var recalVM: RecalibrationVM
    @StateObject private var statsVM: StatsVM
    @StateObject private var prefs: AppPreferencesVM
    @StateObject private var hapticsEngine: HapticsService // warmed generators (UI object)
    @StateObject private var debug = DebugRouter()
    
    /// Builds once: create infrastructure: actors/services, wire VM for "when", actors for "how", and assign to `@StateObject` wrappers.
    init() {
        // Infra actors/services
        let persistence     = PersistenceActor()
        let config          = TimerConfig.current
        
        // Plain instances (no self) of Services / VMs
        let theme           = ThemeManager()
        let payments        = PaymentService(productIDs: ["com.argonnesoftware.intention"])
        let membership      = MembershipVM(payment: payments)
        let prefs           = AppPreferencesVM()
        let engine          = HapticsService()
        let liveHaptics     = LiveHapticsClient(prefs: prefs, engine: engine)
        let history         = HistoryVM(persistence: persistence)
        let focus           = FocusSessionVM(previewMode: false, haptics: liveHaptics, config: config)
        let recal           = RecalibrationVM(haptics: liveHaptics)
        let stats           = StatsVM(persistence: persistence)
        
        // Wiring
        focus.historyVM     = history    // Focus writes completions into History
        stats.memVM         = membership // Stats can query membership state

        recal.onCompleted = { [weak stats, weak focus] (mode: RecalibrationMode) in
            guard let stats = stats else { return }
            let texts = focus?.tiles.map(\.text) ?? []
            stats.logSession(CompletedSession(
                date: .now,
                tileTexts: texts,
                recalibration: mode
            ))
            Task { @MainActor in await focus?.resetSessionStateForNewStart() }
        }
        
        // Assign "wrappers" `_StateObject` backing vars
        _theme          = StateObject(wrappedValue: theme)
        _memVM          = StateObject(wrappedValue: membership)
        _historyVM      = StateObject(wrappedValue: history)
        _focusVM        = StateObject(wrappedValue: focus)
        _recalVM        = StateObject(wrappedValue: recal)
        _statsVM        = StateObject(wrappedValue: stats)
        _prefs          = StateObject(wrappedValue: prefs)
        _hapticsEngine  = StateObject(wrappedValue: engine)
    }
    
    // MARK: Body
    var body: some View {
        // shared palette locals help calm the swift type-checker
        let palFocus        = theme.palette(for: .focus)
        let _               = theme.palette(for: .history)
        let _               = theme.palette(for: .settings)
        let _               = theme.palette(for: .recalibrate)
        let _               = theme.palette(for: .membership)
        let tabBG           = palFocus.background.opacity(0.88) // Makes tab bar match app theme (iOS 16+)
        
        
        // Focus Tab
        let focusContent    = FocusSessionActiveV(
            focusVM: focusVM,     // not viewModel:focusVM - focusVM: focusVM matches view's property name
            recalibrationVM: recalVM
        )
            .scrollDismissesKeyboard(.interactively)
        
        let focusScreen     = FocusShell(screen: .focus) {
            focusContent
        }
        
        let focusNav        = NavigationStack {
            focusScreen
                .navigationTitle("Focus")
                .navigationBarTitleDisplayMode(.inline)
        }
            .tabItem { Image(systemName: "timer") }
        
        // History Tab
        let historyContent  = HistoryV(viewModel: historyVM)
        let historyScreen   = FocusShell(screen: .history) { historyContent }
        let historyNav      = NavigationStack {
            historyScreen
                .navigationTitle("History")
                .navigationBarTitleDisplayMode(.inline)
        }
            .tabItem { Image(systemName: "clock") }
        
        // Settings Tab (drives stats, membership, ...)
        let settingsContent = SettingsV(statsVM: statsVM)
        let settingsScreen  = FocusShell(screen: .settings) { settingsContent }
        let settingsNav     = NavigationStack {
            settingsScreen
                .navigationTitle("Settings")
                .navigationBarTitleDisplayMode(.inline)
        }
            .tabItem { Image(systemName: "gear") }
        
        // Tabs built as a *local* keeps long chains out of top-level expression
        let tabs    = TabView {
            focusNav
            historyNav
            settingsNav
        }
        
        // Wrapped to apply shares (apply tab icon coloring, shared toolbars, backgrounds)
        let content = tabs
            .tint(palFocus.primary)
            .toolbarBackground(tabBG, for: .tabBar)
            .toolbarBackground(.visible, for: .tabBar)
        
        content
        // the shared environment
            .environmentObject(theme)
            .environmentObject(statsVM)
            .environmentObject(memVM)
            .environmentObject(historyVM)
            .environmentObject(prefs)
            .environmentObject(hapticsEngine)
            .environmentObject(focusVM)
            .environmentObject(debug)
            .progressOverlay($isBusy, text: "Loading...")
        // Applies current screen theme to background
            .toolbarBackground(tabBG, for: .navigationBar)
            .environmentObject(overlayManager)
//            .sceneHandlers
//            .launchHandlers
//            .membershipHandlers
//            .rootSheets(activeSheet: $activeSheet, memVM: memVM)
        
        // MARK: App lifecycle (guardrail: scene handling lives at root)
            .onChange(of: scenePhase, perform: { phase in
                // Only set busy for background/inactive phases where a long-running Task might fire
                switch phase {
                case .inactive, .background:
                    isBusy = true
                    Task {
                        defer { isBusy = false }      // Ensure reset after Task completes
                        // 1) coalesce + persist any pending History saves now
                        historyVM.flushPendingSaves()
                        // 2) snapshot focus session state (not a pause)
                        await focusVM.suspendTickingForBackground()
                        isBusy = false
                    }
                
                // Active state only calls short synchronous functions
                case .active:
                    isBusy = true
                    // 3) recompute remaining (time) from snapshot & resume UI ticking if needed
                    recalVM.appDidBecomeActive()
                    Task {
                        await focusVM.resumeTickingAfterForeground(); isBusy = false
                    }
                default: break
                }
            })
        // MARK: App launch + restore any active session state + legal gate
            .onAppear {
                // 1) Set isBusy for the main async launch process
                isBusy = true
                Task {
                    defer { isBusy = false }      // Ensure reset after All onAppear tasks
                    
                    await focusVM.restoreActiveSessionIfAny();
                    hapticsEngine.warm()                        // Synchronous, but wrapped in the main Task
                    
                    if LegalConsent.needsConsent() {
                        // Keep the legal sheet on the main thread
                        await MainActor.run { activeSheet = .legal }
                    }
                }
                
                hapticsEngine.warm()        // implemented as a no-op wrapper than just calls prepare()
                
                // Wrapped in #if debug to not affect release
#if DEBUG
                if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
                    UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
                    UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
                    activeSheet = .legal
                }
#endif

            }
        
        // Membership prompt choreography
        ///FIXME: remove one of the membership because they're "re"-presented?
            .onChange(of: memVM.shouldPrompt) { show in
                if show, activeSheet == nil { activeSheet = .membership }
            }
            .onChange(of: activeSheet) { sheet in
                if sheet == nil, memVM.shouldPrompt { activeSheet = .membership }
            }
        // MARK: Sheets
            .sheet(item: $activeSheet) { sheet in
                switch sheet {
                case .legal:
                    LegalAgreementSheetV(
                        onAccept: {
                            LegalConsent.recordAcceptance()
                            acceptedVersion = LegalConfig.currentVersion
                            acceptedAtEpoch = Date().timeIntervalSince1970
                            activeSheet = nil
                        },
                        onShowTerms: { activeSheet = .terms },
                        onShowPrivacy: { activeSheet = .privacy },
                        onShowMedical: { activeSheet = .medical }
                    )
                    
                case .membership:
                    NavigationStack {
                        MembershipSheetV()
                            .environmentObject(memVM)
                            .environmentObject(theme)
                    }
                    .onDisappear { memVM.shouldPrompt = false }
                    
                case .terms:
                    NavigationStack {
                        LegalDocV(
                            title: "Terms of Use",
                            markdown: MarkdownLoader.load(named: LegalConfig.termsFile)
                        )
                    }
                    
                case .privacy:
                    NavigationStack {
                        LegalDocV(
                            title: "Privacy Policy",
                            markdown: MarkdownLoader.load(named: LegalConfig.privacyFile)
                        )
                    }
                    
                case .medical:
                    NavigationStack {
                        LegalDocV(
                            title: "Wellness Disclaimer",
                            markdown: MarkdownLoader.load(named: LegalConfig.medicalFile)
                        )
                    }
                }
            }
        // ========== DEBUG PRESENTATION WIRING ==========
        // Recalibration "sheet" as a full-screen chrome for debug
            .fullScreenCover(isPresented: $debug.showRecalibration) {
                RecalibrationSheetChrome(onClose: { debug.showRecalibration = false }) {
                    // Use a minimal mock for debug rendering ONLY here.
                    // (Does not mutate live session state.)
                    RecalibrationV(vm: RecalibrationVM.mockForDebug())
                }
                .environmentObject(theme)
            }

            // Organizer overlay using LIVE history categories (no mocks).
            // We pass a Binding into OrganizerOverlayScreen so reordering acts on your real data.
            .fullScreenCover(isPresented: $debug.showOrganizer) {
                OrganizerOverlayChrome(onClose: { debug.showOrganizer = false }) {
                    OrganizerOverlayScreen(
                        categories: Binding(
                            get: { historyVM.categories },
                            set: { historyVM.categories = $0 }
                        ),
                        onMoveTile: { tile, sourceID, destinationID in
                            historyVM.moveTileBetweenCategories(tile, fromCategory: sourceID, toCategory: destinationID)
                        },
                        onReorder: { newTiles, catID in
                            historyVM.reorderTiles(newTiles, in: catID)
                        },
                        onDone: { debug.showOrganizer = false }
                    )
                }
                .environmentObject(theme)
            }

            // Membership debug simply reuses your root sheet choreography
            .onChange(of: debug.showMembership) { want in
                if want { activeSheet = .membership; debug.showMembership = false }
            }

            // Route debug errors through the same global overlayManager
            .onChange(of: debug.showError) { show in
                if show {
                    overlayManager.debugErrorTitle = debug.errorTitle
                    overlayManager.debugErrorMessage = debug.errorMessage
                    overlayManager.isShowingDebugError = true
                    debug.showError = false
                }
            }
        
//            .onReceive(NotificationCenter.default.publisher(for: .devOpenMembership)) { _ in
//                        isShowingMembershipDebug = true
//                    }
//        // The Global Presentation: Use .overlay to float over all content
//                .overlay {
//                    if overlayManager.isShowingDebugError {
//                        ErrorOverlay(
////                            title: overlayManager.debugErrorTitle,
//                            displayMessage: overlayManager.debugErrorMessage,
//                            dismissAction: { overlayManager.isShowingDebugError = false }
//                        )
//                        // Use a standard, quick animation for a polished feel
//                        .transition(.opacity.animation(.easeInOut(duration: 0.2)))
//                    }
//                }
    }
}

//private extension View {
//    var sceneHandlers: some View { modifier(SceneHandlers()) }
//    var launchHandlers: some View { modifier(LaunchHandlers()) }
//    func membershipHandlers(activeSheet: Binding<RootSheet?>, memVM: MembershipVM) -> some View {
//            modifier(MembershipHandlers(activeSheet: activeSheet, memVM: memVM))
//        }
//        func rootSheets(activeSheet: Binding<RootSheet?>, memVM: MembershipVM) -> some View {
//            modifier(RootSheets(activeSheet: activeSheet, memVM: memVM))
//        }
//}

#if DEBUG
#Preview {
    RootView()
        .previewTheme()
}
#endif
-e \n\n
=== ./intention/Features/Settings/SettingsLegalSection.swift ===
//
//  SettingsLegalSection.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

import SwiftUI

struct SettingsLegalSection: View {
    var onShowTerms: () -> Void
    var onShowPrivacy: () -> Void
    var onShowMedical: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Legal").font(.headline)
            HStack(spacing: 10) {
                Button("Terms of Use") { onShowTerms() }.buttonStyle(.plain).underline()
                Text("‚Ä¢")
                Button("Privacy Policy") { onShowPrivacy() }.buttonStyle(.plain).underline()
                Text("‚Ä¢")
                Button("Wellness Disclaimer") { onShowMedical() }.buttonStyle(.plain).underline()
            }
            .font(.footnote)
            .foregroundStyle(.secondary)
        }
    }
}

#if DEBUG
#Preview {
    SettingsLegalSection(onShowTerms: {}, onShowPrivacy: {}, onShowMedical: {})
        .padding()
}
#endif
-e \n\n
=== ./intention/Features/Settings/SettingsV.swift ===
//
//  SettingsV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import UserNotifications

struct SettingsV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    @EnvironmentObject var memVM: MembershipVM
    @EnvironmentObject var focusVM: FocusSessionVM
    @EnvironmentObject var debug: DebugRouter
    @ObservedObject var statsVM: StatsVM
    @AppStorage(DebugKeys.forceLegalNextLaunch) private var debugShowLegalNextLaunch = false
    
    @State private var userID: String = ""      /// aka deviceID
    @State private var showTerms = false
    @State private var showPrivacy = false
    @State private var showMedical = false
    @State private var isBusy = false
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions Settings ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ScrollView {
            Page(top: 4, alignment: .center) {
                T("Settings", .header)
                    .padding(.bottom, 4)
                
#if DEBUG
                // DisclosureGroup<Label, Content>(label: Label, @ViewBuilder content: () -> Content)
                // where the label is the first (non-closure) argument, and the content is the trailing closure
                // use the implicit first and second trailing closures:
                // The Label argument (mandatory for this initializer with DisclosureGroup)
                DisclosureGroup {
                    VStack(alignment: .leading, spacing: 6) {
                        Button("Debug: Clear All") {
                            UserDefaults.standard.removeObject(forKey: "debug.chunkSeconds")
                        }
                        Button("Reset Session"){Task { await focusVM.resetSessionStateForNewStart() } }
                        
                        Toggle("Show Legal on Next Launch", isOn: $debugShowLegalNextLaunch)
                        
                        Button("Reset: Legal Gate") { LegalConsent.clearForDebug() }
                            .controlSize(.large)
                        
                        Divider()
                        T("BYPASS", .largeTitle)
                        
                        Button("Recalibration View"){debug.presentRecalibration() }
                        Button("Organizer View")     { debug.presentOrganizer() }
                        Button("Membership View")    { debug.presentMembership() }
                        Button("ErrorOverlay View")  {
                            debug.presentError(
                                title: "Debug View Activated",
                                message: "This is a forced-view of the error overlay for visual confirmation."
                            )
                        }
//                        
//                        Button("Recalibration View"){NotificationCenter.default.post(
//                            // Fires signal to the receiver (e.g. FocusActiveSessionV)
//                            name: .devOpenRecalibration, object: nil) }
//                        Button("Organizer View"){ NotificationCenter.default.post(
//                            name: .devOpenOrganizerOverlay, object: nil) }
//                        Button("Membership View"){NotificationCenter.default.post(
//                            name: .devOpenMembership, object: nil) }
//                        Button("ErrorOverlay View") {
//                            // Pass sample data for the overlay's content
//                            let userInfo: [AnyHashable: Any] = [
//                                DebugNotificationKey.errorTitle: "Debug View Activated",
//                                DebugNotificationKey.errorMessage: "This is a forced-view of the error overlay for visual confirmation."
//                            ]
//                            NotificationCenter.default.post(
//                                name: .debugShowSampleError, object: nil) }
//                        
                        Picker("Timer debug", selection: Binding(
                            get: { UserDefaults.standard.integer(forKey: "debug.chunkSeconds") },
                            set: { UserDefaults.standard.set($0, forKey: "debug.chunkSeconds") } )) {
                                Text("10s").tag(10); Text("30s").tag(30)
                                Text("OFF (20m)").tag(0) // 0 disables override
                        }}.controlSize(.small) .font(.footnote) .buttonStyle(.bordered)
                } label: {
                    Label("Dev", systemImage: "wrench")         // Dumb words, but this is the CONTENT closure
                }
#endif
                
                // MARK: Support
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Support", .section)
                        NavigationLink {
                            FeedbackV()
                        } label: {
                            HStack {
                                Image(systemName: "paperplane.fill")
                                T("Send Feedback", .action)
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .font(.footnote)
                                    .foregroundStyle(.secondary)
                            }
                            .padding(.vertical, 6)
                        }
                        .buttonStyle(.borderless)
                    }
                    .edgesIgnoringSafeArea(.bottom)
                }
                
                // MARK: Membership
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Membership", .section)
                        //                        .friendlyHelper()
                        (memVM.isMember
                         ? T("Status: Active", .secondary).bold() : T("Status: Not Active", .secondary).bold()
                        )
                        .foregroundStyle(memVM.isMember ? .green : .secondary)
                        
                        T("Your user ID/device ID: \(userID)", .caption)
                            .foregroundStyle(textSecondary)
                        HStack(spacing: 12) {
                            Button(action: {
                                /// Instead of Link()
                                if let url = URL(string: "https://apps.apple.com/account/subscriptions") {
                                    UIApplication.shared.open(url)
                                }
                            }) {
                                T("Manage Subscription", .action)
                            }
                            .primaryActionStyle(screen: .settings)
                            .frame(maxWidth: .infinity)
                            .tint(p.accent)
                        }
                    }
                }
                
                // MARK: Stats
                Card {
                    Grid(horizontalSpacing: 12, verticalSpacing: 12){
                        GridRow {
                            StatPill(icon: "list.bullet",
                                     value: "\(statsVM.totalCompletedIntentions)",
                                     caption: "Accomplished",
                                     screen: .settings)
                            
                            StatPill(icon: "rosette",
                                     value: "\(statsVM.longestStreak)",
                                     caption: "Streak",
                                     screen: .settings)
                            //                        }
                            //                        GridRow {
                            StatPill(icon: "leaf.fill",
                                     value: "\(statsVM.recalibrationCounts[.breathing, default: 0])",
                                     caption: "Breathing",
                                     screen: .settings)
                            StatPill(icon: "figure.walk",
                                     value: "\(statsVM.recalibrationCounts[.balancing, default: 0])",
                                     caption: "Balancing",
                                     screen: .settings)
                            
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
                
                Divider()
                
                // MARK: Preferences
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Preferences", .section)
                        Toggle(isOn: .constant(true)) { T("Enable Notification", .caption) }
                        Toggle(isOn: $prefs.hapticsOnly) { T("Haptics Only: Vibration cues only", .caption)
                            .foregroundStyle(textSecondary) }
                        Toggle(isOn: .constant(false)) { T("Sound Off", .caption) }
                            .controlSize(.small)        /// Toggle size
                            .toggleStyle(SwitchToggleStyle(tint: p.accent))
                    }
                    .friendlyAnimatedHelper("hapticsOnly-\(prefs.hapticsOnly ? "on" : "off")")
                }
                
                // MARK: Customization
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Personalization", .section)
                        
                        // Color Theme Picker
                        Picker(selection: $theme.colorTheme) {
                            ForEach(AppColorTheme.publicCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Color", .label)          // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)                 // segment highlight color
                        
                        // Font Theme Picker
                        Picker(selection: $theme.fontTheme) {
                            ForEach(AppFontTheme.allCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Font", .section)     // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)
                        .friendlyAnimatedHelper(theme.fontTheme.rawValue)
                    }
                }
                
                // MARK: Legal (reprise)
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        
                        SettingsLegalSection(
                            onShowTerms: { showTerms = true },
                            onShowPrivacy: { showPrivacy = true },
                            onShowMedical: { showMedical = true }
                        )
                        .sheet(isPresented: $showTerms) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Terms of Use",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.termsFile)
                                )
                            }
                        }
                        .sheet(isPresented: $showPrivacy) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Privacy Policy",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.privacyFile)
                                )
                            }
                        }
                        .sheet(isPresented: $showMedical) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Wellness Disclaimer",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.medicalFile)
                                )
                            }
                        }
                    }
                }
            }
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .task {
            /// Read it directly from your keychain on-demand - actor requires only await, not async here
            userID = await KeychainHelper.shared.getUserIdentifier()
        }
    }
    
    func requestNotificationPermissions() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            if let error = error {
                print("Notification permission error: \(error.localizedDescription)")
            }
            print("Permission granted: \(granted)")
        }
    }
}

#if DEBUG
#Preview("Stats & Settings") {
    MainActor.assumeIsolated {
        let stats = PreviewMocks.stats
        stats.logSession(CompletedSession(date: .now, tileTexts: ["By Example", "Analysis checklist"], recalibration: .breathing))
        
        return PreviewWrapper {
            SettingsV(statsVM: PreviewMocks.stats)
                .previewTheme()
        }
    }
}
#endif
-e \n\n
=== ./intention/Features/Sheets Overlays/RecalibrationSheetChrome.swift ===
//
//  RecalibrationSheetChrome.swift
//  intention
//
//  Created by Benjamin Tryon on 10/13/25.
//

import SwiftUI

/// A full-screen wrapper that *looks* like a sheet: rounded top, grabber, swipe down to dismiss.
struct RecalibrationSheetChrome<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    var onClose: () -> Void
    @ViewBuilder var content: Content

    @State private var offsetY: CGFloat = 0
    private let dismissThreshold: CGFloat = 120

    private var p: ScreenStylePalette { theme.palette(for: .recalibrate) }
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red

    var body: some View {
        ZStack {
            // The themed gradient or fallback background
            if let g = p.gradientBackground {
                LinearGradient(colors: g.colors, startPoint: g.start, endPoint: g.end)
                    .ignoresSafeArea()
            } else {
                p.background.ignoresSafeArea()
            }

            // ‚ÄúSheet‚Äù container
            VStack(spacing: 0) {
                // Grabber + close
                HStack {
                    Capsule().frame(width: 40, height: 5).opacity(0.35)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .overlay(alignment: .trailing) {
                            Button(action: onClose) {
                                Image(systemName: "xmark")
                                    .font(.headline)
                                    .padding(12)
                            }
                            .tint(p.accent)
                        }
                }
                .contentShape(Rectangle())

                // Your sheet content
                content
                    .background(p.surface.opacity(0.0))
            }
            .background(.clear)
            .clipShape(.rect(cornerRadius: 22, style: .continuous))
            .offset(y: max(0, offsetY))
            .gesture(
                DragGesture()
                    .onChanged { offsetY = max(0, $0.translation.height) }
                    .onEnded { final in
                        if final.translation.height > dismissThreshold { onClose() }
                        else { withAnimation(.spring) { offsetY = 0 }}
                    }
            )
            .padding(.top, 8)
            .padding(.horizontal, 0)
            .ignoresSafeArea(edges: .bottom)
        }
    }
}
-e \n\n
=== ./intention/Features/Sheets Overlays/MembershipSheetV.swift ===
//
//  Sheet.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//
//
// import Foundation
import SwiftUI

struct MembershipSheetV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var viewModel: MembershipVM
    @EnvironmentObject var theme: ThemeManager
    
    @State private var isBusy = false
    
    var useDogEmoji: Bool = true
    private let screen: ScreenName = .membership
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    // 1) Place this INSIDE the struct, but OUTSIDE `body`
    private var tailText: String { "All while helping us keep the lights on, the mortgage paid, and the \(useDogEmoji ? "üêï" : "dog") fed & happy!" }
    
    
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack {
                    // Hero
                    T("You‚Äôve completed your free sessions.", .label)
                    T("""
For $0.30 Per Day, 
Unlock Unlimited Focus
""", .section).underline().padding(.top, 2)
                        .lineLimit(2)
                }
                .multilineTextAlignment(.center)
                .friendlyHelper()
                Page(top: 10, alignment: .center){      // FIXME: top 10 MAY BE SCREWING THIS UP
                    
                    // Price hint (optional, tiny): Signals if a product is loaded + VM bridge (sheet cannot create own PaymentService)
                    if let prod = viewModel.primaryProduct {
                        Text("\(viewModel.perDayBlurb(for: prod)) ‚Ä¢ \(prod.displayPrice)")
                            .font(theme.fontTheme.toFont(.headline))
                            .background(RoundedRectangle(cornerRadius: 12).fill(p.accent))
                            .foregroundStyle(Color.intText)
                            .padding(.bottom, 4)
                    }
                    
                    // Primary CTA row (above the fold)
                    if viewModel.isMember {
                        Label { T("Member!", .label) } icon: { Image(systemName: "star.fill").foregroundStyle(p.primary)
                        }
                        .symbolBounceIfAvailable()
                    } else {
                        // Upgrade
                        Button {
                            Task {
                                isBusy = true; defer { isBusy = false }
                                do { try await viewModel.purchaseMembershipOrPrompt() }
                                catch { viewModel.setError(error) }      /// Shows ErrorOverlay
                            }
                        } label: { T("Upgrade", .action) }
                            .primaryActionStyle(screen: .membership)
                            .frame(maxWidth: .infinity)
                        
                        // Restore
                        Button {
                            Task {
                                do { try await viewModel.restoreMembershipOrPrompt() }
                                catch { viewModel.setError(error) }
                            }        /// Shows ErrorOverlay
                        } label: { T("Restore Purchases", .label) }
                            .secondaryActionStyle(screen: .membership)
                            .frame(maxWidth: .infinity)
                        
                        // Apple offer-code redemption (subscription offers)
                        Button {
                            Task { await redeemOfferCode() }
                        } label: { T("Redeem Code (Apple)", .caption) }
                            .buttonStyle(.plain)
                            .padding(.top, 4)
                    }
                    
                    Card {
                        VStack(alignment: .leading, spacing: 2) {
                            T("Why upgrade?", .title3)
                            T("Your focus fuels our future.", .title3).underline()
                            VStack(alignment: .leading, spacing: 4) {
                                Label("Unlimited focus sessions", systemImage: "infinity")
                                Label("Detailed stats & categories", systemImage: "chart.bar")
                                Label("Full customization", systemImage: "paintbrush")
                                Divider().padding()
                                Label("Build momentum", systemImage: "bolt")
                                Label("Track progress", systemImage: "chart.line.uptrend.xyaxis")
                                Label("\(tailText)", systemImage: "house")
                                Label("Thank you.", systemImage: "heart")
                            }
                            .font(theme.fontTheme.toFont(.footnote))
                            .foregroundStyle(textSecondary)
                            .symbolRenderingMode(.hierarchical)
                            
                            VStack(alignment: .leading, spacing: 2) {
                                Text("Apple securely handles your purchase. Cancel anytime in **Settings ‚Ä∫ Manage Subscription.**")
                                    .font(theme.fontTheme.toFont(.caption))
                                    .foregroundStyle(.secondary)
                                    .padding(.top)
                            }
                        }
                    }
                    .padding(.top, 8)
                }
            }
            .background(p.background.ignoresSafeArea())
            .tint(p.primary)
            // Let people leave
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button{ dismiss() }
                    label: { Image(systemName: "xmark").imageScale(.small).font(.body).controlSize(.large) }.buttonStyle(.plain).accessibilityLabel("Close")}
            }
        }
        // Sheet behavior tuned for iPhone
        .presentationDetents([.fraction(0.55), .large])
        .presentationDragIndicator(.visible)
        .interactiveDismissDisabled(false)
        .overlay {
            if isBusy { ProgressView().controlSize(.large) }
        }
        .overlay {
            if let error = viewModel.lastError {
                ErrorOverlay(error: error) { viewModel.setError(nil) }
                    .transition(.opacity.combined(with: .scale))
                    .zIndex(1)
            }
        }
    }
}

#if DEBUG
#Preview("Membership ‚Äî Not Active") {
    MainActor.assumeIsolated {
        // Dedicated, isolated VM for this preview
        let memberVM = MembershipVM(
            payment: PaymentService(productIDs: ["com.argonnesoftware.intention"])
        )
        memberVM._debugSetIsMember(false)    // Preview the non-member state

        return MembershipSheetV()
            // Inject the exact env objects MembershipSheetV expects
            .environmentObject(PreviewMocks.theme)
            .environmentObject(memberVM)
            // These keep parity with your app environment
            .environmentObject(PreviewMocks.prefs)
            .environmentObject(PreviewMocks.history)
            .environmentObject(PreviewMocks.stats)
    }
}
#endif

-e \n\n
=== ./intention/Features/Sheets Overlays/ErrorOverlay.swift ===
//
//  ErrorOverlay.swift
//  intention
//
//  Created by Benjamin Tryon on 7/1/25.
//

import SwiftUI

// `self.lastError = error` to trigger the ErrorOverlay
struct ErrorOverlay: View {
    @EnvironmentObject var theme: ThemeManager
    let error: Error
    let dismissAction: () -> Void
    
    private let screen: ScreenName = .focus // or whichever main screen hosts this overlay
        private var p: ScreenStylePalette { theme.palette(for: screen) }
    
    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        VStack(spacing: 12) {
            Text("‚ö†Ô∏è Something went wrong")
                .bold()
                .foregroundStyle(colorDanger)
            
            // Message: use the theme's text color for readability
            Text(displayMessage(for: error))
                .multilineTextAlignment(.center)
                .foregroundStyle(p.text)
            
            // Use theme's primary CTA/Accent color
            Button("Dismiss", action: dismissAction)
                .buttonStyle(.borderedProminent)
                                .tint(p.accent) // Use the theme's accent color for the button
        }
        .padding(20)            // Lots, for visual spacing
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
        .shadow(radius: 8, y: 4)    // softer
        .padding(30)        // Ensures overlay doesn't hug screen edges
    }
    
    private func displayMessage(for error: Error) -> String {
        let description = error.localizedDescription
        if description == "The operation could not be completed." {
            return "Something went wrong, please try again"
    }
            return description
    }
}

/*
 Currently, error displays FocusSessionError.unexpected or HistoryError.categoryNotFound, etc.
 Meaning enums fall back to String(describing:) so you see FocusSessionError.unexpected or HistoryError.categoryNotFound

 Later: As soon as you add `LocalizedError` with `custom errorDescription`, the nicer user message shows:
 enum HistoryError: LocalizedError {
     case categoryNotFound
     var errorDescription: String? { "The category could not be found. Tile not added." }
 }
 ‚Ä¶the overlay will automatically show "The category could not be found. Tile not added." without any changes to the view
 */
-e \n\n
=== ./intention/Features/Sheets Overlays/OrganizerOverlayChrome.swift ===
//
//  OrganizerOverlayChrome.swift
//  intention
//
//  Created by Benjamin Tryon on 10/21/25.
//

import SwiftUI

/// A full-screen wrapper that *looks* like a sheet: rounded top, grabber, swipe down to dismiss.
struct OrganizerOverlayChrome<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    var onClose: () -> Void
    @ViewBuilder var content: Content
    
    @State private var offsetY: CGFloat = 0
    private let dismissThreshold: CGFloat = 120
    private var p: ScreenStylePalette { theme.palette(for: .organizer) }
    
    var body: some View {
        ZStack {
            // The themed gradient or fallback background
            if let g = p.gradientBackground {
                LinearGradient(colors: g.colors, startPoint: g.start, endPoint: g.end)
                    .ignoresSafeArea()
            } else {
                p.background.ignoresSafeArea()
            }
            
            // "Sheet" container
            VStack(spacing: 0) {
                // Grabber + close
                HStack {
                    Capsule().frame(width: 40, height: 5).opacity(0.35)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity) //FIXME: - if alignment is off, enter , .alignment: .something)
                        .overlay(alignment: .trailing) {
                            Button(action: onClose) {
                                Image(systemName: "xmark")
                                    .font(.headline)
                                    .padding(12)
                            }
////                            .tint(p.accent)
//                            .tint()
                        }
                }
                .contentShape(Rectangle())

                // -- Rounded part of sheet content --
                // OrganizerOverlayScreen content is here
                content
                    .background(.clear) // Ensures content itself doesn't hide the ZStack gradient
            }
            .clipShape(.rect(cornerRadius: 22, style: .continuous))
            .offset(y: max(0, offsetY))
            .gesture(
                DragGesture()
                    .onChanged { offsetY = max(0, $0.translation.height) }
                    .onEnded { final in
                        if final.translation.height > dismissThreshold { onClose() }
                        else { withAnimation(.spring) { offsetY = 0 }}
                    }
            )
            .padding(.top, 8)
            .padding(.horizontal, 0)
            .ignoresSafeArea(edges: .bottom)
        }
    }
}
-e \n\n
=== ./intention/Features/Sheets Overlays/DebugRouter.swift ===
// DebugRouter.swift
// intention
//
// A tiny @MainActor router that your Dev buttons call.
// RootView observes it and presents the right sheet/overlay.

import SwiftUI

@MainActor
final class DebugRouter: ObservableObject {
    // Presentation toggles
    @Published var showRecalibration = false
    @Published var showOrganizer = false
    @Published var showMembership = false
    
    // Optional payload for a global error overlay
    @Published var errorTitle: String = ""
    @Published var errorMessage: String = ""
    @Published var showError = false
    
    // MARK: Entry points the Dev buttons will call
    func presentRecalibration() { showRecalibration = true }
    func presentOrganizer()     { showOrganizer = true }
    func presentMembership()    { showMembership = true }
    
    func presentError(title: String, message: String) {
        errorTitle = title
        errorMessage = message
        showError = true
    }
}
-e \n\n
=== ./intention/Features/Sheets Overlays/OrganizerOverlayScreen.swift ===
//
//  OrganizerOverlayScreen.swift
//  intention
//
//  Created by Benjamin Tryon on 10/20/25.
//

import SwiftUI

struct OrganizerOverlayScreen: View {
    @EnvironmentObject private var theme: ThemeManager
    @Environment(\.dismiss) private var dismiss
    @Binding var categories: [CategoriesModel]
    var onMoveTile: (TileM, UUID, UUID) -> Void
    var onReorder: (_ newTiles: [TileM], _ categoryID: UUID) -> Void
    var onDone: () -> Void
    private var p: ScreenStylePalette { theme.palette(for: .organizer) }
    
    /* Dark text color */ private let textDarkColor = Color(red: 0.4824, green: 0.3922, blue: 0.1569) // #7B6428

    var body: some View {
        NavigationStack {
            VStack(spacing: 10) {
                // --- Lines 22-32: Apply Material Background and Text Styling ---
                TileOrganizerWrapper(
                    categories: $categories,
                    onMoveTile: onMoveTile,
                    onReorder: onReorder
                )
                .font(.headline)        // Applies to text within the wrapper
                .foregroundStyle(textDarkColor)
                .padding(8)             // Breathing room inside the *material* background
                
                // This replaces .clipShape and .shadow from the original code:
                .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
                // -------------------------------------------------------------
//                .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
//                .shadow(radius: 3, y: 1)
//                .padding(5)
            } // For when we had a Zstack
            .navigationTitle("Organize")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Done") { onDone() }.font(.body).controlSize(.large)
                }
                
                ToolbarItem(placement: .topBarTrailing) {
                    Button{ dismiss() }
                    label: { Image(systemName: "xmark").imageScale(.small).font(.body).controlSize(.large) }.buttonStyle(.plain).accessibilityLabel("Close")
                }
            }
  
        }
    }
}

struct OverlayContainer: View {
    var body: some View {
        // 1. Ensure the code runs on the main actor for EnvironmentObjects
        MainActor.assumeIsolated {
            
            // 2. Define mock data for @Binding and closures
            @State var mockCategories: [CategoriesModel] = [
                // Add some mock categories/data here if needed for visual context
            ]
            
            let mockOnMoveTile: (TileM, UUID, UUID) -> Void = { _, _, _ in }
            let mockOnReorder: ([TileM], UUID) -> Void = { _, _ in }
            let mockOnDone: () -> Void = {}
            
            // 3. Define the content of the overlay (OrganizerOverlayScreen)
            let overlayContent = OrganizerOverlayScreen(
                categories: $mockCategories,
                onMoveTile: mockOnMoveTile,
                onReorder: mockOnReorder,
                onDone: mockOnDone
            )
            
            // 4. Wrap the content in the Chrome wrapper
            return OrganizerOverlayChrome(onClose: {}) {
                overlayContent
            }
            
            // 5. Inject all necessary environment objects
            .environmentObject(PreviewMocks.theme)
            .environmentObject(PreviewMocks.prefs)
            // Add any other environment objects your view hierarchy might require
        }
    }
}
#if DEBUG
#Preview {
    OverlayContainer()
}
#endif // DEBUG
-e \n\n
=== ./intention/Features/Focus/ContinuousClockActor.swift ===
//
//  ContinuousClockActor.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import Foundation

// VM = ‚Äúwhen‚Äù (state machine + orchestration + UI/session snapshot), Actor = ‚Äúhow‚Äù (monotonic time with ContinuousClock, tick loop, background math, tiny safety snapshot
// session's start time and the tiles that have been added within that session context
// Owns ContinuousClock, tick loop, background/foreground math.
// Supports user pause/resume vs. app background suspend/resume.
// Provides an auxiliary safety snapshot.
actor ContinuousClockActor {
    /// Short debug/UI tests without touching production logic
    // MARK: init
    private let config: TimerConfig
    init(config: TimerConfig) { self.config = config }
    
    // MARK: session state Convenience
    private(set) var sessionStartDate: Date?
    private(set) var currentTiles: [TileM] = []     // NOTE: adding = [] dismisses 'has no initializers'
    
    // MARK: Ticking
    private let clock = ContinuousClock()
    // Ticking stops on *backgrounding*, but endInstant keeps track without pausing
    private var tickingTask: Task<Void, Never>?
    // Time keeps elapsing from this
    private var endInstant: ContinuousClock.Instant?
    // Used for *user* paused, not app backgrounding
    private var pausedRemaining: Int?
    
    
    /// Starts a new session window; clears actor's tile buffer.
    // MARK: Session lifecycle (called by VM)
    func startSessionTracking() {
        sessionStartDate = Date()
        currentTiles = []           /// Clear tiles for new session
        pausedRemaining = nil
    }
    
    /// Append a tile; returns false if limit (2) already reached.
    func addTile(_ tile: TileM) -> Bool {
        guard currentTiles.count < 2 else { return false }
        currentTiles.append(tile)
        return true
    }
    
    func shouldCheckIn() -> Bool {
        guard let start = sessionStartDate else { return false }
        return Date().timeIntervalSince(start) >= Double(config.chunkDuration)      /// Should be 1200 - don't hardcode
    }
    
    func resetSessionTracking() {
        sessionStartDate = nil
        currentTiles = []
        cancelTicking()
        endInstant = nil
        pausedRemaining = nil
    }
    
    // MARK: - Ticking control
    func startTicking(
        totalSeconds: Int? = nil,
        onTick: @Sendable @escaping (Int) -> Void,
        onFinish: @Sendable @escaping () -> Void
    ) async {
        cancelTicking()
        
        let total = max(0, totalSeconds ?? config.chunkDuration) // "clamps": UI never shows -00:01
        endInstant = clock.now.advanced(by: .seconds(total))

        
        // run the loop on the actor via a private actor-isolated function (tickLoop), the Task only calls into that function
        tickingTask = Task { [weak self] in
            guard let self else { return }
            await self.tickLoop(onTick: onTick, onFinish: onFinish)
        }
    }
    
    // User-initiated pause (unchanged semantics): freezes remaining and clears end
    func pauseTicking(currentRemaining: Int) {
        pausedRemaining = max(0, currentRemaining)      // "clamps": UI never shows -00:01
        cancelTicking()
        endInstant = nil                    // true pause: time stops
    }
    
    // Resume from user pause (unchanged time keeping)
    func resumeTicking(
        onTick:     @Sendable @escaping (Int) -> Void,
        onFinish:   @Sendable @escaping () -> Void
    ) async {
        let resumeFrom = pausedRemaining ?? secondsRemaining() ?? config.chunkDuration
        pausedRemaining = nil
        await startTicking(totalSeconds: resumeFrom, onTick: onTick, onFinish: onFinish)
    }
    
    func suspendForBackground(){
        // App background: stop work but KEEP endInstant so wall time keeps elapsing.
        // endInstant remains set; the key difference vs a user pause
        cancelTicking()
    }
    
    // Foreground: compute remaining using endInstant and, either finish or  return nil
    func remainingAfterForeground() async -> Int? {
        guard let end = endInstant else { return pausedRemaining }
        // let now = clock.now
        // return max(0, Int(ceil(end.duration(to: now).magnitude.seconds)))
        return remainingSeconds(to: end)
    }
    
    func secondsRemaining() -> Int? {
        guard let end = endInstant else { return pausedRemaining }
                return remainingSeconds(to: end)
    }
    
    // MARK: actor-isolated tickLoop
    private func tickLoop(
        onTick:     @Sendable (Int) -> Void,
        onFinish:   @Sendable () -> Void
    ) async {
            var lastEmitted = Int.max
            while !Task.isCancelled {
                // Sleep to the next second boundary
                guard let end = endInstant else { break }
                let secs = remainingSeconds(to: end)
                if secs != lastEmitted {
                    lastEmitted = secs
                    onTick(secs)
                }
                if secs == 0 { break }
                try? await clock.sleep(for: .seconds(1))
            }
            if !Task.isCancelled { onFinish() }
    }

// Use this helper anywhere you derive remaining time so it‚Äôs consistent and non-negative
private func remainingSeconds(to end: ContinuousClock.Instant) -> Int {
    let dur = clock.now.duration(to: end)                   // positive if end in the future
    let secs = Int(ceil(Double(dur.components.seconds)))    // ignore attoseconds; 1 Hz UI
    return max(0, secs)                                     // "clamps": UI never shows -00:01
}
    
    private func cancelTicking(){
        tickingTask?.cancel()
        tickingTask = nil
    }
    
    // MARK: Auxiliary safety snapshot
    //    Why: App background suspends your task, not wall-clock time. Keeping endInstant lets you recompute exactly how much time passed while the app was away.
    // Optional: still keep snapshot if you like; not strictly required if endInstant persists in memory.
    struct Snapshot: Codable, Sendable {
        let sessionStartEpoch: TimeInterval
        let remainingSeconds: Int
        let capturedAtEpoch: TimeInterval
    }
    
    func makeSnapshot() -> Snapshot? {
        guard let start = sessionStartDate else { return nil }
        let remaining = (secondsRemaining()) ?? config.chunkDuration
        return Snapshot(
            sessionStartEpoch: start.timeIntervalSince1970,
            remainingSeconds: remaining,
            capturedAtEpoch: Date().timeIntervalSince1970
        )
    }
    
    func restoreFromSafetySnapshot(_ snap: Snapshot) {
        sessionStartDate = Date(timeIntervalSince1970: snap.sessionStartEpoch)
        pausedRemaining = snap.remainingSeconds
        endInstant = nil
        cancelTicking()
    }
}
-e \n\n
=== ./intention/Features/Focus/FocusSessionVM.swift ===
//
//  FocusSessionVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import Foundation

/// FocusSessionVM talks to ContinuousClockActor and drives the UI
/// Errors: make UI-called methods async throws (no wrapper)
@MainActor
final class FocusSessionVM: ObservableObject {
    
    /// UI state of the current 20-min chunk
    enum Phase: String, Codable, Sendable { case none, idle, running, finished, paused }
    
    // MARK: - Published UI State
    @Published var tileText: String = ""
    {
        didSet { validationMessages = tileText.taskValidationMessages } /// Input field for tiles' text;   Validate whenever tileText changes
    }
    @Published var tiles: [TileM] = []              /// List of current session tiles (max 2)
    @Published var canAdd: Bool = true              /// Flag if user can add more tiles at that point
    @Published var sessionActive: Bool = false      /// Overall session state (two 20-min chunks)
    @Published var showRecalibrate: Bool = false    /// Whether to show recalibration
    @Published var countdownRemaining: Int          /// Secs remaining in 20 minutes for individual tile task - set via config
    @Published var phase: Phase = .none             /// State of the *current* 20-min countdown chunk
    @Published var currentSessionChunk: Int = 0     /// Index of current chunk (0 or 1): Tracks which 20-min chunk of the session is active
    @Published var sessionHistory: [[TileM]] = []   /// Array of tiles completed in this session of 2 chunks
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    @Published var validationMessages: [String] = []
    @Published private(set) var didHapticForChunk: Set<Int> = []    /// remembers which chunk indices have already buzzed
    /// ^ returning from background for re-entering a completion can't "double buzz"
    
    weak var historyVM: HistoryVM?                      /// Link to history view model for/to save completed sessions
    ///
    // MARK: Dependencies
    //    private static let activeSnapshotKey = "focus.activeSession"
    private let haptics: HapticsClient
    private let config: TimerConfig
    private let persistence: any Persistence            /// handles activeSessionSnapshot via Persistence
    private let timeActor: ContinuousClockActor
    private var chunkCountdown: Task<Void, Never>?        /// background live time keeper/ticker
    private var sessionCompletionTask: Task<Void, Never>? /// background timer for the entire session (2x 20-min chunks)
    private var runningDeadline: Date?                  /// property to mark a deadline when a chunk starts or resumes
    
    var chunkDuration: Int { config.chunkDuration }     /// Default 20 min chunk duration constant
    
    // MARK: - Cancel or teardown
    deinit {
        chunkCountdown?.cancel()
        sessionCompletionTask?.cancel()
    }
    
    // MARK: Snapshot (the VM snapshot is canonical)
    private struct VMSnapshot: Codable, Equatable {
        var tileTexts: [String]
        var phase: Phase
        var chunkIndex: Int
        var deadline: Date?
        var remainingSeconds: Int       // fallback when no deadline
        var showRecalibrate: Bool
        var didHapticForChunk: [Int]
    }
    private let vmSnapshotKey = "focus.vm.snapshot.v2"
    
    // MARK: Init
    init(
        previewMode: Bool = false,
        haptics: HapticsClient,
        config: TimerConfig = .current,
        persistence: any Persistence = PersistenceActor()
    ){
        self.haptics = haptics
        self.config = config
        self.persistence = persistence
        self.countdownRemaining = config.chunkDuration
        self.timeActor = ContinuousClockActor(config: config)
        
        if previewMode {
            tiles = [TileM(text: "Tile 1"), TileM(text: "Tile 2")]
            tileText = "Start another..."
            canAdd = false
            sessionActive = true
            currentSessionChunk = 1
            phase = .running
            countdownRemaining = config.chunkDuration / 20
        }
    }
    
    // MARK: Derived
    private var hasTwoTiles: Bool { tiles.count == 2 }
    /// Guard for phases -> canPrimary for flipping to the "Add" button
    private var inputIsValid: Bool {
        let t = tileText.trimmingCharacters(in: .whitespacesAndNewlines)
        return !t.isEmpty && t.taskValidationMessages.isEmpty
    }
    
    var canPrimary: Bool {
        // Only allow "Add" when the current input is valid AND you‚Äôre not running
        if !hasTwoTiles { return inputIsValid && phase != .running }
        // Only allow "Begin" when not running (fresh or between chunks)
        else { return phase == .idle || phase == .none || (phase == .finished && currentSessionChunk == 1)
        }
    }
    
    /// Tap handler here, the button widget lives in the Focus view -> Lets the View bind `.disabled(!viewModel.canPrimary)`
    var primaryCTATile: String {
        if !hasTwoTiles { return "Add" }
        if phase == .finished && currentSessionChunk == 1 { return "Next" }
        return "Begin"
    }
    
    /// Enter idle early and consistently; cases never returns an empty label
    func enterIdleIfNeeded() {
        if phase == .none { phase = .idle }
    }
    
    // MARK: Control public funnel used by TextField and CTA
    enum PrimaryCTAResult { case added, began }
    
    /// The one funnel both TextField.onSubmit and the bottom CTA should use.
    @discardableResult
    func handlePrimaryTap(validatedInput: String?) async throws -> PrimaryCTAResult {
        if !hasTwoTiles {
            // the ADDED path
            let text = (validatedInput ?? tileText).trimmingCharacters(in: .whitespacesAndNewlines)
            guard !text.isEmpty, text.taskValidationMessages.isEmpty else {
                throw FocusSessionError.emptyInput
            }
            try await addTileAndPrepareForSession(text)
            return .added
        } else {
            // the BEGIN / NEXT path
            guard phase == .idle || phase == .none || (phase == .finished && currentSessionChunk == 1) else {
                throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
            }
            try await beginOverallSession()
            return .began
        }
    }
    
    // MARK: - Tile Handling
    func addTileAndPrepareForSession(_ text: String) async throws {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {   throw FocusSessionError.emptyInput    }
        guard tiles.count < 2 else {    throw FocusSessionError.tooManyTiles()    }
        
        let newTile = TileM(text: trimmed)
        /// Cross-actor hop; no 'try' because the actor method doesn't throw
        let accepted = await timeActor.addTile(newTile)
        guard accepted else { throw FocusSessionError.tooManyTiles(limit: 2) }
        
        tiles.append(newTile)
        tileText = ""
        canAdd = tiles.count < 2       /// Keeps flag in sync
        // Wrap noisy debug prints in if debug
        haptics.added()
        saveVMSnapshot()
    }
    
    // MARK: Start a 20-min chunk
    private func startCurrent20MinCountdown(seconds: Int? = nil) async {
        //        guard hasTwoTiles, phase != .running else {
        //            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        //        }
        phase = .running
        sessionActive = true
        // cancels any existing timers
        //        stopCurrent20MinCountdown()
        //        phase = .running
        
        let total = seconds ?? config.chunkDuration
        countdownRemaining = total
        // ContinuousClock avoids wall-clock jumps from time/date changes
        //        runningDeadline = Date().addingTimeInterval(TimeInterval(seconds)) // seconds = chunkDuration
        saveVMSnapshot()
        
        await timeActor.startTicking(
            totalSeconds: total,
            onTick: { [ weak self ] secs in
                Task { @MainActor in self?.countdownRemaining = secs }
            },
            onFinish: { [ weak self] in
                Task { @MainActor in
                    guard let self else { return }
                    self.countdownRemaining = 0
                    if self.phase == .running {
                        self.fireDoneHapticOnce()
                        self.finishCurrentChunk()
                    }
                }
            }
        )
    }
    
    // MARK: Begin overall session (two chunks)
    func beginOverallSession() async throws {
        //        guard hasTwoTiles, (phase == .idle || phase == .none || (phase == .finished && currentSessionChunk == 1)) else {
        //            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        //        }
        guard hasTwoTiles else {
            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        }
        await timeActor.startSessionTracking()
        if phase == .finished && currentSessionChunk == 1 {
            // start next chunk, explicitly //FIXME: should ask Next, per DynamicMessageAndAction
            await startCurrent20MinCountdown()
        } else {
            await startCurrent20MinCountdown()
        }
        //        sessionActive = true
        //        try startCurrent20MinCountdown()
    }
    
    // MARK: User pause / resume
    func pauseCurrent20MinCountdown() async {
        guard phase == .running else { return }
        await timeActor.pauseTicking(currentRemaining: countdownRemaining)
        phase = .paused
        saveVMSnapshot()
    }
    
    func resumeCurrent20MinCountdown() async throws {
        guard phase == .paused else { throw FocusSessionError.unexpected }
        await timeActor.resumeTicking(
            onTick: { [weak self] secs in
                Task { @MainActor in self?.countdownRemaining = secs }
            },
            onFinish: { [weak self] in
                Task { @MainActor in
                    guard let self else { return }
                    self.countdownRemaining = 0
                    if self.phase == .running {
                        self.fireDoneHapticOnce()
                        self.finishCurrentChunk()
                    }
                }
            }
        )
        phase = .running
        saveVMSnapshot()
        
    }
    
    // MARK: App lifecycle (RootView calls these)
    func suspendTickingForBackground() async {
        // 1) Save *VM* snapshot (canonical UI/session)
        saveVMSnapshot()
        // 2) Let actor stop work but keep endInstant so wall-time continues
        await timeActor.suspendForBackground()
        // 3) (Optional) write actor safety snapshot to disk for kill-restore
        if let snap = await timeActor.makeSnapshot() {
            try? await persistence.write(snap, to: "focus.actor.safety")
        }
    }
    
    func resumeTickingAfterForeground() async {
        // First, try the actor‚Äôs monotonic recompute
        if let remaining = await timeActor.remainingAfterForeground() {
            if remaining <= 0 {
                // Finished while away
                phase = .finished
                countdownRemaining = 0
                finishCurrentChunk()
                clearVMSnapshot()
                return
            }
            // Re-arm ticking
            await startCurrent20MinCountdown(seconds: remaining)
            return
        }
        
        // If actor had no state (process kill), try safety snapshot (aux) THEN VM snapshot (canonical)
        if let safety: ContinuousClockActor.Snapshot =
            try? await persistence.readIfExists(ContinuousClockActor.Snapshot.self, from: "focus.actor.safety") {
            
            // Restore into actor and VM scaffolding
            await timeActor.restoreFromSafetySnapshot(safety)
            await startCurrent20MinCountdown(seconds: safety.remainingSeconds)
            try? await persistence.clear("focus.actor.safety")
            return
        }
        
        // Finally, VM snapshot as canonical (e.g., after kill/launch)
        if let vmSnap: VMSnapshot = try? await persistence.readIfExists(VMSnapshot.self, from: vmSnapshotKey) {
            applyVMSnapshot(vmSnap)
            clearVMSnapshot()
            if phase == .running {
                // Recreate ticking respecting paused/running
                if phase == .running {
                    await startCurrent20MinCountdown(seconds: vmSnap.remainingSeconds)
                }
            }
        }
    }
    
    func restoreActiveSessionIfAny() async {
        // On cold launch; reuse the same logic as foreground
        await resumeTickingAfterForeground()
    }
    
    // MARK: End-of-chunk/session
    /// ONLY advancement path; Marks the current chunk complete, advances chunk index once,
    ///     performs end-of-session work when both chunks are done.
    ///     NO NEED for a separate `mark()` or `check()` needed
    func finishCurrentChunk() {
        currentSessionChunk += 1
        if currentSessionChunk >= 2 {
            sessionActive = false
            phase = .finished
            showRecalibrate = true
            
            if let targetCategoryID = historyVM?.generalCategoryID {
                for tile in tiles.prefix(2) {
                    historyVM?.addToHistory(tile, to: targetCategoryID)
                }
            }
        } else {
            phase = .finished   // between chunks; UI will show Next
        }
        // Clear the running deadline; take a snapshot of the new state
        runningDeadline = nil
        saveVMSnapshot()
    }
    
    /// Resets the session state for a new start - non-throwing; async because we `await` the actor
    func resetSessionStateForNewStart() async {
        //        stopCurrent20MinCountdown()                     /// Ensures any running countdown is stopped
        tiles = []
        tileText = ""
        canAdd = true
        sessionActive = false
        showRecalibrate = false
        //        completedTileIDs.removeAll()
        currentSessionChunk = 0
        phase = .none
        countdownRemaining = config.chunkDuration
        didHapticForChunk.removeAll()
        await timeActor.resetSessionTracking()
        clearVMSnapshot()
        //        debugPrint("[FocusVM.resetSessionStateForNewStart] state NOT reset for a new session.")
    }
    
    /// checkmarks + Calls when each 20-min chunk completes:
    /// you persist currentSessionChunk. On restore, new TileM ids are created, so any stored completedTileIDs wouldn‚Äôt match; index-derived stays correct.
    func thisTileIsCompleted(_ tile: TileM) -> Bool {
        guard let idx = tiles.firstIndex(where: { $0.id == tile.id }) else { return false }
        //        completedTileIDs.contains(tile.id)
        return idx < currentSessionChunk
    }
    
    // MARK: Haptics (guard once per chunk)
    // Pattern to call haptic once per completion
    private func fireDoneHapticOnce() {
        guard !didHapticForChunk.contains(currentSessionChunk) else { return }
        didHapticForChunk.insert(currentSessionChunk)
        haptics.notifyDone()            // don't call itself with fireDoneHapticOnce()
    }
    
    // MARK: VM snapshot helpers (canonical)
    private func makeVMSnapshot() -> VMSnapshot {
        VMSnapshot(tileTexts: tiles.map(\.text),
                   phase: phase,
                   chunkIndex: currentSessionChunk,
                   deadline: nil,                       // deadline-based restore
                   remainingSeconds: countdownRemaining,   // always stores a fallback
                   showRecalibrate: showRecalibrate,
                   didHapticForChunk: Array(didHapticForChunk)
        )
    }
    
    private func saveVMSnapshot() {
        let snap = makeVMSnapshot()
        Task { try? await persistence.write(snap, to: vmSnapshotKey) }
    }
    
    private func clearVMSnapshot() {
        Task { await persistence.clear(vmSnapshotKey)}
    }
    
    private func applyVMSnapshot(_ s: VMSnapshot) {
        tiles = s.tileTexts.map { TileM(text: $0) }
        phase = s.phase
        currentSessionChunk = s.chunkIndex
        showRecalibrate = s.showRecalibrate
        didHapticForChunk = Set(s.didHapticForChunk)
        sessionActive = (phase == .running || phase == .paused || currentSessionChunk > 0)
    }
    
    // MARK: Utilities
    var formattedTime: String {
        let minutes = countdownRemaining / 60
        let seconds = countdownRemaining % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
    
    /// Sets flag to trigger recalibration modal
    func checkRecalibrationNeeded() {
        if tiles.count == 2 {
            showRecalibrate = true
        }
    }
    
    //  NOTE: Do not set as a global function - needs to modify `lastError`
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do { try await action() }
            catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
}

extension FocusSessionVM {
    var inputValidationState: ValidationState {
        let msgs = tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    func debugPhaseSummary(_ tag: String = "") -> String {
        "[VM] \(tag) tiles=\(tiles.count) phase=\(phase) remaining=\(countdownRemaining) active=\(sessionActive)"
    }
    
}

/// Error cases for focus session flow
enum FocusSessionError: Error, Equatable, LocalizedError {
    case emptyInput
    case tooManyTiles(limit: Int = 2)
    case invalidBegin(phase: FocusSessionVM.Phase, tilesCount: Int)
    case persistenceFailed
    case unexpected
    
    var errorDescription: String? {
        switch self {
        case .emptyInput: return "Please enter a task, what you intend to do."
        case .tooManyTiles(let limit): return "You can only add \(limit) intentions."
        case .invalidBegin(_, let count): return "Can't begin with \(count) tiles."
        case .persistenceFailed: return "Saving failed. Try again."
        case .unexpected: return "Something went wrong. Please try again."
        }
    }
    
}
-e \n\n
=== ./intention/Features/Focus/FocusSessionActiveV.swift ===
//
//  FocusSessionActiveV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

// FocusSessionActiveV <--> ContentView

import SwiftUI

/// Error types specific to the active session/chunk
enum ActiveSessionError: Error, Equatable, LocalizedError {
    case submitFailed, sessionAlreadyRunning
    
    var errorDescription: String? {
        switch self {
        case .submitFailed: return "Submit failed"
        case .sessionAlreadyRunning: return "A session is already running."
        }
    }
}

/// MembershipSheetV modal sheet presentation handling enum
enum ActiveSheet: Equatable { case none, membership }

/// Primary screen. Accepts two intention tiles and runs a 20-min countdown.
/// Hosts validation UI, dynamic messages and the recalibration sheet
struct FocusSessionActiveV: View {
    
    // MARK: Environment
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var statsVM: StatsVM
    @EnvironmentObject var memVM: MembershipVM
    @Environment(\.dismiss) var dismiss
    @Environment(\.scenePhase) private var phase
    @Environment(\.accessibilityDifferentiateWithoutColor) private var diffNoColor
    
    // MARK: View Models
    @ObservedObject var focusVM: FocusSessionVM
    @ObservedObject var recalibrationVM: RecalibrationVM
 
    // MARK: Local UI State
    /// manages both focus to textfield AND return from background
    /// single flag `showValidation`controls when to show validation checks
    @FocusState private var intentionFocused: Bool
    @State private var showValidation: Bool = false
    @State private var isBusy = false
    @State private var isShowingRecalibrationToDebug = false
    @State private var isShowingOrganizerOverlayToDebug = false
    
    private var isInputActive: Bool { focusVM.phase != .running && focusVM.tiles.count < 2 }
    
    private var vState: ValidationState {
        // Until first submit, stay neutral - charcoal border, no caption)
        guard showValidation else { return .none }
        let msgs = focusVM.tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    
    /// Theme hooks
    private let screen: ScreenName = .focus
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for Focus ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        VStack(spacing: 0){             // Main VStack to control vertical layout
            // All your content that should appear above the tiles
            // The `ScrollView` should be constrained to the available space
            ScrollView {
                // Allows content to breath on small screens
                Page(top: 6, alignment: .center) {
                    StatsSummaryBar()
                    // FIXME: Page {} may be controlling sizing, see if .frame( should be dropped
                    
                    
                    // Text input  validation
                    VStack(alignment: .leading, spacing: 8) {
                        if isInputActive {
                            // onSubmit and primaryCTA both call the same VM method handlePrimaryTap() -> "same funnel"
                            TextField("", text: $focusVM.tileText, prompt: T("Add Your Intended Task", .caption))
                                .focused($intentionFocused)
                                .submitLabel(.done)
                                .validatingField(state: vState, palette: p) // charcoal until showValidation == true & invalid
                                .disabled(!isInputActive)                   // lock after 2
                                .autocorrectionDisabled()
                                .textInputAutocapitalization(.sentences)
                                .onSubmit {
                                    showValidation = true                   // turn validation on
                                    guard vState.isInvalid == false else { return } // stay focused and show message
                                    // Valid -> add
                                    let trimmed = focusVM.tileText.trimmingCharacters(in: .whitespacesAndNewlines)
                                    Task {
                                        do {
                                            _ = try await focusVM.handlePrimaryTap(validatedInput: trimmed)
                                        } catch {
                                            FocusSessionError.unexpected
                                        }
                                    }
                                    focusVM.tileText = ""                   // Clear text field
                                    intentionFocused = (focusVM.tiles.count < 2) // re-focus UNTIL two tiles
                                    showValidation = false                  // reset to neutral for next entry
                                }
                            // Display ValidationCaption BELOW Textfield
                            //      Caption only after first submit AND invalid
                            if showValidation, case .invalid = vState {
                                // Use VState logic for the correct messages
                                ValidationCaption( state: vState)
                                //FIXME: USE THIS BELOW, OR KEEP state: vState, palette: p
                                //                                    state: vState.isInvalid ? vState : .invalid(messages: ["Please enter a task, what you intend to do."]),
                                //                                    palette: p
                                
                            }
                        }
                        // Guidance  Messages (no Add/Begin here)
                        DynamicMessageAndActionArea(
                            focusVM: focusVM,
                            onRecalibrateNow: { focusVM.showRecalibrate = true }
                        )
                        .padding(.top, 8)
                        .environmentObject(theme)
                        //  Centered countdown (its internal own logic self-selects paused/running visuals
                        //      inside it, `isActive` includes .running  .paused
                        //      In .paused, it draws the clipped overlay  "Paused"; in .running, it draws the unwinding pie  time
                        //      The tap target persists across both states, thanks to .onTapGesture { handleTap() }.
                        DynamicCountdown(
                            fVM: focusVM,
                            palette: p,
                            progress: Double(focusVM.countdownRemaining) / Double( TimerConfig.current.chunkDuration )
                        )
                        .padding(.top, 20)  // separates from Stats and messages
                        .frame(maxWidth: .infinity)  // centers fixed-size content
                    }
                    .padding(.top, 8)
                    .onDisappear { intentionFocused = false }
                    .onAppear {
                        focusVM.enterIdleIfNeeded()
                        // Auto-focus on first load, if we still can add text
                        intentionFocused = (focusVM.phase != .running && focusVM.tiles.count < 2)
                    }
                    // Drops focus when we start running or when we leave the screen
                    .onChange(of: focusVM.phase) { phase in
                        if phase == .running { intentionFocused = false }
                    }
                    
                }
            }
            // This spacer pushes the scrollable content to the top,
            // making space for the BottomComposer at the very bottom.
            Spacer(minLength: 0)
            BottomComposer
            // inside the main VStack, ensuring it sits at the bottom
            // and doesn't interfere with the ScrollView.
            // It will be snug against the bottom of the screen.
        }
        //        .onChange(of: focusVM.phase) { _ in
        //            print(focusVM.debugPhaseSummary("phase change"))
        //        }
        
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        // Single bottom chrome: do NOT add an overlay; this keeps it snug to the tab bar
        //      if user taps Close or swipes down, this stops a running recalibration
        .fullScreenCover(isPresented: $focusVM.showRecalibrate) {
            RecalibrationSheetChrome(onClose: {
                    recalibrationVM.performAsyncAction {
                        if recalibrationVM.phase == .running || recalibrationVM.phase == .pause {
                            try await recalibrationVM.stop()
                        }
                    }
                    focusVM.showRecalibrate = false
                }
            ) {
                NavigationStack {
                    RecalibrationV(vm: recalibrationVM) .navigationBarHidden(true)          // own chrome owns the close
                }
            }
        }
        .onDisappear {
            if focusVM.showRecalibrate == false {
                recalibrationVM.performAsyncAction {
                    if recalibrationVM.phase == .running || recalibrationVM.phase == .pause {
                        try await recalibrationVM.stop()
                    }
                }
            }
        }
//        .sheet(isPresented: $showMembership) {
//            // present your membership UI
//            MembershipV()
//        }

    }
    
    
    // MARK: Bottom composer
    @ViewBuilder
    private var BottomComposer: some View {
        //        // Two slots; we present [second, first] visual order by using slots[]
        //        let completedSlotIndex: Int? = (focusVM.currentSessionChunk >= 1) ? 1 : nil
        VStack(spacing: 10){
            ForEach(0..<slots.count, id: \.self) { slot in
                TileSlot(
                    text: slots[slot] ?? "",
                    isFilled: (slots[slot]?.isEmpty == false),
                    isCompleted: completionForSlot(slot),
                    isActive: isActiveSlot(slot),
                    p: p,
                    diffNoColor: diffNoColor
                )
            }
            
            
            Button {
                showValidation = true
                // For Add flow, enforce validation first; for Begin flow canPrimary already handles phase/tiles.
                if focusVM.tiles.count < 2 && vState.isInvalid { return }
                let trimmed = focusVM.tileText.trimmingCharacters(in: .whitespacesAndNewlines)
                Task {
                    do { _ = try await focusVM.handlePrimaryTap(validatedInput: trimmed) }
                    catch { /* show error overlay if desired */ }
                }
                focusVM.tileText = ""
                intentionFocused = (focusVM.tiles.count < 2)
                showValidation = false
            } label: {
                T(focusVM.primaryCTATile, .action).monospacedDigit()
            }
            .primaryActionStyle(screen: screen)
            .frame(maxWidth: .infinity)
            .disabled(!focusVM.canPrimary)
            .accessibilityIdentifier("primaryCTA")
        }
        
        .padding(.top, 12)
        /// tile and begin/add container controls
        .padding(.horizontal, 16)
        .padding(.bottom, 12)
        .background(.thinMaterial)
        .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
        .animation(.easeInOut(duration: 0.2), value: focusVM.tiles)
    }
    
    // MARK: Slot helpers
    /// Visual order = [first, second]
    private var slots: [String?] {
        let first = focusVM.tiles.indices.contains(0) ? focusVM.tiles[0].text : nil
        let second = focusVM.tiles.indices.contains(1) ? focusVM.tiles[1].text : nil
        return [first, second]
    }
    
    /// Completed check uses VM‚Äôs persisted logic so it survives navigation/app relaunch
    private func completionForSlot(_ slot: Int) -> Bool {
        guard focusVM.tiles.indices.contains(slot) else { return false }
        return focusVM.thisTileIsCompleted(focusVM.tiles[slot])
    }
    
    /// Active = white; inactive = brown/gray (segment look)
    private func isActiveSlot(_ slot: Int) -> Bool {
        // 1) Before any tiles exist, guide the user by highlighting Tile 1
        if slot == 0 && !focusVM.tiles.indices.contains(0) { return true }
        
        let firstCompleted  = completionForSlot(0)
        let secondCompleted = completionForSlot(1)
        
        switch slot {
        case 0:
            // 2) Keep tile 1 active until completed
            return focusVM.tiles.indices.contains(0) ? !firstCompleted : true
        case 1:
            // Active after first completes, until second completes
            guard focusVM.tiles.indices.contains(1) else { return false }
            return firstCompleted && !secondCompleted
        default:
            return false
        }
    }
}

// MARK: TileSlot view (compact min height; segment-like look, multi-line text wraps fully,)

private struct TileSlot: View {
    @EnvironmentObject var theme: ThemeManager
    let text: String
    let isFilled: Bool
    let isCompleted: Bool
    let isActive: Bool
    let p: ScreenStylePalette
    let diffNoColor: Bool
    
    // Layout constants
    private let hPad: CGFloat = 10
    private let vPad: CGFloat = 8
    private let minDesiredHeight: CGFloat = 1
    
    // --- Local Color Definitions for Focus ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    private let colorSuccess = Color.green
    
    var body: some View {
        let bg = isActive ? p.surface : p.surface.opacity(0.35)
        let stroke = colorBorder
        
        // MARK: - tiles container
        VStack {
            if isFilled {
                HStack(alignment: .top, spacing: 8) {
                    theme.styledText(text, as: .tile, in: .focus)
                        .foregroundStyle(p.text)
                    // Allow text to wrap to as many lines as needed
                        .lineLimit(nil)
                    // This allows the Text view to expand vertically while being constrained horizontally
                        .fixedSize(horizontal: false, vertical: true)
                    
                    // Fills the button width, actually
                    Spacer(minLength: 8)
                    
                    // Always show a checkmark for filled tiles
                    Image(systemName: isCompleted ? "checkmark.circle.fill" : "checkmark.circle")
                        .font(.body)                        // slightly increases size
                        .foregroundStyle(colorSuccess)   // more vivid than "accent"
                        .accessibilityHidden(true)
                }
                .baselineOffset(1)
                .padding(.horizontal, hPad)
                .padding(.vertical, vPad)
            } else {
                // Empty state - no checkmarks yet
                HStack(alignment: .firstTextBaseline, spacing: 20) {
                    Image(systemName: "text.alignleft").font(.body).accessibilityHidden(true)
                    Text("").foregroundStyle(textSecondary)
                }
                .padding(.horizontal, hPad)
                .padding(.vertical, vPad)
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 10, style: .continuous).fill(bg)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 10, style: .continuous).stroke(stroke, lineWidth: 1)
        )
        //        .frame(minHeight: minDesiredHeight, alignment: .center)
        //    }
        .accessibilityElement(children: .combine)
        .accessibilityLabel(isFilled ? (isCompleted ? "Intention completed" : "Intention") : "Empty slot")
        .accessibilityHint(isFilled ? "" : "Add an intention above, then press Add.")
    }
}



// MARK: - Preview
#if DEBUG
#Preview("Focus") {
    PreviewWrapper {
        FocusSessionActiveV(
            focusVM: PreviewMocks.focusSession,
            recalibrationVM: RecalibrationVM(haptics: NoopHapticsClient())
        )
        .previewTheme()
    }
}
#endif
-e \n\n
=== ./intention/Features/Feedback/FeedbackV.swift ===
//
//  FeedbackV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/21/25.
//

import MessageUI
import SwiftUI


private extension View {
    @ViewBuilder func cardBackground() -> some View {
        background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12, style: .continuous))
        //TODO: Or use .shadow(radius: 3, y: 1)
    }
    @ViewBuilder func fieldClip() -> some View {
        clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
    }
}

struct FeedbackV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    
    @Environment(\.openURL) private var openURL

    // Inputs
    @State private var name: String = ""
    @State private var email: String = ""
    @State private var message: String = ""
    @State private var userID: String = "" // auto-filled

    // Validation states
    @State private var nameState: ValidationState = .none      // optional
    @State private var emailState: ValidationState = .none     // required
    @State private var messageState: ValidationState = .none   // required

    @State private var showComposer = false
    @State private var composerPayload: (subject: String, body: String)? = nil
    @State private var showingAlert = false
    @State private var alertMsg = ""

    private let maxMessageChars = 2000
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for FeedbackV ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    // MARK: Precomputes
    private var trimmedMessage: String {
        message.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    private var messageCountText: String { "\(message.count)/\(maxMessageChars)" }
    private var deviceRowText: String { "Device ID: \(userID)" }
    // --- MAYBE THESE TOO? ---
    private var fieldStrokeShape: RoundedRectangle { .init(cornerRadius: 10, style: .continuous) }
    private var cardShape: RoundedRectangle { .init(cornerRadius: 12, style: .continuous) }

    
    // MARK: Section: Header
    @ViewBuilder private var headerRow: some View {
        T("Send Feedback", .header).cardBackground()
        //TODO: Or use .shadow(radius: 3, y: 1)
    }
    
        // MARK: Section: Name
        @ViewBuilder private var nameSection: some View {
            Group {
                T("Name (optional)", .label)
                Spacer()
                TextField("Jane Doe", text: $name)
                    .textInputAutocapitalization(.words)
                    .autocorrectionDisabled(false)
                    .validatingField(state: nameState, palette: p)
            }
        }

        // MARK: Section: Email
        @ViewBuilder private var emailSection: some View {
            Group {
                T("Email (required)", .label)
                    .cardBackground()

                Spacer()
                TextField("name@example.com", text: $email)
                    .keyboardType(.emailAddress)
                    .textContentType(.emailAddress)
                    .textInputAutocapitalization(.never)
                    .autocorrectionDisabled(true)
                    .validatingField(state: emailState, palette: p)
                ValidationCaption(state: emailState)
            }
        }
        
        // MARK: Section: Message
        @ViewBuilder private var messageSection: some View {
            Group {
                HStack {
                    T("Message", .label)
                        .cardBackground()
                    Spacer()
                    Text(messageCountText)
                        .font(.caption)
                        .foregroundStyle(textSecondary)
                        .monospacedDigit()
                }
                
                TextEditor(text: $message)
                    .frame(minHeight: 160)
                    .textInputAutocapitalization(.sentences)
                    .autocorrectionDisabled(false)
                    .padding(12)
                    .overlay(
                        fieldStrokeShape
                            .stroke(messageState.isInvalid ? colorDanger : colorBorder, lineWidth: 1)
                    )
                    .background(fieldStrokeShape.fill(Color.clear))
                    .fieldClip()
                ValidationCaption(state: messageState)
            }
        }
        
        // MARK: Section: Device Row
        @ViewBuilder private var deviceRow: some View {
            // Auto insert userID/deviceID from your Keychain helper
            T(deviceRowText, .caption)
                .foregroundStyle(textSecondary)
                .textSelection(.enabled)
        }
        
        // MARK: Section: Send button
        @ViewBuilder private var sendButtonSection: some View {
        Button(action: sendTapped) {
            T("Send", .action)
                .cardBackground()
                .monospacedDigit()
        }
        .primaryActionStyle(screen: screen)
        .disabled(!canSend)
    }
        
    // Keep the heavy sheet content out of the main body closure
        // MARK: Mail sheet content
        @ViewBuilder private var composerSheet: some View {
            if MFMailComposeViewController.canSendMail(), let payload = composerPayload {
                MailComposer(
                    to: ["feedback@argonnesoftware.com"],
                    subject: payload.subject,
                    body: payload.body
                ) { result in
                    switch result {
                    case .success:
                        alertMsg = "Thanks! Feedback sent!"
                    case .failure(let err):
                        alertMsg = "Could not send: \(err.localizedDescription)"
                    }
                    showingAlert = true
                }
            } else {
                // Fallback shouldn‚Äôt appear as a sheet; we‚Äôll use openURL instead.
                EmptyView()
            }
        }
    
    // MARK: CanSend: Bool
    private var canSend: Bool {
        emailIsValid(email) && !trimmedMessage.isEmpty
    }

    var body: some View {
        // Email body with useful info for bug reports
        //        let body = "\n\nApp Version: \(version)\nDevice: \(deviceType)\niOS: \(osVersion)"
        
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                headerRow
                nameSection
                emailSection
                messageSection
                deviceRow
                sendButtonSection
            }
            .padding(20)
            .frame(maxWidth: 700, alignment: .leading)
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .navigationTitle("Feedback")
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
        //TODO: Or use .shadow(radius: 3, y: 1)
        .navigationBarTitleDisplayMode(.inline)
        .scrollDismissesKeyboard(.interactively) // swipe down to dismiss
        .safeAreaInset(edge: .bottom) { Color.clear.frame(height: 8) } // keeps content visible above the keyboard on small screens
        .onAppear {
            Task { @MainActor in
                userID = await KeychainHelper.shared.getUserIdentifier()
            }
        }
        .sheet(isPresented: $showComposer) { composerSheet }
        .alert("Feedback", isPresented: $showingAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(alertMsg)
        }
        .onChange(of: message) { new in
            if new.count > maxMessageChars {
                message = String(new.prefix(maxMessageChars))
            }
        }
    }
    
    /// Returns true if we successfully opened a mail client.
    /// UIApplication callers @MainActor (they already run on main, but this clarifies actor isolation)
    // MARK: - MainActor OpenMainTo()
    @MainActor
    @discardableResult
    private func openMailTo(subject: String, body: String) -> Bool {
        let to = "feedback@argonnesoftware.com"

        var comps = URLComponents()
        comps.scheme = "mailto"
        comps.path = to
        comps.queryItems = [
            URLQueryItem(name: "subject", value: subject),
            URLQueryItem(name: "body", value: body)
        ]

        guard let url = comps.url else { return false }

        // Prefer the environment's openURL (respects scene), but also probe UIApplication as a fallback.
        var opened = false
        openURL(url) { success in opened = success }
        if opened { return true }

        // Fallback probe (some contexts call this synchronously)
        if UIApplication.shared.canOpenURL(url) {
            UIApplication.shared.open(url)
            return true
        }

        return false
    }

    // MARK: - SendTapped()
    @MainActor
    private func sendTapped() {
        // validate now (gate surfacing)
        emailState = emailIsValid(email) ? .valid : .invalid(messages: ["Enter a valid email address."])
        messageState = message.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
            ? .invalid(messages: ["Message can‚Äôt be empty."])
            : .valid
        guard canSend else { return }

        let subject = "Intendly Feedback"
        let body = composedBody()
        composerPayload = (subject, body)

        // 1) Try user's default mail client via mailto:
        if openMailTo(subject: subject, body: body) {
            alertMsg = "Your mail app was opened with a pre-filled message."
            showingAlert = true
            return
        }

        // 2) Fallback to in-app composer (Apple Mail backend)
        if MFMailComposeViewController.canSendMail() {
            showComposer = true
            return
        }

        // 3) No handler + no Mail account: show a helpful message
        alertMsg = "No mail app available. Please configure a mail app or copy your message."
        showingAlert = true
    }

    // MARK: ComposedBody()
    private func composedBody() -> String {
        let appVersion = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "?"
        let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "?"
        let sys = UIDevice.current.systemVersion
        let model = UIDevice.current.model

        return """
        Name: \(name.isEmpty ? "(not provided)" : name)
        Email: \(email)
        Device ID: \(userID)
        App: \(appVersion) (\(build)) ‚Ä¢ iOS \(sys) ‚Ä¢ \(model)

        ---- Message ----
        \(message)
        """
    }

    private func fallbackMailToIfNeeded() {
        guard let payload = composerPayload else { return }
        // URL-encode (simple)
        let to = "feedback@argonnesoftware.com"
        let subject = payload.subject.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "Feedback"
        let body = payload.body.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        if let url = URL(string: "mailto:\(to)?subject=\(subject)&body=\(body)") {
            UIApplication.shared.open(url)
        } else {
            alertMsg = "No Mail account is configured and I couldn‚Äôt open a mailto: link."
            showingAlert = true
        }
    }

    private func emailIsValid(_ s: String) -> Bool {
        let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
        guard trimmed.count <= 254 else { return false }
        // Lightweight validation: one @ and at least one dot after
        let parts = trimmed.split(separator: "@")
        guard parts.count == 2, parts[0].count >= 1 else { return false }
        return parts[1].contains(".")
    }
}
-e \n\n
=== ./intention/Features/Feedback/MailComposer.swift ===
//
//  MailComposer.swift
//  intention
//
//  Created by Benjamin Tryon on 10/21/25.
//


import MessageUI
import SwiftUI

struct MailComposer: UIViewControllerRepresentable {
    let to: [String]
    let subject: String
    let body: String
    let onComplete: (Result<Void, Error>) -> Void

    final class Coordinator: NSObject, MFMailComposeViewControllerDelegate {
        let parent: MailComposer
        init(_ parent: MailComposer) { self.parent = parent }
        func mailComposeController(_ controller: MFMailComposeViewController,
                                   didFinishWith result: MFMailComposeResult,
                                   error: Error?) {
            controller.dismiss(animated: true) {
                if let error { self.parent.onComplete(.failure(error)) }
                else { self.parent.onComplete(.success(())) }
            }
        }
    }

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIViewController(context: Context) -> MFMailComposeViewController {
        let vc = MFMailComposeViewController()
        vc.setToRecipients(to)
        vc.setSubject(subject)
        vc.setMessageBody(body, isHTML: false)
        vc.mailComposeDelegate = context.coordinator
        return vc
    }

    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}
}
-e \n\n
=== ./intention/Features/Social/ShareService.swift ===
//
//  ShareService.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct ShareService: View {
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/"Hello, World!"/*@END_MENU_TOKEN@*/)
    }
}

#if DEBUG
#Preview {
    ShareService()
}
#endif
-e \n\n
=== ./intention/Features/History/HistoryV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
/// content-management screen with an explicit Edit/Done mode
struct HistoryV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var viewModel: HistoryVM
    @Environment(\.editMode) private var editMode
    
    // UI State
    //    @State private var newTextTiles: [UUID: String] = [:]       /// Store new tile text per category using its `id` as key
    @State private var isOrganizing = false
    @State private var showOrganizerOverlay = false
    @State private var showErrorOverlay = false
    @State private var createdCategoryID: UUID?
    @State private var targetCategoryID: UUID?
    @State private var showRenamePicker = false
    @State private var showDeletePicker = false
    @State private var showRenameSheet = false
    @State private var renameText = ""
    @State private var showDeleteConfirm = false
    @State private var isBusy = false
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ScrollView {
            Page(top: 6, alignment: .center) {
                
                LazyVStack(alignment: .leading, spacing: 8) {
                    // $Bindings are so rows can edit categories
                    ForEach($viewModel.categories) { $category in
                        CategoryCard(
                            category: $category,
                            isArchive: category.id == viewModel.archiveCategoryID,
                            onRename: { id in
                                targetCategoryID = id
                                renameText = viewModel.name(for: id)
                                showRenameSheet = true
                            },
                            onDelete: { id in
                                targetCategoryID = id
                                showDeleteConfirm = true
                            }
                        )
                        .id(category.id)
                        //                        .padding(.vertical, 12)
                        //                        .padding(.horizontal, 16)
                        //                        .environmentObject(theme)
                        // -- category separator --
                        Rectangle()
                            .fill(colorBorder)
                            .frame(height: 1)
                            .padding(.vertical, 4)
                    }
                }
                //                Divider().overlay(Color.intTan)
                //                .padding(.vertical, 12)
            }
            // Toasts
            VStack(spacing: 8) {
                if let move = viewModel.lastUndoableMove {
                    HStack {
                        //                        Text("\(move.tile.text) moved").font(.footnote)
                        //                        Spacer()
                        Button {viewModel.undoLastMove()} label: { T("Undo?", .action) }.primaryActionStyle(screen: screen)
                    }
                    .padding(.horizontal, 12)           // Card instead?
                    .padding(.vertical, 10)             // Card instead?
                    .background(.ultraThinMaterial, in: Capsule())
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
                
                if viewModel.tileLimitWarning {
                    T("Archive capped at 200; oldest items were removed.", .caption)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 10)
                        .background(.ultraThinMaterial, in: Capsule())
                        .task {
                            try? await Task.sleep(nanoseconds: 2_000_000_000)
                            await MainActor.run { viewModel.tileLimitWarning = false }
                        }
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
        }
        .background(p.background)
        .opacity(1)     // so the history background wins against organizerOverlay
        .zIndex(0)      // so the history background wins against organizerOverlay
        .tint(p.accent)
        .animation(.easeInOut(duration: 0.2), value: viewModel.lastUndoableMove != nil)
        .toolbar { historyToolbar }.environmentObject(theme)
        /// [.medium] is half-screen, .visible affordance
        .sheet(isPresented: $showRenameSheet) {
            renameSheet
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
        .alert("Delete category?", isPresented: $showDeleteConfirm) {
            Button("Delete", role: .destructive) {
                if let id = targetCategoryID {
                    Task { _ = viewModel.deleteCategory(id: id) }
                }
            }
            Button("Cancel", role: .cancel) { }
        } message: { Text("Tiles will be moved to Archive.") }
        
        //        // Organizer overlay (your fullScreenCover is driven by isOrganizing)
        //            .onReceive(NotificationCenter.default.publisher(for: .devOpenOrganizerOverlay)) { _ in
        //                withAnimation { isOrganizing = true }
        //            }
        
        // Error overlay
        //            .onReceive(NotificationCenter.default.publisher(for: .debugShowSampleError)) { _ in
        //                showErrorOverlay = true
        //            }
        //            .overlay {
        //                if showErrorOverlay {
        //                    ErrorOverlayV(onClose: { showErrorOverlay = false })
        //                }
        //            }
            .fullScreenCover(isPresented: $isOrganizing
                             //                             //FIXME: - Does this =work without onDismiss?
                             //                             onDismiss: { viewModel.flushPendingSaves() }
            ) {
                OrganizerOverlayChrome(onClose: {
                    //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                    //                    viewModel.flushPendingSaves()
                    isOrganizing = false
                }) {
                    OrganizerOverlayScreen(
                        categories: $viewModel.categories,
                        onMoveTile: { tile, sourceID, destinationID in
                            Task { @MainActor in
                                do { try await viewModel.moveTileThrowing(tile, fromCategory: sourceID, toCategory: destinationID) }
                                catch { viewModel.lastError = error }
                            }
                        },
                        onReorder: { newTiles, categoryID in
                            // reorderTiles already applies caps AND persists, saveHistory() isn't needed
                            viewModel.reorderTiles(newTiles, in: categoryID)
                        },
                        onDone: {
                            // close path X/drag like RecalibrationChrome
                            //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                            // viewModel.flushPendingSaves()
                            isOrganizing = false
                        }
                    )
                    .environmentObject(theme)
                }
                // Chrome owns gesture/X dismissal
                .interactiveDismissDisabled(true)
            }
        // HistoryV: the flush in .task(id: isOrganizing) when it becomes false,
        // - happens ONCE here, when the cover closes
            .task(id: isOrganizing) {
                // On leaving organize mode, force-flush pending saves.
                if !isOrganizing { viewModel.flushPendingSaves() }
            }
            .overlay {
                if let error = viewModel.lastError {
                    ErrorOverlay(error: error) { viewModel.setError(nil) }
                        .transition(.opacity.combined(with: .scale))
                        .zIndex(1)
                        .allowsHitTesting(true)     // opt-in to hits only when visible
                }
            }
        Spacer(minLength: 0)
    }
    
    
    //    @ToolbarContentBuilder private var historyToolbar: some ToolbarContent {
    //        ToolbarItemGroup(placement: .topBarTrailing) {
    @ToolbarContentBuilder
    private var historyToolbar: some ToolbarContent {
        ToolbarItemGroup(placement: .topBarTrailing) {
            Button {
                if isOrganizing { viewModel.flushPendingSaves() }
                withAnimation { isOrganizing.toggle() }
            } label: {
                Label(
                    isOrganizing ? "Done" : "Edit", systemImage: "arrow.up.arrow.down"
                ).foregroundStyle(p.primary)
            }
            
            Menu {
                Button("Rename Category") {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        renameText = viewModel.name(for: only)
                        showRenameSheet = true
                    } else {
                        showRenamePicker = true
                    }
                }
                
                Button("Delete Category", role: .destructive) {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        showDeleteConfirm = true
                    } else {
                        showDeletePicker = true
                    }
                }
                
                Divider()
                
                Button("Add Category") {
                    if let id = viewModel.addEmptyUserCategory() {
                        createdCategoryID = id
                    }
                }
                .disabled(!viewModel.canAddUserCategory())
            } label: {
                Image(systemName: "ellipsis.circle").foregroundStyle(p.primary)
            }
        }
    }
    
    
    @ViewBuilder private var renameSheet: some View {
        NavigationStack {
            Form {
                Section("New Name") {
                    TextField("Category name", text: $renameText)
                        .textInputAutocapitalization(.words)
                        .disableAutocorrection(true)
                    
                    Button { Task { viewModel.canAddUserCategory() } } label: { T("Rename Category", .action) }
                        .primaryActionStyle(screen: screen)
                }
            }
            .navigationTitle("Rename")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { showRenameSheet = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        if let id = targetCategoryID {
                            viewModel.renameCategory(id: id, to: renameText.trimmingCharacters(in: .whitespacesAndNewlines))
                        }
                        showRenameSheet = false
                    }
                    .disabled(renameText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
        }
        .presentationDetents([.medium])
    }
}
// UUID helper
extension Array {
    var only: Element? { count == 1 ? first : nil }
}

// MARK: - Category Card (private) = Header  Tile List
///composes CategoryHeaderRow  CategoryTileList with the rounded card chrome. Keeping it private avoids scattering styling across files and keeps the view tree simple
private struct CategoryCard: View {
    @Binding var category: CategoriesModel
    let isArchive: Bool
    var onRename: (UUID) -> Void
    var onDelete: (UUID) -> Void
    @EnvironmentObject private var viewModel: HistoryVM
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            CategoryHeaderRow(
                title: isArchive ? "Archive" : category.persistedInput.ifEmpty("Untitled"),
                count: category.tiles.count,
                isArchive: isArchive,
                allowEdit: !isArchive && category.id != viewModel.generalCategoryID,
                onRename: { onRename(category.id) },
                onDelete:  { onDelete(category.id) }
            )
            
            CategoryTileList(category: $category, isArchive: isArchive)
                .padding(.vertical, 12)
            //                .frame(maxWidth: .infinity, alignment: .leading)
                .environmentObject(viewModel)
        }
        //        .padding(.horizontal, 16)
        //        .background(Color.clear)
        //        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

// UUID helper
private extension String {
    func ifEmpty(_ replacement: String) -> String { isEmpty ? replacement : self }
}

#if DEBUG
extension HistoryV {
    init(
        viewModel: HistoryVM,
        _preview_isOrganizing: Bool = false,
        _preview_showRenameSheet: Bool = false,
        _preview_targetCategoryID: UUID? = nil,
        _preview_renameText: String = ""
    ) {
        self.viewModel = viewModel
        _isOrganizing    = State(initialValue: _preview_isOrganizing)
        _showRenameSheet = State(initialValue: _preview_showRenameSheet)
        _targetCategoryID = State(initialValue: _preview_targetCategoryID)
        _renameText      = State(initialValue: _preview_renameText)
    }
}
#endif


// Mock/ test data prepopulated
#if DEBUG
#Preview("Populated Preview History") {
    MainActor.assumeIsolated {
        let historyVM = HistoryVM(persistence: PersistenceActor())
        historyVM.ensureGeneralCategory()
        
        if let generalID = historyVM.categories.first?.id {
            historyVM.addToHistory(TileM(text: "Color background from gray-ish to history Tan"), to: generalID)
            historyVM.addToHistory(TileM(text: "Define Dividers as the light tan"), to: generalID)
        }
        
        return PreviewWrapper {
            HistoryV(viewModel: historyVM)
                .previewTheme()
        }
    }
}
#endif

#if DEBUG
#Preview("History ‚Äî Organizer Overlay") {
    MainActor.assumeIsolated {
        // Build a self-contained HistoryVM with some tiles
        let h = HistoryVM(persistence: PersistenceActor())
        h.ensureGeneralCategory()
        h.ensureArchiveCategory()
        
        if let userID = h.addEmptyUserCategory() {
            h.renameCategory(id: userID, to: "Projects")
            h.addToHistory(TileM(text: "Refactor the organizerOverlay"), to: userID)
            h.addToHistory(TileM(text: "Add accessibility"), to: userID)
            h.addToHistory(TileM(text: "Debug accessibility"), to: userID)
            h.addToHistory(TileM(text: "Ship v1"), to: userID)
            h.addToHistory(TileM(text: "Prep screenshots"), to: userID)
        }
        
        return PreviewWrapper {
            // Force organizer overlay ON for preview
            HistoryV(viewModel: h, _preview_isOrganizing: true)
        }
    }
}
#endif
-e \n\n
=== ./intention/Features/History/ArchiveActor.swift ===
//
//  ArchiveActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/26/25.
//

import Foundation
// dedicated actor to handle offloading old tiles
// receives a [CategoriesModel], trims tiles beyond the 200 tile cap and persist

/// Purpose: points to a tile where it lives without copying text or timeStamp. Different than TileM (the full model) and different than TileOrganizerVM (a ViewModel for UI organizing)
/// Identity used for offloading between actors
struct TileRef: Hashable, Codable, Sendable {
    let categoryID: UUID
    let tileID: UUID
}

/// Purpose: archives tiles into persistent list
/// dedicated, thread-safe manager - handles offloading into archive from "live" categories dedicated, thread-safe manager for archiving tiles. It handles offloading old tiles from live categories to a persistent archive, ensuring the total count of tiles remains below a specified limit.
/// The **only store of Archive tiles** (authoritative for Archive contents

actor ArchiveActor {
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let archiveKey = "archivedTiles"
//
//    struct OffloadResult: Sendable, Codable {
//        let archived: [TileM]           /// full tiles archived first, and in the bottom most location of the archive
//        let refs: [TileRef]             /// exact locations the tiles came from
//    }
//    
//    /// Offload tiles to archive storage, top-first, **excluding** Archive category
//    /// - Parameters:
//    ///     - categories: to consider
//    ///     - maxTiles: cap for *live* tiles (General + user categories)
//    /// - Returns: OffloadResult with exact refs & tiles archived; Empty if no overflow
//    func offloadOldTiles(from categories: [CategoriesModel], maxTiles: Int) async throws {
//        // 1) Flatten only non-Archive categories (HistoryVM will pass those; this is defensive)
//        let live = categories
//        // 2) oldest/bottom first across live times
//        let all = live.flatMap(\.tiles).sorted { $0.timeStamp < $1.timeStamp }
//        let overflowCount = max(0, all.count - maxTiles)
//        guard overflowCount > 0 else { return }
//        
//        // the oldest overflow that must be offloaded
//        let toArchive = Array(all.prefix(overflowCount))  // take the oldest overflow
//
//        // 3) Append to existing archive (keep newest at top in storage)
//        let existing = await loadArchivedTiles()
//        var combined = toArchive.reversed() + existing     // put ‚Äúnewly archived‚Äù on top
//        if combined.count > maxTiles {
//            combined.removeLast(combined.count - maxTiles) // drop oldest from bottom
//        }
//
//        let data = try encoder.encode(combined)
//        UserDefaults.standard.set(data, forKey: archiveKey)
//        #if DEBUG
//        debugPrint("ArchiveActor: Archived \(toArchive.count) tiles. Archive total: \(combined.count)")
//        #endif
//    }
    
    // Write/load archived tiles for testing or restoration.
    func loadArchivedTiles() async -> [TileM] {
        guard let data = UserDefaults.standard.data(forKey: archiveKey) else { return [] }
        do { return try decoder.decode([TileM].self, from: data) } catch { debugPrint("ArchiveActor: decode archived tiles failed:", error); return [] }
    }
    
    // Update on every Archive mutation
    func saveArchivedTiles(_ tiles: [TileM]) async {
        if let data = try? encoder.encode(tiles) {
            UserDefaults.standard.set(data, forKey: archiveKey)
        }
    }
    
    // Clear archive for testing/reset
    func clearArchive() { UserDefaults.standard.removeObject(forKey: archiveKey) }
}
-e \n\n
=== ./intention/Features/History/HistoryVM.swift ===
//
//  HistoryVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

enum HistoryError: Error, Equatable, LocalizedError {
    case categoryNotFound, historyNotLoaded, saveHistoryFailed, moveFailed

    var errorDescription: String? {
        switch self {
        case .categoryNotFound: return "Category not found."
        case .historyNotLoaded: return "History not loaded."
        case .saveHistoryFailed: return "Could not save history."
        case .moveFailed: return "Tile move failed."
        }
    }
}

/// VM decides *when*, persistence/actors decide *how*.
/// Single source of truth for General/Archive IDs and category ordering.
@MainActor
final class HistoryVM: ObservableObject {
    // MARK: - Published UI state
        @Published var categories: [CategoriesModel] = []
        @Published var categoryValidationMessages: [UUID: [String]] = [:]
        @Published var tileLimitWarning: Bool = false
        @Published var lastUndoableMove: (tile: TileM, from: UUID, to: UUID)?
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    
    // MARK: - Dependencies
    private let persistence: any Persistence
    private let archiveActor = ArchiveActor()

    // MARK: - Storage keys / caps / debounce
    private let storageKey = "categoriesData"
    private let tileSoftCap = 200                      // Archive cap
    private var pendingSnapshot: [CategoriesModel]?
    private var debouncedSaveTask: Task<Void, Never>?
    private var lastSavedSignature: Int = 0
    private let saveDebouncedDelayNanos: UInt64 = 300_000_000 // 300 ms
    
    // MARK: - Canonical IDs (persisted)
    @AppStorage("generalCategoryID") private var generalCategoryIDString: String = ""
    @AppStorage("archiveCategoryID") private var archiveCategoryIDString: String = ""

    var generalCategoryID: UUID {
        get { UUID(uuidString: generalCategoryIDString) ?? { let u = UUID(); generalCategoryIDString = u.uuidString; return u }() }
        set { generalCategoryIDString = newValue.uuidString }
    }
    var archiveCategoryID: UUID {
        get { UUID(uuidString: archiveCategoryIDString) ?? { let u = UUID(); archiveCategoryIDString = u.uuidString; return u }() }
        set { archiveCategoryIDString = newValue.uuidString }
    }
    
    // MARK: - Init
    init(persistence: any Persistence) {
        self.persistence = persistence
        Task { await loadHistory() }
    }
    
    func setError(_ error: Error?) { lastError = error }

    // MARK: - Load / Bootstrap / Reconcile
       private func loadHistory() async {
           do {
               // 1) Load categories from disk (without Archive tiles; those hydrate from ArchiveActor)
               if let loaded: [CategoriesModel] = try await persistence.readIfExists([CategoriesModel].self, from: storageKey) {
                   categories = loaded
               } else {
                   categories = []
               }

               // 2) Reconcile built-in IDs by name, if present
               if let g = categories.first(where: { $0.persistedInput == "General" }) { generalCategoryID = g.id }
               if let a = categories.first(where: { $0.persistedInput == "Archive" }) { archiveCategoryID = a.id }

               // 3) Ensure both built-ins exist using canonical IDs
               if !categories.contains(where: { $0.id == generalCategoryID }) {
                   categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
               }
               if !categories.contains(where: { $0.id == archiveCategoryID }) {
                   categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
               }

               // 4) Hydrate Archive tiles from ArchiveActor and enforce cap (now that the archive ID is canonical)
               let archived = await archiveActor.loadArchivedTiles()
               if let aIdx = categories.firstIndex(where: { $0.id == archiveCategoryID }) {
                   categories[aIdx].tiles = archived
                   applyCaps(afterInsertingIn: aIdx) // trims if > 200 and mirrors back to actor
               }

               // 5) /Persist if anything changed during steps 2‚Äì4
               // keeps data in order
               normalizeCategoryOrder()
               // save the sanitized (Archive-empty) snapshot
               saveHistory()

           } catch {
               debugPrint("[HistoryVM.loadHistory] error:", error)
               lastError = error
           }
       }

       /// Reconcile built-ins again on demand; then persist.
       func reconcileAndEnsureBuiltIns() {
           // 1) If categories already contain built-ins, prefer those IDs and write them back to AppStorage.
           if let g = categories.first(where: { $0.persistedInput == "General" }) { generalCategoryID = g.id }
           if let a = categories.first(where: { $0.persistedInput == "Archive" }) { archiveCategoryID = a.id }
           
           // 2) Ensure both exist using the canonical IDs (lazily created if empty).
           if !categories.contains(where: { $0.id == generalCategoryID }) {
               categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
           }
           if !categories.contains(where: { $0.id == archiveCategoryID }) {
               categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
           }
           
           // the debounced/immediate server
           normalizeCategoryOrder()
           saveHistory()
       }
    
    // MARK: - Ordering (Canonical - General -> A-Z users, cats -> Archive)

    /// Rebuilds array as: General ‚Üí (user categories, A‚ÄìZ by name) ‚Üí Archive
    /// Call after *every* mutation that could affect order.
    fileprivate func normalizeCategoryOrder() {
        // 1) Pull out General + Archive
        guard
            let gIdx = categories.firstIndex(where: { $0.id == generalCategoryID }),
            let aIdx = categories.firstIndex(where: { $0.id == archiveCategoryID })
        else { return }

        let general = categories[gIdx]
        let archive = categories[aIdx]
        
        // 2) Everything else (user categories) in alphabetical
        let users = categories
            .filter { $0.id != generalCategoryID && $0.id != archiveCategoryID }
            .sorted { $0.persistedInput.localizedCaseInsensitiveCompare($1.persistedInput) == .orderedAscending }
        // 3) Rebuild: General first ‚Üí users ‚Üí Archive last
        categories = [general] + users + [archive]
    }
    
    // MARK: - Sanitization & Persistence
    // sanitizedForSave() and performSaveIfChanged - Persist categories without the Archive tiles. Hydrate Archive tiles on load from ArchiveActor
    private func sanitizedForSave(_ cats: [CategoriesModel]) -> [CategoriesModel] {
        cats.map { category in
            var copy = category
            if category.id == archiveCategoryID { copy.tiles = [] }     // keep Archive empty in categoriesData - Archive tiles live in ArchiveActor
            return copy
        }
    }
    
    private func saveSignature(for categories: [CategoriesModel]) -> Int {
        var acc = categories.count
        for cat in categories {
            acc = acc &* 31 &+ cat.id.hashValue &+ cat.tiles.count  //// Mixes ID + tile count
        }
        return acc
    }
    
    // Writes only if content changed since last success - if `snapshot` is nil, uses live `categories`
    private func performSaveIfChanged(_ snapshot: [CategoriesModel]? = nil) async {
        let raw = snapshot ?? categories
        let toWrite = sanitizedForSave(raw)
        let signature = saveSignature(for: toWrite)               // compare sanitized - not raw
        guard signature != lastSavedSignature else { return }
        do {
            try await persistence.write(toWrite, to: storageKey)
            lastSavedSignature = signature
        } catch {
            debugPrint("[HistoryVM.performSaveIfChanged] error: ", error)
            await MainActor.run { self.lastError = HistoryError.saveHistoryFailed }
        }
    }
    
    /// Public save entrypoint.
       func saveHistory(immediate: Bool = false) {
           if immediate {
               let snapshot = categories
               pendingSnapshot = nil
               debouncedSaveTask?.cancel()
               debouncedSaveTask = nil
               Task { await performSaveIfChanged(snapshot) }
               return
           }
           scheduleDebouncedSave()
       }


    private func scheduleDebouncedSave() {
        let snapshot = categories       // Capture now; UI may keep mutating
        pendingSnapshot = snapshot

        debouncedSaveTask?.cancel()
        debouncedSaveTask = Task { [weak self, snapshot ] in
            guard let self else { return }
            try? await Task.sleep(nanoseconds: saveDebouncedDelayNanos)
            await self.performSaveIfChanged(snapshot)
            await MainActor.run { self.pendingSnapshot = nil }
        }
    }

    // Call on scenePhase changes, or when leaving organizer mode.
    func flushPendingSaves() {
        let snapshot = pendingSnapshot
        pendingSnapshot = nil
        debouncedSaveTask?.cancel()
        debouncedSaveTask = nil
        Task { [snapshot] in await performSaveIfChanged(snapshot) } // falls back to/uses live categories if nil
    }
    
    // MARK: - Category CRUD
    func addCategory(persistedInput: String) {
        let newCategory = CategoriesModel(persistedInput: persistedInput)
        categories.append(newCategory)
        normalizeCategoryOrder()
        saveHistory()
    }
    
    /// Adds an empty user category if allowed and returns its id (for autofocus)
    @discardableResult
    func addEmptyUserCategory(limit: Int = 2) -> UUID? {
        guard canAddUserCategory(limit: limit) else { return nil }
        let new = CategoriesModel(persistedInput: "")
        categories.append(new)
        normalizeCategoryOrder()
        saveHistory()
        return new.id
    }

    /// Rename category and persist. Validates and coalesces via saveHistory(). IF General is renamed...
    @MainActor
       func renameCategory(id: UUID, to newNameRaw: String) {
           let newName = newNameRaw.trimmingCharacters(in: .whitespacesAndNewlines)
           guard !newName.isEmpty else { return }
           guard let idx = categories.firstIndex(where: { $0.id == id }) else { lastError = HistoryError.categoryNotFound; return }
           
           let renamingGeneral = (id == generalCategoryID)
           categories[idx].persistedInput = newName
           validateCategory(id: id, title: newName)
           
           // If General is renamed, create a new empty "General" and repoint the anchor
           if renamingGeneral && newName != "General" {
                      let newGeneral = CategoriesModel(id: UUID(), persistedInput: "General", tiles: [])
//                      categories.insert(newGeneral, at: 0)         // temp‚Äînormalize will place correctly //FIXME: Use *.insert* or *.append*
               categories.append(newGeneral)
                      generalCategoryID = newGeneral.id            // didSet also normalizes (see below)
           }
           
           normalizeCategoryOrder()
           saveHistory()
       }

       /// Delete a user-defined category. Tiles are moved to Archive first (safe).
       @discardableResult
       func deleteCategory(id: UUID) -> Bool {
           // 1) Prevent permanently deleting anchors
           guard id != generalCategoryID, id != archiveCategoryID else { return false }
           guard
               let delIdx = categories.firstIndex(where: { $0.id == id }),
               let archIdx = categories.firstIndex(where: { $0.id == archiveCategoryID })
           else { lastError = HistoryError.categoryNotFound ; return false }

           // 2) Move tiles to Archive, "top locally" first
           let moving = categories[delIdx].tiles
           if !moving.isEmpty {
               categories[archIdx].tiles.insert(contentsOf: moving, at: 0)
               applyCaps(afterInsertingIn: archIdx)                         // 3) Trims and mirrors to actor
               
               //FIXME: This or
//               let arch = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
//               Task { await archiveActor.saveArchivedTiles(arch) }
               
               //FIXME: This? Which acts as we need it to?
           }

           categories.remove(at: delIdx)
           normalizeCategoryOrder()
           saveHistory()
           return true
       }

    // MARK: - Tiles API
    /// Called by Focus on completion; safe regardless of UI order (uses IDs).
    func addToHistory(_ newTile: TileM, to categoryID: UUID) {
        guard let index = categories.firstIndex(where: {  categoryItem in       // $0.id == categoryID
            categoryItem.id == categoryID
        }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            self.lastError = HistoryError.categoryNotFound
            return
        }
        /// Newest-first for UI display; enforce caps (Archive = 200, General and user-defined=10);
        categories[index].tiles.insert(newTile, at: 0)
        applyCaps(afterInsertingIn: index)
        saveHistory()
        /// If you do want a click here later, trigger it from the view after a successful action using your HapticsService env object, not from the VM
    }
    
    // MARK: valid target to call to move tiles within categories
    // Enforced (yes #2)
    func transferTile(_ tile: TileM, fromCategory sourceID: UUID, toCategory destinationID: UUID) {
        Task {
            do { try await moveTileThrowing(tile, fromCategory: sourceID, toCategory: destinationID) }
            catch { await MainActor.run { self.lastError = error } }
        }
    }

    func undoLastMove() {
        guard let move = lastUndoableMove else { return }
        Task {
            do {
                try await moveTileThrowing(move.tile, fromCategory: move.to, toCategory: move.from)
                await MainActor.run { self.lastUndoableMove = nil }
            } catch {
                debugPrint("[HistoryVM.undoLastMove] error: ", error)
                await MainActor.run { self.lastError = error }
            }
        }
    }
    
    /// UI-friendly sugar for cross-category moves that funnels to the canonical thrower.
    /// Keeps call sites readable without duplicating core logic.
    func moveTileBetweenCategories(_ tile: TileM, fromCategory sourceCategoryID: UUID, toCategory destinationCategoryID: UUID) {
        Task {
            do { try await moveTileThrowing(tile, fromCategory: sourceCategoryID, toCategory: destinationCategoryID) }
            catch { await MainActor.run { self.lastError = error } }
        }
    }
    
    // MARK: Wrapper for call-site (RootView) clarity
    /// Reorder tiles within the given category. Validates, re-applies caps, persists.
    // (yes #2)
    func reorderTiles(_ newOrder: [TileM], in categoryID: UUID){
        guard let idx = categories.firstIndex(where: { $0.id == categoryID } ) else { return }
        categories[idx].tiles = newOrder
        applyCaps(afterInsertingIn: idx)
        saveHistory()           // VM decides *when* to persist
    }
    
    //(yes #2)
    /// Replace an entire category‚Äôs tiles (e.g., within-category reorder).
    func updateTiles(in categoryID: UUID, to newTiles: [TileM]) {
        guard let index = categories.firstIndex(where: { $0.id == categoryID }) else { return }
            categories[index].tiles = newTiles
            /// does the Archive=200 / General+2=10 trims
            applyCaps(afterInsertingIn: index)
            saveHistory()       /// Persist change
        }
    
    /// If a VC provides a full category order, we still re-assert canonical order afterward.
    func reorderCategories(_ newOrder: [CategoriesModel]) {
        categories = newOrder
        normalizeCategoryOrder()            // General first, Archive last
        saveHistory()
    }
    
    /// Validation function to be called from the view
    // FIXME: Needed?
    func validateCategory(id: UUID, title: String) {
        let messages = title.categoryTitleMessages
        if messages.isEmpty { categoryValidationMessages.removeValue(forKey: id) } else { categoryValidationMessages[id] = messages }
    }
    
    // MARK: Caps & Archive sync
    /// Cap rules for all categories
    private func applyCaps(afterInsertingIn idx: Int) {
        let catID = categories[idx].id
        
        // 1) Archive cap: 200 (dropping oldest to bottom)
        if catID == archiveCategoryID {
            let overflow = categories[idx].tiles.count - tileSoftCap    // tileSoftCap == 200
            if overflow > 0 {
                categories[idx].tiles.removeLast(overflow)
                tileLimitWarning = true                             // An FYI for the user
            }
            // Keep ArchiveActor authoritative
            let intoArchive = categories[idx].tiles
            Task { await archiveActor.saveArchivedTiles(intoArchive) }
            return
        }

        // 2) Build the dynamic "capped@10" set: General + first two user-defined categories
        //    (user-defined = not General, not Archive). Uses current array order.
        let userIDs = categories
            .map(\.id)
            .filter { $0 != generalCategoryID && $0 != archiveCategoryID }

        var capped10 = Set<UUID>()
        capped10.insert(generalCategoryID)
        for id in userIDs.prefix(2) { capped10.insert(id) }

        if capped10.contains(catID) {
            let overflow = categories[idx].tiles.count - 10
            if overflow > 0 { categories[idx].tiles.removeLast(overflow) }
        }
    }
    
    
   // MARK: Utilities / Convenience
    /// User-defined categories (not General/Archive)
//       var userCategoryIDs: [UUID] {
//           categories.map(\.id).filter { $0 != generalCategoryID && $0 != archiveCategoryID }
//       }
    
    var userDefinedCategoryCount: Int {
//        categories.filter { $0.id != generalCategoryID && $0.id != archiveCategoryID }.count
        userCategoryIDs.count
    }
    
    func canAddUserCategory(limit: Int = 2) -> Bool {
        userDefinedCategoryCount < limit
    }

//       func name(for id: UUID) -> String {
//           categories.first(where: { $0.id == id })?.persistedInput ?? ""
//       }
    
    /// Sets automatic "General" category aka "bootstrapping"
    func ensureGeneralCategory(named name: String = "General") {
        let generalID = generalCategoryID
        if !categories.contains(where: { generalCategoryItem in generalCategoryItem.id == generalID }) {
            let new = CategoriesModel(id: generalID, persistedInput: name)
            categories.append(new)                                                      //FIXME: use `.insert(new, at: 0)` instead?
//            debugPrint("[HistoryVM.ensureGeneralCategory] error creating 'General'")
            normalizeCategoryOrder()
            saveHistory()
        }
    }
    
    // MARK: - Sets automatic Archive category aka "bootstrapping"
    func ensureArchiveCategory(named name: String = "Archive") {
        let archiveID = archiveCategoryID
        if !categories.contains(where: { archiveCategoryItem in archiveCategoryItem.id == archiveID }) {
            let new = CategoriesModel(id: archiveID, persistedInput: name)
            categories.append(new)                                                  //FIXME: use `.insert(new, at: 0)` instead?
//            debugPrint("[HistoryVM.ensureArchiveCategory] error creating 'Archive'")
            normalizeCategoryOrder()
            saveHistory()
        }
    }
    
    // RESETS all categories: clears model first; persists a cleared list; clear storage safely: see PersistenceActor
    func clearHistory() {
        categories = []
        saveHistory()
        Task {  await persistence.clear(storageKey); await archiveActor.clearArchive() }
    }
    
    // MARK: - Throwing save (direct)
    func saveHistoryThrowing() async throws {
        try await persistence.write(sanitizedForSave(categories), to: storageKey)
    }
    
    // MARK: - Convenience throwers for call sites that want explicit errors
    func addToHistoryThrowing(_ tile: TileM, to categoryID: UUID) async throws {
        guard let index = categories.firstIndex(where: {  categoryItem in categoryItem.id == categoryID }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            throw HistoryError.categoryNotFound
        }
        categories[index].tiles.insert(tile, at: 0)
        applyCaps(afterInsertingIn: index)
        saveHistory()
    }
    
    // (yes #2)
    /// For cross-category moves: awaiting archive persistence before returning
    func moveTileThrowing(_ tile: TileM, fromCategory sourceID: UUID, toCategory destinationID: UUID) async throws {
        guard
            let fromIndex = categories.firstIndex(where: { $0.id == sourceID }),
            let toIndex = categories.firstIndex(where: { $0.id == destinationID }),
            let tileIndex = categories[fromIndex].tiles.firstIndex(of: tile)
        else { debugPrint("[HistoryVM.moveTileThrowing //core] Category ID not found. Tile not added."); throw HistoryError.moveFailed }
        
        let moving = categories[fromIndex].tiles.remove(at: tileIndex)
        categories[toIndex].tiles.insert(moving, at: 0)
        applyCaps(afterInsertingIn: toIndex)
        
        // If Archive is involved, mirror the authoritative store
        if sourceID == archiveCategoryID || destinationID == archiveCategoryID {
            let intoArchive = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
            Task { await archiveActor.saveArchivedTiles(intoArchive) }
        }
        
        saveHistory()
        lastUndoableMove = (moving, sourceID, destinationID)
        
        // Auto-clear undo affordance
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 3_000_000_000)
            self.lastUndoableMove = nil
        }
    }
}
-e \n\n
=== ./intention/Features/History/HistoryVM+Computed.swift ===
//
//  HistoryVM+Computed.swift
//  intention
//
//  Created by Benjamin Tryon on 9/19/25.
//

import SwiftUI
import Foundation

extension HistoryVM {
    
    /// IDs for user-defined categories (excludes General/Archive)
    var userCategoryIDs: [UUID] {
        categories
            .map(\.id)
            .filter { $0 != generalCategoryID && $0 != archiveCategoryID }
    }

    /// Name lookup by ID (safe default)
    func name(for id: UUID) -> String {
        categories.first(where: { $0.id == id })?.persistedInput ?? "Untitled"
    }
}

//
//    var sortedCategories: [CategoriesModel] {
//        categories.sorted { a, b in
//            // non-archive first, Archive always last
//            let aRank = (a.id == archiveCategoryID) ? 1 : 0
//            let bRank = (b.id == archiveCategoryID) ? 1 : 0
//            if aRank != bRank { return aRank < bRank }
//            // Alphabetical by persistedInput
//            return a.persistedInput.localizedCaseInsensitiveCompare(b.persistedInput) == .orderedAscending
//        }
//    }
//}
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationKind.swift ===
//
//  RecalibrationKind.swift
//  intention
//
//  Created by Benjamin Tryon on 9/3/25.
//

import Foundation

enum RecalibrationKind: String, Codable, Hashable {
    case breathing, balancing
}

struct RecalibrationRecord: Codable, Identifiable, Equatable {
    let id: UUID
    let date: Date
    let kind: RecalibrationKind
    let durationSeconds: Int
}
-e \n\n
=== ./intention/Features/Recalibration/BalanceSideDots.swift ===
//
//  BalanceSideDots.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BalanceSideDots: View {
    let activeIndex: Int   // 0 = Left, 1 = Right
    let p: ScreenStylePalette

    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        HStack(spacing: 16) {
            dot(label: "Left Foot", isActive: activeIndex == 0)
            dot(label: "Right Foot", isActive: activeIndex == 1)
        }
        .frame(maxWidth: .infinity)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(activeIndex == 0 ? "Left foot" : "Right foot")
    }

    let fWOn: CGFloat = 50
    let fWOff: CGFloat = 10
    let fHOn: CGFloat = 50
    let fHOff: CGFloat = 10
    private func dot(label: String, isActive: Bool) -> some View {
        HStack(spacing: 6) {
            Circle()
                .fill(isActive ? p.accent : colorBorder)
                .frame(width: isActive ? fWOn : fWOff, height: isActive ? fHOn : fHOff)
                .overlay(Circle().stroke(colorBorder, lineWidth: isActive ? 0 : 1))
                .animation(.spring(response: 0.22, dampingFraction: 0.85), value: isActive)
            Text(label)
                .font(.callout.weight(isActive ? .semibold : .regular))
                .foregroundStyle(isActive ? p.text : textSecondary)
        }
    }
}
-e \n\n
=== ./intention/Features/Recalibration/BreathingPhaseGuide.swift ===
//
//  BreathingPhaseGuide.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BreathingPhaseGuide: View {
    @EnvironmentObject var theme: ThemeManager
    
    let phases: [String]
    let activeIndex: Int
    let p: ScreenStylePalette
    
    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    
    var body: some View {
        HStack(spacing: 10) {
            ForEach(phases.indices, id: \.self) { i in
                Text(phases[i])
                    .font(.footnote.weight(i == activeIndex ? .semibold : .regular))
                    .padding(.horizontal, 10).padding(.vertical, 6)
                    .background(
                        Capsule().fill(i == activeIndex ? p.surface.opacity(0.9) : .clear)
                        )
                    .overlay(
                        Capsule().stroke(i == activeIndex ? colorBorder : .clear, lineWidth: 1)
                    )
                    .foregroundStyle(i == activeIndex ? p.text : textSecondary)
                    .scaleEffect(i == activeIndex ? 1.06 : 1.0)
                    .animation(.spring(response: 0.22, dampingFraction: 0.85), value: activeIndex)
                    .accessibilityLabel("\(phases[i])\(i == activeIndex ? ", current" : "")")
            }
        }
        .frame(maxWidth: .infinity)
    }
}
-e \n\n
=== ./intention/Features/Recalibration/RecalibrateV.swift ===
//
//  RecalibrateV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct RecalibrationV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var vm: RecalibrationVM
    @State private var insetHeight: CGFloat = 72        // height of sticky bar
    @State private var breathingChoice: Int = 2
    @State private var balancingChoice: Int = 2
    @State private var isBusy = false
    
    // Tunable presets users expect: quick, obvious, one tap.
    private let breathePreset = 60   // 1 min
    private let balancePreset = 60   // 1 min
    
    private let screen: ScreenName = .recalibrate
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        VStack {
            ScrollView {
                Page {
                    // H1 centered; prose left-aligned = calmer eye path
                    T("Reset & Recalibrate", .largeTitle).underline()
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.top, 12)
                    
                    // Supporting copy: left-aligned, subdued
                    T("Short resets help you start your next 20-minute focus chunk fresh.", .body)
                        .foregroundStyle(textSecondary)
                    
                    T("Choose one below:", .body)
                        .foregroundStyle(textSecondary)
                    
                    // the ONLY CTA/timer block
                    actionArea
                        .padding(.top)
                    
                    // Lightweight guidance
                    //FIXME: or use == .none or .notStarted?
                    if vm.phase == .none || vm.phase == .idle, let theMode = vm.mode {
                        InstructionList( items: theMode.instructions, p: p, theme: theme )
                            .padding(.top, 8)
                    }
                    
                    // Live indicators:
                    // Balancing - ‚ÄúSwitch feet‚Äù flashes briefly each minute
                    // Breathing - modes and expanding dot
                    if vm.mode == .balancing {
                        if !vm.eyesClosedMode {
                            Text(vm.promptText)
                                .font(.title3).fontWeight(.semibold)
                        }
                        BalanceSideDots(activeIndex: vm.balancingPhaseIndex, p: p)
                            .padding(.top, 6)
                    } else if vm.mode == .breathing, vm.phase != .none, vm.phase != .idle {
                        BreathingPhaseGuide(
                            phases: vm.breathingPhases,
                            activeIndex: vm.breathingPhaseIndex,
                            p: p
                        )
                        .padding(.top, 6)
                    }
                }
                // Room for sticky inset + it never covers buttons/picker
                .padding(.bottom, insetHeight + 16)
                .padding(.horizontal, 16)
            }
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .task { breathingChoice = vm.currentBreathingMinutes }
        .presentationDragIndicator(.visible)
        // Fill-height sheet so users don‚Äôt have to expand it first
        .presentationDetents([.large])
        // Sticky bottom chrome
//        .safeAreaInset(edge: .bottom, spacing: 0) {
//            BottomInset
//                .background(.ultraThinMaterial)
//                .readHeight($insetHeight)   // helper below to measure height
//        }
        .overlay {
            if let err = vm.lastError {
                ErrorOverlay(error: err) { vm.lastError = nil }
            }
        }
        // Let people leave
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button { dismiss() } label: {
                    Image(systemName: "xmark").imageScale(.small).font(.body).controlSize(.large)
                }
                .buttonStyle(.plain)
                .accessibilityLabel("Close")
            }
        }
    }
    
    
    // MARK: Helpers
    private var PresetPicker: some View {
        HStack(spacing: 8) {
            T("Length of Time", .caption).foregroundStyle(.secondary)
            Picker("", selection: $breathingChoice) {
                Text("2m").tag(2); Text("3m").tag(3); Text("4m").tag(4)
            }
            .pickerStyle(.segmented)
        }
        .onChange(of: breathingChoice) { new in
            do { try vm.setBreathingMinutes(new) } catch { vm.lastError = error }
        }
    }
    private var PresetPickerBal: some View {
        HStack(spacing: 8) {
            Toggle(isOn: $vm.eyesClosedMode) {
                T("Expert Mode: Eyes-closed", .caption).foregroundStyle(.secondary)
            }
            .toggleStyle(.automatic)
        }
        .onChange(of: balancingChoice) { new in
            do { try vm.setBalancingMinutes(new) } catch { vm.lastError = error }
        }
    }
    
    @ViewBuilder
    private var actionArea: some View {
        switch vm.phase {
        case .none, .idle:
            VStack(spacing: 12) {
                if vm.phase == .none || vm.phase == .idle { PresetPicker }   // 2m / 3m / 4m
                Button {
                    vm.performAsyncAction { try await vm.start(mode: .breathing) }
                } label: { T("Breathing", .action) }
                    .recalibrationActionStyle(screen: screen)
                
                Divider()
                if vm.phase == .none || vm.phase == .idle { PresetPickerBal }
                Button {
                    vm.performAsyncAction { try await vm.start(mode: .balancing) }
                } label: { T("Balancing", .action) }
                    .recalibrationActionStyle(screen: screen)
            }
            
        case .running, .pause:
            VStack(spacing: 8) {
                T(vm.mode == .breathing ? "Breathing" : "Balancing", .section)
                    .frame(maxWidth: .infinity, alignment: .center)
                
                Text(vm.formattedTime)
                    .font(.system(size: 56, weight: .semibold, design: .rounded))
                    .monospacedDigit()
                    .frame(maxWidth: .infinity, alignment: .center)
                
                Button(role: .destructive) {
                    vm.performAsyncAction { try await vm.stop() }
                } label: { T("Cancel", .action)
                        .recalibrationActionStyle(screen: screen)
                }
            }
        case .finished:
            EmptyView()
        }
    }
    // Sticky chrome above the Home indicator (keep it simple; no refactor of actionArea)
//    @ViewBuilder
//    private var BottomInset: some View {
//        VStack(spacing: 8) {
//            // a subtle handle/status‚Äîtweak as you like
//            HStack {
////                Text(vm.phase == .running || vm.phase == .pause ? "Recalibration in progress" : "Ready")
//                Text(vm.phase == .running || vm.phase == .pause ? "" : "")
//                    .font(.footnote).foregroundStyle(.secondary)
//                Spacer()
//                if vm.phase == .running || vm.phase == .pause {
//                    Text(vm.formattedTime)
//                        .font(.title3.bold()).monospacedDigit()
//                }
//            }
//            .padding(.horizontal, 16)
//            .padding(.top, 10)
//            
//            // keep a comfortable tap zone above the home indicator
//            Color.clear.frame(height: 16)
//        }
//    }
}
    // Tiny, reusable instruction list (keeps body tidy)
    private struct InstructionList: View {
        let items: [String]
        let p: ScreenStylePalette
        let theme: ThemeManager
        var body: some View {
            VStack(alignment: .leading, spacing: 4) {
                ForEach(items, id: \.self) { Text("‚Ä¢ \($0)") }
            }
            .font(theme.fontTheme.toFont(.footnote))
            .foregroundStyle(p.text)
        }
    }
    private struct HeightReader: View {
        var onChange: (CGFloat) -> Void
        var body: some View {
            GeometryReader { proxy in
                Color.clear
                    .preference(key: HeightKey.self, value: proxy.size.height)
            }
        }
    }
    private struct HeightKey: PreferenceKey {
        static var defaultValue: CGFloat = 0
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) { value = nextValue() }
    }

    private extension View {
        func readHeight(_ binding: Binding<CGFloat>) -> some View {
            background(HeightReader { binding.wrappedValue = $0 })
                .onPreferenceChange(HeightKey.self) { binding.wrappedValue = $0 }
        }
    }
//
//                    
//                    /// users tap a length first (2/3/4), then ‚ÄúBreathe.‚Äù
//                    if vm.phase == .idle {
//                        HStack(spacing: 8) {
//                            T("Breathing length", .caption)
//                                .foregroundStyle(.secondary)
//                            Picker("", selection: $breathingChoice) {
//                                Text("2m").tag(2)
//                                Text("3m").tag(3)
//                                Text("4m").tag(4)
//                            }
//                            .pickerStyle(.segmented)
//                            .frame(maxWidth: 220)
//                        }
//                        .onChange(of: breathingChoice) { new in
//                            do { try vm.setBreathingMinutes(new) }
//                            catch { vm.lastError = error }
//                        }
//                    }
//                    
//                    /// When inactive, show simple, obvious choices
//                    if vm.phase != .running {
//                        VStack(spacing: 12) {
//                            if vm.mode == nil {
//                                Button { start(.breathing) } label: {
//                                    HStack(spacing: 8){
//                                        Image(systemName: RecalibrationMode.breathing.iconName)
//                                        T(activeTitle, .largeTitle)
//                                    }
//                                    .frame(maxWidth: .infinity)
//                                }
//                                .primaryActionStyle(screen: .recalibrate)
//                                
//                                Button { start(.balancing) } label: {
//                                    HStack(spacing: 8){
//                                        Image(systemName: RecalibrationMode.balancing.iconName)
//                                        T(activeTitle, .largeTitle)
//                                    }
//                                    .frame(maxWidth: .infinity)
//                                }
//                                .primaryActionStyle(screen: .recalibrate)
//                            }
//                        }
//                    } else {
//                        /// Active countdown view: big, legible, tappable cancel
//                        VStack(spacing: 16) {
//                            Text(activeTitle)
//                                .font(.headline)
//                            Text(vm.formattedTime)
//                                .font(.system(size: 56, weight: .semibold, design: .rounded))
//                                .monospacedDigit()
//                            Button(role: .destructive) { stop() } label: {
//                                Label("Cancel", systemImage: "xmark.circle")
//                                    .frame(maxWidth: .infinity)
//                                    .tint(.red)
//                            }
//                        }
//                        .padding(.top, 8)
//                    }
//                    // instructions for the selected mode:
//                    if let m = vm.mode, vm.phase != .running {
//                        VStack(alignment: .leading, spacing: 4) {
//                            ForEach(m.instructions, id: \.self) { Text("‚Ä¢ \($0)") }
//                        }
//                        .font(theme.fontTheme.toFont(.footnote))
//                        .foregroundStyle(p.text)
//                        .padding(.top, 8)
//                    }
//                    
//                    VStack(spacing: 8) {
//                        if vm.mode == .balancing {
//                            Text(vm.promptText) // shows ‚ÄúSwitch feet‚Äù briefly each minute
//                                .font(.title3).fontWeight(.semibold)
//                        } else if vm.mode == .breathing {
//                            BreathingPhaseGuide(
//                                phases: vm.breathingPhases,
//                                activeIndex: vm.breathingPhaseIndex,
//                                p: p
//                            )
//                            HStack(spacing: 6) {
//                                ForEach(Array(vm.breathingPhases.enumerated()), id: \.0) { idx, name in
//                                    if idx == vm.breathingPhaseIndex { Text("‚Ä¢ \(name)") } else { Text(name) }
//                                    if idx != vm.breathingPhases.count - 1 { Text("¬∑").opacity(0.6) }
//                                }
//                            }
//                            .font(.headline)
//                            .monospacedDigit()
//                        }
//                        //                    Text(vm.formattedTime).font(.system(.largeTitle, design: .rounded)).monospacedDigit()
//                    }
//                    
//                }
//                .task { breathingChoice = vm.currentBreathingMinutes }
//                .presentationDetents([.height(320), .medium])
//                .presentationDragIndicator(.visible)
//                
//                // Error overlay‚Äîsame pattern as the rest of the app
//                if let err = vm.lastError {
//                    ErrorOverlay(error: err) { vm.lastError = nil }
//                        .zIndex(1)
//                }
//            }
//            .background(p.background.ignoresSafeArea())
//        }
//    }

// struct RecalibrateV: View {
//    @EnvironmentObject var theme: ThemeManager
//    @ObservedObject var viewModel: RecalibrationVM
//    @State private var recalibrationChoice: RecalibrationMode = .breathing
//        
//    @StateObject private var recalibrationVM = RecalibrationVM()
//        
//    var body: some View {
//        
//        let palette = theme.palette(for: .recalibrate)
//        
//        VStack(spacing: 24) {
//            // Header
////            Text.styled("Recalibrate", as: .header, using: fontTheme, in: palette)
//            Label("Recalibrate", systemImage: recalibrationChoice.iconName) // image and text
//                .font(.largeTitle)
//                .foregroundStyle(palette.primary)
//            
//            // Picker
//            Picker("Method", selection: $recalibrationChoice) {
//                ForEach(RecalibrationMode.allCases, id: \.self) { type in
//                    Text("\(type.label)")
//                        .font(.caption)
//                        .tag(type)
//                }
//            }
//            .pickerStyle(SegmentedPickerStyle())
//            
//            // Begin/Start Button
//            Button(action: {
//                viewModel.start(mode: recalibrationChoice)
//            }) {
//                Label("Begin", systemImage: "play.circle.fill")
//                    .font(.title)
//            }
//            .primaryActionStyle(screen: .recalibrate)
//            .environmentObject(theme)
//            
//            // Coundown Displayed
//            Text("‚è± \(viewModel.formattedTime)")
//                .font(.title2)
//                .bold()
//                .foregroundStyle(palette.text)
//            
//            // Instruction List
//            ForEach(recalibrationChoice.instructions, id: \.self) { line in
//                Text("‚Ä¢ \(line)")
//            }
//            
//
//            // Conditional UI when finished
//            if viewModel.phase == .finished {
//                Text("‚úÖ Done! Tap to go back")
//                    .foregroundColor(palette.text)
//                    .padding(.top, 8)
//                Text("Tap to post to social")
//                    .foregroundStyle(palette.text)
//                    .padding(.top, 8)
//            }
//            
//            // Exit Button
//            Button("Exit")  {
//                viewModel.stop()
//            }
//            .secondaryActionStyle(screen: .recalibrate)
//            .environmentObject(theme)
//        }
//        .padding()
//        .onAppear {
//            viewModel.start(mode: recalibrationChoice)
//        }
//        .background(
//            RoundedRectangle(cornerRadius: 24)
//                .fill(palette.background)
//                .shadow(color: palette.primary.opacity(0.2), radius: 10, x: 0, y: 4)
//        )
//        .padding()
//    }
// }
#if DEBUG
#Preview("Recalibrate - Running") {
    PreviewWrapper {
//        RecalibrationV(vm: PreviewMocks.recalibrationRunning())
//            .previewTheme()(haptics: NoopHapticsClient())
        RecalibrationV(vm: RecalibrationVM.mockForDebug()).previewTheme()
            .previewTheme()
    }
}
#endif
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationType.swift ===
//
//  RecalibrationMode.swift
//  intention
//
//  Created by Benjamin Tryon on 7/22/25.
//

import SwiftUI

// Authoritiative model - Operation + duration, View can request preset cleanly
/// Role-only; Durations live in the VM's config

enum RecalibrationMode: String, Hashable, Codable, CaseIterable {
    case balancing
    case breathing
    
    var label: String {
        switch self {
        case .balancing: return "Balancing Reset"
        case .breathing: return "Breathing Reset"
        }
    }
    
    var iconName: String {
        switch self {
        case .balancing: return "figure.stand"
        case .breathing: return "lungs.fill"
        }
    }
    
        var instructions: [String] {
            switch self {
            case .balancing:
                /// 4 minutes, switch every minute
                return [
                    "Stand on one foot.",
                    "Switch feet, every minute",
                    "Level up: close eyes and repeat."
                ]
            case .breathing:
                /// 6-3, 6-3
                return [
                    "Inhale 6 sec, hold 3 sec.",
                    "Exhale 6 sec, hold 3 sec.",
                    "Repeat until timer ends."
                ]
            }
        }
}

-e \n\n
=== ./intention/Features/Recalibration/RecalibrationVM.swift ===
//
//  RecalibrationVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//

import Foundation

enum RecalibrationError: LocalizedError {
    case invalidBreathingMinutes, cannotChangeWhileRunning
    var errorDescription: String? {
        switch self {
        case .invalidBreathingMinutes:   return "Breathing must be 2‚Äì4 minutes."
        case .cannotChangeWhileRunning:  return "You can‚Äôt change duration while a session is running."
        }
    }
}


/// One entry point: start(mode:)

/// VM decides duration + cadence (no durations in the View).

/// Haptics are triggered from VM only (View stays quiet).

/// Swift-6 friendly captures; cancel on deinit.
/// VM is already @MainActor, so the Task {} body runs on the main actor; you can mutate published properties directly (no MainActor.run)
@MainActor
final class RecalibrationVM: ObservableObject {
    enum Phase { case none, idle, running, finished, pause }
    
    @Published private(set) var phase: Phase = .none
    @Published private(set) var mode: RecalibrationMode?
//    @Published private(set) var startedAt: Date?    // part of "snapshotting" the wall-clock to recompute remaining time on re-activation
    @Published private(set) var timeRemaining: Int = 0
    @Published var lastError: Error?
    @Published var breathingPhaseIndex: Int = 0     // 0:Inhale, 1:Hold, 2:Exhale, 3:Hold
    @Published var promptText: String = ""          // ‚ÄúSwitch feet‚Äù pulses EMOM
    @Published var eyesClosedMode: Bool = false     // UI toggles this before start()
    @Published var balancingPhaseIndex: Int = 0
    
    var formattedTime: String {
        let m = timeRemaining / 60, s = timeRemaining % 60
        return String(format: "%02d:%02d", m, s)
    }
    
    // Counts
    var onCompleted: ((RecalibrationMode) -> Void)?
    
    // VMs current default on present
    var currentBreathingMinutes: Int { breathingMinutes }
    var currentBalancingMinutes: Int { balancingMinutes }
    
    // Prompts
    let breathingPhases = ["Inhale", "Hold", "Exhale", "Hold"]
    var breathingPhaseLine: String { breathingPhases.joined(separator: " . ") }
    
    // Policy knobs (VM decides "when")
    private var breathingMinutes: Int
    private var balancingMinutes: Int
    private let inhale = 6, hold1 = 3, exhale = 6, hold2 = 3

    private let haptics: HapticsClient
    private var task: Task<Void, Never>?
    @Published private(set) var didHaptic: Set<Int> = []
    
    // Related to time the user backgrounded/spent time outside the app
    private var recalDeadline: Date?
//    private var intendedDuration: Int = 0       // seconds (for .current mode)


    init(haptics: HapticsClient, breathingMinutes: Int = 2, balancingMinutes: Int = 4) {
        self.haptics = haptics
        self.breathingMinutes = min(4, max(2, breathingMinutes))
        self.balancingMinutes = min(4, max(4, balancingMinutes))
    }

    deinit { task?.cancel() }
    
    // MARK: Core API (async throws; View calls these)
    // When starting (not resuming when re-activated after leaving, see `appDidBecomeActive()`):
    func start(mode: RecalibrationMode) async throws {
        cancel()
        self.mode = mode
        self.phase = .running
        
        let mins = (mode == .breathing ? breathingMinutes : balancingMinutes)
        let seconds = mins * 60
        self.timeRemaining = seconds
        self.recalDeadline = Date().addingTimeInterval(TimeInterval(seconds))
        
        switch mode { case .balancing: runBalancing(); case .breathing: runBreathing() }
    }
    
    func stop() async throws {
        cancel()
        phase = .idle
        mode = nil
        promptText = ""
    }

    private func cancel() {
        task?.cancel()
        task = nil
        recalDeadline = nil
    }
    
    func setBreathingMinutes(_ minutes: Int) throws {
        guard (2...4).contains(minutes) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        breathingMinutes = minutes
    }
    
    func setBalancingMinutes(_ mins: Int) throws {
        guard (1...4).contains(mins) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        balancingMinutes = mins
    }
    
    
    func appWillResignActive() { /* no-op; wall clock handles it */}
    
    // Resuming when re-activated after leaving, see `start(mode:)`
    // is called un RootView when scene becomes active:
    func appDidBecomeActive() {
        guard phase == .running, let returned = recalDeadline else { return }
        let remain = max(0, Int(returned.timeIntervalSinceNow))         // "clamps": UI never shows -00:01
        
        if remain != timeRemaining { timeRemaining = remain }
        if remain == 0 {
            // finish immediately
            phase = .finished
            let finished = mode
            mode = nil
            promptText = ""
            if let m = finished { onCompleted?(m) }
            fireHapticsNotifyDone()
        }
    }
    
    // Pattern to call haptic once per completion
//    private func fireDoneHapticOnce() {
//        guard !didHapticForChunk.contains(currentSessionChunk) else { return }
//        didHapticForChunk.insert(currentSessionChunk)
//        haptics.notifyDone()
//    }
    private func fireHapticsNotifyDone() { haptics.notifyDone() }
    
    
    // MARK: Balancing - short-short every min; long-long-short on done
    private func runBalancing() {
        // Minute beeps: short‚Äìshort; Done: long‚Äìlong‚Äìshort; only show ‚ÄúSwitch feet‚Äù briefly each minute
        /// cue at start + each minute, set balancingPhaseIndex, optionally show promptText for 1s
        let total = timeRemaining
//        var lastMinBoundary = total
        
        task = Task { [weak self] in
            guard let self else { return }
            var lastCueAt = -1                      // ensure we cue at the start and then each minute boundary
            
            while self.timeRemaining > 0 && !Task.isCancelled {
                // EMOM fire at boundary
                if self.timeRemaining == total || (self.timeRemaining % 60 == 0 && self.timeRemaining != lastCueAt) {
//                    let elapsed = total - self.timeRemaining
//                    let minuteIndex = (elapsed / 60) % 2          // 0,1,0,1...
                    //                    self.haptics.warn()             // short‚Äìshort
                    haptics.warn()                       // short‚Äìshort
                    //                    await MainActor.run {
                    //                        self.balancingPhaseIndex = minuteIndex
                    lastCueAt = self.timeRemaining
                    if !self.eyesClosedMode {
                        self.promptText = "Switch feet"
                        try? await Task.sleep(nanoseconds: 1_000_000_000)
                        self.promptText = ""
                    }
                }
//                        if !self.eyesClosedMode { self.promptText = "Switch feet" }
//                    }
//                    try? await Task.sleep(nanoseconds: 1_000_000_000)
//                    await MainActor.run { self.promptText = "" }
//                    lastCueAt = self.timeRemaining
//                }

                // Tick every second no matter what
                try? await Task.sleep(nanoseconds: 1_000_000_000)
//                await MainActor.run { self.timeRemaining -= 1 }
                self.timeRemaining -= 1
            }

            guard !Task.isCancelled else { return }
            haptics.notifyDone()                // long‚Äìlong‚Äìshort
//            await MainActor.run {
                self.phase = .finished
                let finished = self.mode
                self.mode = nil
                self.promptText = ""
                if let m = finished { self.onCompleted?(m) }
//            }
//            await MainActor.run { self.onCompleted?(.balancing) }
        }
    }

    // MARK: Breathing ‚Äî 6/3/6/3, tiny cue each phase
    private func runBreathing() {
        // Show one line ‚ÄúInhale ¬∑ Hold ¬∑ Exhale ¬∑ Hold‚Äù and move a subtle dot via breathingPhaseIndex
        task = Task { [weak self] in
            guard let self else { return }
            let seq: [(idx: Int, secs: Int)] = [(0, inhale), (1, hold1), (2, exhale), (3, hold2)]
            while self.timeRemaining > 0 && !Task.isCancelled {
                for (idx, secs) in seq {
//                    await MainActor.run {
                        self.breathingPhaseIndex = idx
                        // NOTE: No big label per phase; UI uses breathingPhaseLine + index to draw the dot
//                    }
                    for _ in 0..<secs {
                        guard !Task.isCancelled else { return }
                        try? await Task.sleep(nanoseconds: 1_000_000_000)
//                        await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }
                        self.timeRemaining = max(0, self.timeRemaining - 1) // "clamps": UI never shows -00:01
                        if self.timeRemaining == 0 { break }
                    }
                    if self.timeRemaining == 0 { break }
                    haptics.added()             // tiny cue at phase boundaries
                }
            }
            guard !Task.isCancelled else { return }
            haptics.notifyDone()                // long‚Äìlong‚Äìshort
//            await MainActor.run {
                self.phase = .finished
                let finished = self.mode
                self.mode = nil
                self.promptText = ""
                if let m = finished { self.onCompleted?(m) }
//            }
        }
    }

       private func phaseBlock(label: String, seconds: Int) async {
           haptics.added()                          // single short cue at each phase start
           for _ in 0..<seconds {
               guard !Task.isCancelled else { return }
               try? await Task.sleep(nanoseconds: 1_000_000_000)
               await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }  // "clamps": UI never shows -00:01
           }
       }
    
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do {
                try await action()
            } catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
}

#if DEBUG
@MainActor
extension RecalibrationVM {
    /// Debug-only setters; returning Self enables fluent build-up in previews.
    @discardableResult func _debugSetPhase(_ p: Phase) -> Self { self.phase = p; return self }
    @discardableResult func _debugSetMode(_ m: RecalibrationMode?) -> Self { self.mode = m; return self }

    /// Canonical preview factory: shows a running breathing session with a visible countdown.
    static func mockForDebug() -> RecalibrationVM {
        let vm = RecalibrationVM(
            haptics: NoopHapticsClient(),
            breathingMinutes: 1,
            balancingMinutes: 1
        )
        vm._debugSetMode(.breathing)
          ._debugSetPhase(.running)
        vm.timeRemaining = 17 // 1:30 gives a nice visual
        return vm
    }
}
#endif
-e \n\n
=== ./intention/Features/Stats/StatsVM.swift ===
//
//  StatsVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/30/25.
//

import Foundation
import SwiftUI

enum StatsError: Error, Equatable, LocalizedError {
    case calculationFailed
    
    var errorDescription: String? {
        switch self {
        case .calculationFailed: return "Calculation failed."
        }
    }
}

@MainActor
final class StatsVM: ObservableObject {
    @Published private(set) var averageCompletionRate: Double = 1.0
    @Published private(set) var totalCompletedIntentions: Int = 0
    @Published private(set) var recalibrationCounts: [RecalibrationMode: Int] = [:] // what?
    @Published private(set) var lastRecalibrationChoice: RecalibrationMode?
    @Published private(set) var streak: Int = 0
    @Published private(set) var longestStreak: Int = 0
    @Published var shouldPromptForMembership: Bool = false  // is good flag
    @Published var lastError: Error?
    
    private let persistence: any Persistence
    private let storageKey = "completedSessions"
    private let membershipThreshold = 2
    private var completedSessions: [CompletedSession] = []
    
    weak var memVM: MembershipVM?
    
    init(persistence: any Persistence) {
        self.persistence = persistence
        Task {  await loadSessions()    }
    }
    
    func logSession(_ session: CompletedSession) {
        completedSessions.append(session)
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        memVM?.triggerPromptIfNeeded(afterSessions: completedSessions.count)
        
        /// if user did recalibrate (picked breathing or balancing), type will be non-nil, and count incremented
        if let type = session.recalibration {
            recalibrationCounts[type, default: 0] += 1
            lastRecalibrationChoice = type
        }
        
        recalculateStats()
        
        /// Updates to trigger membership prompt ($0.99 then $5.99 for 3 months?)
        /// Keeps onboarding friction at zero: the user never types anything.
        if completedSessions.count == membershipThreshold {
            shouldPromptForMembership = true    // Observe in the RootView and present as alert/sheet
        }
        
        Task {
            do {
                try await persistence.write(completedSessions, to: storageKey)
            } catch {
                debugPrint("[StatsVM.logSession persistence.saveHistory] error:", error)
                await MainActor.run { self.lastError = error }
            }
        }
    }
    
    private func loadSessions() async {
        do {
            if let loaded: [CompletedSession] = try await persistence.readIfExists([CompletedSession].self, from: storageKey) {
                completedSessions = loaded
                recalculateStats()
            }
        } catch {
            debugPrint("[StatsVM.loadSessions] from PersistenceActor: ", error)
            await MainActor.run { self.lastError = error }
        }
    }
    private func recalculateStats() {
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        let intendedTiles = completedSessions.count * 2
        /// Update average completion rate
        averageCompletionRate = intendedTiles == 0 ? 1.0 : Double(totalCompletedIntentions) / Double(intendedTiles)
        
        /// Update recalibration counts - counts and ‚Äúlast choice‚Äù are always correct after app relaunch
        var newCounts: [RecalibrationMode: Int] = [:]
        var last: RecalibrationMode?
        for sesh in completedSessions {
            if let t = sesh.recalibration {
                newCounts[t, default: 0] += 1
                last = t
            }
        }
        recalibrationCounts = newCounts
        lastRecalibrationChoice = last
        
        updateRunStreak()
    }
    
    private func updateRunStreak() {
        let calendar = Calendar.current
        let daysWithSessions = Set(completedSessions.map {
            calendar.startOfDay(for: $0.date)
        })
        let sortedDays = daysWithSessions.sorted(by: >) // descending: [today, yesterday, ...]
        
        // If empty, no streak, otherwise start/continue Current Streak
        guard !sortedDays.isEmpty else {
            streak = 0
            longestStreak = 0
//            tilesCompletedThisWeek = 0
            return
            }
        
        // Run streak (most recent backward)
        var maxStreak = 1
        var currentStreak = 1
        var isTrackingCurrent = true
        for i in 1..<sortedDays.count {
            let diff = calendar.dateComponents([.day], from: sortedDays[i], to: sortedDays[i - 1]).day ?? 0
            if diff == 1 {
                currentStreak += 1
                if isTrackingCurrent { streak = currentStreak }
                maxStreak = max(maxStreak, currentStreak)
            } else {
                isTrackingCurrent = false
                currentStreak = 1
            }
        }
        // If all dates are consecutive, streak isn't updated in the loop
        if isTrackingCurrent { streak = currentStreak }
        longestStreak = maxStreak
    }
    
    // MARK: Helpers + Throwing Core
    
    /// Throwing core (async throws): use when the caller wants to decide how to handle the error
    
    func logSessionThrowing( _ s: CompletedSession) async throws {
        completedSessions.append(s)
        recalculateStats()
        try await persistence.write(completedSessions, to: storageKey)
    }
    
    // Background
    func autosaveStats() {
        //            Task {
        //                do { try await persistence.saveHistory(self, to: "statsData") }
        //                catch {
        //                    debugPrint("[StatsVM.autosaveStats] error:", error)
        //                    self.lastError = error
        //                }
    }
    
    var totalRecalibrations: Int {
        recalibrationCounts.values.reduce(0, +)
    }
}

// MARK: Supporting Types -
// Keeps CompletedSession simple and fully Codable for PersistenceActor
struct CompletedSession: Codable {
    let date: Date
    let tileTexts: [String]
    let recalibration: RecalibrationMode?
}
-e \n\n
=== ./intention/Features/Stats/StatsSummaryBar.swift ===
//
//  StatsSummaryBar.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import SwiftUI

struct StatsSummaryBar: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var vm: StatsVM
    private let screen: ScreenName = .settings
        private var p: ScreenStylePalette { theme.palette(for: screen) }
        private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }

    var body: some View {
        HStack(spacing: 12) {
            StatPill(icon: "flame",
                      value: "\(vm.streak)",
                      caption: "Your Streak",
                      screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns

            StatPill(icon: "checkmark",
                      value: String(format: "%.0f%%", vm.averageCompletionRate * 100), // FIXME: value: vm.avgCompletionString, label: "Avg.")
                      caption: "Completion",
                      screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns

            StatPill(icon: (vm.lastRecalibrationChoice?.iconName ?? "arrow.triangle.2.circlepath"),
                     value: "\(vm.totalRecalibrations)",
                     caption: "Recalibrations",
                     screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns
        }
    }
}
-e \n\n
=== ./intention/Features/Stats/StatPill.swift ===
//
//  StatPill.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct StatPill: View {
    @EnvironmentObject var theme: ThemeManager
    let icon: String
    let value: String
    let caption: String
    let screen: ScreenName
    
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(p.primary)
                .frame(height: 24)
            
            // Top Row: the number (scales, doesn't wrap)
            T(value, .title3)
                .statNumberStyle(p)
                .frame(height: 22)
            T(caption, .caption)
                .statCaptionStyle(p)
                .frame(height: 16)
        }
        .multilineTextAlignment(.center)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(caption) \(value)")
    }
}
-e \n\n
=== ./intention/Features/Membership/redeemOfferCode.swift ===
//
//  redeemOfferCode.swift
//  intention
//
//  Created by Benjamin Tryon on 9/25/25.
//

import Foundation
import StoreKit

@MainActor
func redeemOfferCode() async {
    if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
        try? await AppStore.presentOfferCodeRedeemSheet(in: scene)   // iOS 16+
    }
}
-e \n\n
=== ./intention/Features/Membership/MembershipVM.swift ===
//
//  MembershipVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import SwiftUI
import StoreKit

enum MembershipError: Error, Equatable, LocalizedError {
    case purchaseFailed, restoreFailed, invalidCode, networkError, appEnvironmentFail

    var errorDescription: String? {
        switch self {
        case .purchaseFailed:     return "Purchase could not be completed."
        case .restoreFailed:      return "No purchases to restore."
        case .invalidCode:        return "That code isn‚Äôt valid."
        case .networkError:       return "Network error. Please try again."
        case .appEnvironmentFail: return "App environment error."
        }
    }
}

/// pure async/await for purchase/restore paths, one paywall, stable entitlement refresh
/// `isMember` flips only from verified entitlements in PaymentService.refreshEntitlementStatus(), and the VM just mirrors that via updates()
@MainActor
final class MembershipVM: ObservableObject {
    // UI state mirrored from PaymentService
    @Published private(set) var isMember: Bool = false
    @Published var shouldPrompt: Bool = false
    @Published var showCodeEntry: Bool = false
    @Published var primaryProduct: Product?         /// Shows "¬¢/day ‚Ä¢ $X.XX"
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    
    let payment: PaymentService             //FIXME: only use the injected instance, and not p let paymentService = PaymentService()?
    private let codeService = MembershipCodeService()
    
    init(payment: PaymentService) {
        self.payment = payment
        // Observe payment service state
        // "Mirror service state" (‚úÖ this is how VM learns membership)
        Task {
            for await state in await payment.updates(){
                self.isMember = state.isMember
                self.primaryProduct = state.products.first
            }
        }
        // Initial configuration
        Task { await payment.configure() }
    }
        
//        paymentService.$isMember
//            .receive(on: RunLoop.main)
//            .assign(to: &$isMember)
//        
//        paymentService.$products
//            .map { $0.first }   // FIXME: not $0, what is 0 made of?
//            .receive(on: RunLoop.main)
//            .assign(to: &$primaryProduct)
//    }

    func buy() async {
        do {
            let paid = try await payment.purchaseMembership()
            if !paid { await payment.refreshEntitlementStatus() }
        } catch {
            lastError = error
        }
    }
    
    /// Trigger helper to reopen form anywhere (starts in RootView, can be in a banner, Settings, locked feature)
    @MainActor func presentPaywall() { shouldPrompt = true }

    func restore() async {
        do {
            try await payment.restorePurchases()
            if !isMember { lastError = MembershipError.restoreFailed }
        } catch {
            lastError = error
        }
    }

    // Public UI API (never sets isMember directly)
    func purchaseMembershipOrPrompt() async throws {
        let before = isMember
        do {
            let paid = try await payment.purchaseMembership()
            await payment.refreshEntitlementStatus()
            shouldPrompt = !(paid || isMember)
            if !(paid || isMember) { throw MembershipError.purchaseFailed }
        } catch {
            shouldPrompt = !before
            lastError = error
            throw error
        }
    }
    
    func restoreMembershipOrPrompt() async throws {
        do {
            try await payment.restorePurchases()
            shouldPrompt = !isMember
            if !isMember { throw MembershipError.restoreFailed }
            } catch {
                let err = MembershipError.restoreFailed; setError(err); throw err
        }
    }
    
    @MainActor
    func verifyCode(_ code: String) async throws {
        let deviceID = UIDevice.current.identifierForVendor?.uuidString ?? "unknown"
        let result = await codeService.verify(code: code, deviceID: deviceID)
        switch result {
        case .success:
            // Treat as an unlocked entitlement
            isMember = true
            shouldPrompt = false
            showCodeEntry = false
        case .invalid:
            let err = MembershipError.invalidCode; setError(err); throw err
        case .networkError:
            let err = MembershipError.networkError; setError(err); throw err
        }
    }
    
    func triggerPromptIfNeeded(afterSessions sessionCount: Int, threshold: Int = 2) {
        if !isMember && sessionCount >= threshold { shouldPrompt = true }
    }
    
    func setError(_ error: Error?) { lastError = error }
    
    func perDayBlurb(for product: Product) -> String {
        guard let sub = product.subscription else { return "" }
        // Very rough: 30-day month, 365-day year. It‚Äôs just a blurb.
        let days: Decimal
        switch sub.subscriptionPeriod.unit {
        case .month: days = 30
        case .year:  days = 365
        case .week:  days = 7
        case .day:   days = 1
        @unknown default: days = 30
        }
        // Product.price is Decimal in StoreKit 2.
        let daily = (product.price / days) as NSDecimalNumber
        let cents = (daily.multiplying(by: 100)).doubleValue.rounded()
        return "about \(Int(cents))¬¢/day"
    }
    
    var showSheetBinding: Binding<Bool> {
        Binding(
            get: { self.shouldPrompt },
            set: { newVal in self.shouldPrompt = newVal  }
            // ^ aka, self.shouldPrompt = $0
        )
    }
    
    #if DEBUG
    // Preview/testing hook to flip membership without touching StoreKit
    // because this method is inside the type, it can write to the private(set) property
    func _debugSetIsMember(_ value: Bool) { self.isMember = value }
    #endif
}
-e \n\n
=== ./intention/Shared/Haptics/AppPreferencesVM.swift ===
//
//  AppPreferencesVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import SwiftUI

/// The delivery mechanism: inject a HapticsService from RootView (no singletons), @MainActor, warmed generators, safe everywhere
@MainActor
final class AppPreferencesVM: ObservableObject {
    @AppStorage("hapticsOnly") var hapticsOnly: Bool = true  /// default ON
    
    /// optional: add more later (soundsEnabled, reduceAnimations, etc.)
}
-e \n\n
=== ./intention/Shared/Haptics/LiveHapticsClient.swift ===
//
//  LiveHapticsClient.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import Foundation
import UIKit

@MainActor
final class HapticsService: ObservableObject {
    private let light   = UIImpactFeedbackGenerator(style: .light)
    private let impact  = UIImpactFeedbackGenerator(style: .medium)
    private let heavy   = UIImpactFeedbackGenerator(style: .heavy)
    private let notify  = UINotificationFeedbackGenerator()
    
    init() { prepareGenerators() }
    
    /// Pre-warms the generators; safe to call often
    func warm() { prepareGenerators() }
    private func prepareGenerators() {
        light.prepare(); impact.prepare(); heavy.prepare(); notify.prepare()
    }
    
    func added() { impact.impactOccurred(intensity: 0.8) }
    func warn() { notify.notificationOccurred(.warning) }
    func notifyDone() {
        heavy.impactOccurred()                      // 1st heavy
        
        Task {
            let longerPause: UInt64 = 200_000_000   // 200 million nanoseconds - 200 milisecdons
            let shortPause: UInt64 = 90_000_000     // 90 million nanoseconds - 90 milisecdons
            // wait; second heavy
            try? await Task.sleep(nanoseconds: longerPause); heavy.impactOccurred()
            // wait; third heavy
            try? await Task.sleep(nanoseconds: shortPause); heavy.impactOccurred()
            // wait; last heavy
            try? await Task.sleep(nanoseconds: shortPause); heavy.impactOccurred()
        }
        notify.notificationOccurred(.success)
    }
}
/// Gates haptics; VMs only talk to this protocol
@MainActor
protocol HapticsClient {
    func added()
    func warn()
    func notifyDone()
}

/// No-op (for tests or to disable globally)
struct NoopHapticsClient: HapticsClient {
    func added() {}
    func warn() {}
    func notifyDone() {}
}

/// Live client that checks prefs.hapticsOnly and calls the engine
 @MainActor
struct LiveHapticsClient: HapticsClient {
    let prefs: AppPreferencesVM
    let engine: HapticsService
    private var enabled: Bool { prefs.hapticsOnly }

    func added()    { guard enabled else { return }; engine.added() }
    func warn()     { guard enabled else { return }; engine.warn() }
    func notifyDone() { guard enabled else { return }; engine.notifyDone() }
}
-e \n\n
=== ./intention/Shared/Resources/Bundle+AppIcon.swift ===
//
//  AppIcon.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI
import UIKit

extension Bundle {
    var appIconFileName: String? {
        guard let icons = infoDictionary?["CFBundleIcons"] as? [String: Any],
              let primaryIcon = icons["CFBundlePrimaryIcon"] as? [String: Any],
              let iconFiles = primaryIcon["CFBundleIconFiles"] as? [String],
              let iconFileName = iconFiles.last
        else { return nil }
        return iconFileName
    }
    
    // Convenience key/computed property to load the app icon (as a UIImage)
    var appIcon: UIImage? {
        guard let appIconFileName = appIconFileName else { return nil }
        return UIImage(named: appIconFileName)      // already GETS and returns the image... do NOT need map
    }
//    don't need the flatMap and map chain in the View's body because the intermediate optional states are already handled by your appIcon computed property
}
-e \n\n
=== ./intention/Shared/Resources/PillSandbox.swift ===
//
//  PillSandbox.swift
//  intention
//
//  Created by Benjamin Tryon on 10/2/25.
//

import SwiftUI

struct PillSandbox: View {
    var body: some View {
        HStack(spacing: 16){
//            StatPill
        }
    }
}

#Preview {
    PillSandbox()
}
-e \n\n
=== ./intention/Shared/Resources/ThemeManager.swift ===
//
//  AppThemeManager.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//
import SwiftUI
// views will use local color constants for validation, border, and secondary text
// Shim: keep code compiling that expects ThemePalette, if any still refer to it!

typealias ThemePalette = ScreenStylePalette

// -- Use a material background (which applies a subtle blur/opacity)
//    .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 8))
// modern approach in Swift for non-shadow readability.
// It automatically ensures the text's background contrasts with the content behind it, boosting legibility without adding an explicit shadow
// MARK: Screens
enum ScreenName {
    case focus, history, settings, organizer, recalibrate, membership
}
// MARK: Text roles
enum TextRole {
    case largeTitle, header, section, title3, label, body, tile, secondary, caption, action, placeholder
}
// MARK: - Per-screen color tokens
struct ScreenStylePalette {
    let primary: Color          // secondary button bg or highlighting
    let background: Color       // main pages
    let surface: Color          // card color, tab bars, // RENAME
    let accent: Color          // CTA color - use for fill
    let text: Color
    
    struct LinearGradientSpecial {
        let colors: [Color]
        let start: UnitPoint
        let end: UnitPoint
    }
    let gradientBackground: LinearGradientSpecial?      // nil == use `background` color
//    dynamic foreground color that automatically adjusts based on the background color.
}
// MARK: - App Font Theme
enum AppFontTheme: String, CaseIterable {
    case serif, rounded, mono
    var displayName: String { self == .serif ? "Serif" : self == .rounded ? "Rounded" : "Mono" }
    func toFont(_ style: Font.TextStyle) -> Font {
        let design: Font.Design = switch self {
        case .serif: .serif
        case .rounded: .rounded
        case .mono: .monospaced
        }
        return .system(style, design: design)
    }
}

// MARK: Color Constants (Moved from extension to local enums/structs for clarity)
// Color Palette:
// background_light: f6f6f6, background_medium: d9ddc7, surface: c1c1c1, accent: 8ea131, text: 555555, secondary_text_bg: 3e3e36

private enum DefaultColors {
    // R: 246, G: 246, B: 246 (#F6F6F6) - Very light, almost white background
    static let backgroundLight = Color(red: 0.965, green: 0.965, blue: 0.965)
    
    //    // R: 217, G: 221, B: 199 (#D9DDC7) - Tan-gray (used for Recalibrate/Organizer background)
    //    static let backgroundMedium = Color(red: 0.851, green: 0.867, blue: 0.788)
    // R: 217, G: 221, B: 199 (#E0D8CB) - Tan-gray (used for Recalibrate/Organizer background)
    static let backgroundMedium = Color(red: 0.878, green: 0.847, blue: 0.796)
    
    // R: 193, G: 193, B: 193 (#C1C1C1) - Medium gray for cards/surfaces
    static let surface = Color(red: 0.757, green: 0.757, blue: 0.757)
    
    // R: 142, G: 161, B: 49 (#8EA131) - Leaf (filling things like CTA)
    static let accent = Color(red: 0.557, green: 0.631, blue: 0.192)
    
    // R: 85, G: 85, B: 85 (#555555) - Dark Gray (Primary Text)
    static let text = Color(red: 0.333, green: 0.333, blue: 0.333)
}

// MARK: OrganizerOverlay
private enum OrgBG {
    // TopLight and BottomDark are now assigned based on the new backgroundMedium color if needed
    static let topLight = DefaultColors.backgroundLight
    static let bottomDark = DefaultColors.backgroundMedium
}

// MARK: Recalibrate Sheet
private enum RecalibrateBG {
    // -> lighter = #335492, darker #001e64
    // Keep the distinct Recalibrate blues, as they provide high contrast for that screen's specific context.
    static let topLight  = Color(red: 0.2000, green: 0.3294, blue: 0.5725)
    // converted from #001e64
    static let bottomDark = Color(red: 0.0, green: 0.1176, blue: 0.3922)
}

// MARK: Membership Sheet
private enum MembershipBG {
    static let topLight  = Color(red: 0.72, green: 0.86, blue: 1.00)
    static let bottomDark = Color(red: 0.0, green: 0.1176, blue: 0.3922)
}

// MARK: Sea theme
private enum Sea {
    // Light ‚ÄúClose‚Äù blue (used as top of gradient & general bg) #73a7f6
    static let topLight  = Color(red: 0.45, green: 0.65, blue: 96)
    // Darker body blue (used as bottom of gradient & accent/tint) #0d53bf
    static let bottomDark = Color(red: 0.05, green: 0.33, blue: 0.75)
}


// MARK: - App Color Theme ‚Üí per-screen palettes
enum AppColorTheme: String, CaseIterable {
    case `default`, sea
    
    var displayName: String {
        switch self {
        case .default: "Default"
        case .sea: "Sea"
        }
    }
    
    // Show fewer choices in Settings without deleting anything.
    // Change this list whenever you want to expose more/less.
    static var publicCases : [AppColorTheme] { [.default, .sea] }
    
    //    /// One accent per theme for consistency
    //    private var accent: Color {
    //        switch self {
    //        case .default: DefaultColors.accent
    //        case .sea:     Color(red: 0.35, green: 0.75, blue: 1.0)
    //        }
    //    }
    
    func colors(for screen: ScreenName) -> ScreenStylePalette {
        switch self {
            // ---------- DEFAULT ----------
        case .default:
            switch screen {
            case .focus, .history, .settings:
                return .init(
                    primary: DefaultColors.surface,             // secondary/quiet CTAs
                    background: DefaultColors.backgroundLight,    // Page pg
                    surface: DefaultColors.surface.opacity(0.85), // card/surface (slightly lighter)
                    accent: DefaultColors.accent,                  // CTA color (citron)
                    text: DefaultColors.text,                   // primary text color (dark gray)
                    gradientBackground: nil
                )
                
            case .recalibrate:
                return .init(
                    primary: RecalibrateBG.bottomDark,          // icon tints if needed
                    background: RecalibrateBG.topLight,         // fallback if gradient is nil
                    surface: DefaultColors.surface.opacity(0.10),   // frosted cards
                    accent: DefaultColors.accent,               // CTA on sheet
                    text: DefaultColors.backgroundLight,       // light text over dark blue
                    gradientBackground: .init(
                        colors: [(RecalibrateBG.topLight), (RecalibrateBG.bottomDark)],
                        start: .topLeading,
                        end: .bottomTrailing
                    )
                )
                
            case .membership:
                return .init(
                    primary: DefaultColors.accent,               // CTA color (citron)
                    background: DefaultColors.backgroundLight,    // fallback if gradient is nil
                    surface: DefaultColors.surface.opacity(0.96), // card/surface (slightly lighter)
                    accent: DefaultColors.accent,               // CTA color (citron)
                    text: DefaultColors.text,                   // primary text color (dark gray)
                    gradientBackground: .init(
                        colors: [(MembershipBG.topLight), (MembershipBG.bottomDark)],
                        start: .topTrailing,
                        end: .bottomLeading
                    )

                )
                
            case .organizer:
                // superior contrast (6.1:1) against the light gradient
                /*#7b6428*/ let organizerText = Color(red: 0.4824, green: 0.3922, blue: 0.1569)
                return .init(
                    primary: DefaultColors.accent,               // CTA color (citron)
                    background: .clear,                         // clear, to see gradient
                    surface: .clear,                            // let gradient breath
                    accent: organizerText,                      // toolbar tint (X button, etc)
                    text: organizerText,          // primary text
                    gradientBackground: .init(
                        colors: [OrgBG.topLight, OrgBG.bottomDark],  
                        start: .top,
                        end: .bottom
                    )
                )
            }
            
            // ---------- SEA ----------
        case .sea:
            // Background: #0B47A3 (Dark Blue)
                        let seaBG = Color(red: 0.043, green: 0.278, blue: 0.639)
                        // Text: #D9EBFF (Very Light Blue)
                        let seaText = Color(red: 0.851, green: 0.922, blue: 1.0)
                        // Accent: #FF8C00 (Orange)
                        let seaAccent = Color(red: 1.0, green: 0.55, blue: 0.0)
       
                    
                    // Standard colors for the Sea gradient
                    let seaGradientColors: [Color] = [Sea.topLight, Sea.bottomDark]

                    switch screen {
                    case .focus, .history, .settings:
                        // These main tabs use solid backgrounds
                        return .init(
                            primary: Color(red: 0.00, green: 0.30, blue: 0.70),
                            background: seaBG,
                            surface: seaText.opacity(0.12),
                            accent: seaAccent,
                            text: seaText,
                            gradientBackground: nil
                        )
                        
                    case .recalibrate:
                        // Unique Gradient Direction: Diagonal
                        return .init(
                            primary: Color(red: 0.00, green: 0.12, blue: 0.22),
                            background: Sea.bottomDark.opacity(0.9),
                            surface: seaText.opacity(0.15),
                            accent: seaAccent,
                            text: .white,
                            gradientBackground: .init(
                                colors: seaGradientColors,
                                start: .topLeading,
                                end: .bottomTrailing // ‚ÜñÔ∏è Diagonal flow
                            )
                        )
                        
                    case .membership:
                        // Unique Gradient Direction: Horizontal
                        return .init(
                            primary: Color(red: 0.00, green: 0.28, blue: 0.62),
                            background: seaBG,
                            surface: seaText.opacity(0.12),
                            accent: seaAccent,
                            text: seaText,
                            gradientBackground: .init(
                                colors: seaGradientColors,
                                start: .leading,
                                end: .trailing // ‚û°Ô∏è Horizontal flow
                            )
                        )
                        
                    case .organizer:
                        // Unique Gradient Direction: Vertical
                        return .init(
                            primary: Color(red: 0.00, green: 0.28, blue: 0.62),
                            // Background is .clear to ensure the gradient shows through FocusShell
                            background: .clear,
                            surface: seaText.opacity(0.12),
                            accent: seaAccent,
                            text: seaText,
                            gradientBackground: .init(
                                colors: seaGradientColors,
                                start: .top,
                                end: .bottom // ‚¨áÔ∏è Vertical flow
                            )
                        )
                    }
        }
    }
}

// MARK: - Theme Manager
@MainActor
final class ThemeManager: ObservableObject {
    @AppStorage("selectedColorTheme") private var colorRaw: String = AppColorTheme.default.rawValue
    @AppStorage("selectedFontTheme")  private var fontRaw: String = AppFontTheme.serif.rawValue

    @Published var colorTheme: AppColorTheme {
        didSet { colorRaw = colorTheme.rawValue }
    }
    @Published var fontTheme: AppFontTheme {
        didSet { fontRaw  = fontTheme.rawValue  }
    }

    init() {
        let storedColor = UserDefaults.standard.string(forKey: "selectedColorTheme") ?? AppColorTheme.default.rawValue
        let storedFont  = UserDefaults.standard.string(forKey: "selectedFontTheme")  ?? AppFontTheme.serif.rawValue
        self.colorTheme = AppColorTheme(rawValue: storedColor) ?? .default
        self.fontTheme  = AppFontTheme(rawValue: storedFont)  ?? .serif
    }

    func palette(for screen: ScreenName) -> ScreenStylePalette {
        colorTheme.colors(for: screen)
    }

    func styledText(_ content: String, as role: TextRole, in screen: ScreenName) -> Text {
        let font  = fontTheme.toFont(Self.fontStyle(for: role))
        let color = Self.color(for: role, palette: palette(for: screen))
        
        let weight: Font.Weight = switch role {
            case .largeTitle: .bold
            case .header:.semibold
            case .section: .semibold
            case .title3:.semibold
            case .label: .medium
            case .action:.semibold
            default: .regular
        }
        return Text(content).font(font).fontWeight(weight).foregroundColor(color)
    }

    // MARK: Style mapping
    static func fontStyle(for role: TextRole) -> Font.TextStyle {
        switch role {
            case .largeTitle: .largeTitle
            case .header: .largeTitle
            case .section: .title2
            case .title3:.title3
            case .label: .headline
            case .action:.headline
            case .body: .body
            case .tile: .body
            case .secondary: .subheadline
            case .placeholder: .subheadline
            case .caption: .caption
        }
    }
    
    static func color(for role: TextRole, palette: ScreenStylePalette) -> Color {
        switch role {
            case .header, .section, .title3, .body, .tile, .largeTitle, .label:
                return palette.text
                
            case .secondary, .caption, .placeholder:
                // Calculate secondary text color based on primary theme text color.
                return palette.text.opacity(0.72)
                
            case .action:
                // Actions (buttons) often use white/light text for contrast against a filled background.
                return .white
        }
    }
}

// MARK: - Legacy / Utility Colors (Cleaned up)
extension Color {
    // New utility color for actions where white might be too harsh
    static let intText = Color(red: 0.96, green: 0.96, blue: 0.96) // #F5F5F5

}

//Color + contrast utilities (safe, sRGB-linear, works with SwiftUI Color)
//
//Color extension to calculate .shadow or .material combination best contrasting with the text color of the specific screen based on the gradient background's luminence; the logic would then be applied to the specific areas behind text
//import SwiftUI
//
//extension Color {
//    func luminance() -> Double {
//        var r: CGFloat = 0, g: CGFloat = 0, b: CGFloat = 0, a: CGFloat = 0
//        
//        // Convert SwiftUI Color to UIKit's UIColor to get RGB components
//        guard UIColor(self).getRed(&r, green: &g, blue: &b, alpha: &a) else {
//            return 0.0
//        }
//        
//        // sRGB to linear RGB conversion
//        let adjustedR = (r < 0.04045) ? r / 12.92 : pow((r + 0.055) / 1.055, 2.4)
//        let adjustedG = (g < 0.04045) ? g / 12.92 : pow((g + 0.055) / 1.055, 2.4)
//        let adjustedB = (b < 0.04045) ? b / 12.92 : pow((b + 0.055) / 1.055, 2.4)
//        
//        // Calculate luminance (perceived brightness)
//        return 0.2126 * adjustedR + 0.7152 * adjustedG + 0.0722 * adjustedB
//    }
//
//    func contrasted(against color: Color) -> Color {
//        let textLuminance = self.luminance()
//        let backgroundLuminance = color.luminance()
//        let contrastRatio = (max(textLuminance, backgroundLuminance) + 0.05) / (min(textLuminance, backgroundLuminance) + 0.05)
//        
//        // W3C recommendation for enhanced contrast is 7:1 (AAA)
//        // A ratio of 4.5:1 is the minimum (AA)
//        // Adjust the threshold to achieve the desired contrast
//        if contrastRatio < 6.1 {
//            // Not enough contrast, choose a contrasting color
//            return backgroundLuminance > 0.5 ? .black : .white
//        } else {
//            return self
//        }
//    }
//}
//
//In SwiftUI, a texturized gradient background with superior contrast can be created by layering a subtle noise or grain texture over a LinearGradient. The texture helps to break up the smooth gradient, ensuring a more consistent contrast ratio against the text, which is a key accessibility requirement. A contrast ratio of 4.5:1 is the standard for normal text, with 3:1 for larger text, so 6.1:1 offers excellent readability.
//Method 1: Using a noise shader
//This modern technique provides the best performance and flexibility for generating procedural textures.
//1. Create a noise shader
//Create a new Metal file (.metal) in Xcode, for instance NoiseShader.metal, with the following code to generate a simple noise texture.
//
// // NoiseShader.metal
//#include <metal_stdlib>
//using namespace metal;
//
//[[ stitchable ]] half4 noiseShader(float2 position, half4 color, float2 size, float time) {
//    float value = fract(sin(dot(position + time, float2(12.9898, 78.233))) * 43758.5453);
//    return half4(value, value, value, 1) * color.a;
//}
//
//2. Define within the AvailabilityTarget+.swift
//
//3. Apply the shader in a SwiftUI view
//You can now apply this shader to your gradient in SwiftUI.
//
// 4. How it works:
//A LinearGradient provides the base light colors.
//The .visualEffect modifier applies the noiseShader using a layerEffect.
//The time parameter can be used to animate the noise, or you can use a fixed value to create a static texture.
//An opaque or translucent background, such as .ultraThinMaterial, can be placed directly behind the text to ensure the contrast ratio remains high in all areas, while still letting the textured background show through.
//
//
//import SwiftUI
//
//struct TexturedGradientView: View {
//    let lightColors: [Color] = [Color(red: 0.95, green: 0.98, blue: 1.0), Color(red: 0.85, green: 0.95, blue: 1.0)]
//
//    var body: some View {
//        ZStack {
//            // Background Layer
//            LinearGradient(
//                colors: lightColors,
//                startPoint: .top,
//                endPoint: .bottom
//            )
//            .ignoresSafeArea()
//            .visualEffect { content, proxy in
//                content
//                    .layerEffect(
//                        ShaderLibrary.default.noiseShader(
//                            .boundingRect,
//                            .float(3.0), // Noise strength
//                            .float(proxy.time)
//                        ),
//                        maxSampleOffset: .zero // For static noise
//                    )
//            }
//
//            // Foreground Text
//            VStack {
//                Text("Superior Contrast")
//                    .font(.largeTitle)
//                    .fontWeight(.bold)
//                    .foregroundColor(.black)
//                Text("6.1:1 Contrast Ratio")
//                    .font(.title)
//                    .foregroundColor(.black.opacity(0.8))
//            }
//            .padding(20)
//            .background(.ultraThinMaterial) // Use material for guaranteed contrast on text
//            .cornerRadius(12)
//        }
//    }
//}
-e \n\n
=== ./intention/Shared/Utilities/friendlyAnimatedHelper.swift ===
//
//  friendlyAnimatedHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import SwiftUI

extension View {
    /// Mark as a rotor-friendly heading
    func friendlyHelper() -> some View { self.accessibilityAddTraits(.isHeader) }

    /// Gate animations for motion sensitivity
    func friendlyAnimatedHelper(_ value: AnyHashable, animation: Animation = .easeInOut) -> some View {
        modifier(AnimatedIfAllowed(value: value, animation: animation))
    }
}

private struct AnimatedIfAllowed<V: Hashable>: ViewModifier {
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    let value: V
    let animation: Animation
    func body(content: Content) -> some View {
        content.animation(reduceMotion ? nil : animation, value: value)
    }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig.swift ===
//
//  TimerConfig.swift
//  intention
//
//  Created by Benjamin Tryon on 8/7/25.
//

import SwiftUI
import Foundation

/// Single source of truth for all durations
/// In UI tests, pass a launch argument to flip to short timers
struct TimerConfig: Sendable {
    // MARK: Focus/session
    let chunkDuration: Int          /// 20-min chunks (1200)
    
    // MARK: Haptics policy
    struct Haptics: Sendable {
        let endCountdownStart: Int       // 3s
        let halfwayTick: Bool
        let balanceSwapInterval: Int     // 60s
    }
    let haptics: Haptics
    
    // sensible default haptics
    init(chunkDuration: Int,
         haptics: Haptics = .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 60)) {
        self.chunkDuration = chunkDuration
        self.haptics = haptics
    }

    static let prod = TimerConfig(chunkDuration: 20 * 60)
    static let shortDebug = TimerConfig(chunkDuration: 10,
                                        haptics: .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 5))

    static var current: TimerConfig {
        #if DEBUG
        let override = UserDefaults.standard.integer(forKey: "debug.chunkSeconds")
        return TimerConfig(chunkDuration: override > 0 ? override : 20 * 60)
        #else
        return TimerConfig(chunkDuration: 20 * 60)
        #endif
    }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig+UITest.swift ===
//
//  TimerConfig+UITest.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

//import Foundation
//
//extension TimerConfig {
//    static let fastUITest = TimerConfig(
//    chunkDuration: 3,
//        haptics: .init(endCountdownStart: 1, halfwayTick: false, balanceSwapInterval: 1)
//    )
//}
-e \n\n
=== ./intention/Shared/Components/UnwindingPie.swift ===
//
//  UnwindingPie.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI

struct UnwindingPieShape: Shape {
    var progress: Double        // from 0.0 to 1.0
    
    var animatableData: Double {
        get { progress }
        set { progress = newValue }
    }
    
    func path(in rect: CGRect) -> Path {
        var path = Path()
        
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2
        let startAngle = -90.0
        let endAngle = startAngle - (progress * 360)

        path.move(to: center)
        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(startAngle),
            endAngle: .degrees(endAngle),
            clockwise: true
        )
        path.closeSubpath()

        return path
    }
}

struct Pie: View {
    @EnvironmentObject var theme: ThemeManager
    @State private var remainingTime = 60.0
    let totalTime: TimeInterval = 60.0
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    
    var body: some View {
        let palette = theme.palette(for: .focus)
        ZStack {
            Circle()
                .fill(palette.background.opacity(0.2))
            
            UnwindingPieShape(progress: remainingTime / totalTime)
                .fill(palette.accent)
            
        }
        .frame(width: 200, height: 200)
        .onReceive(timer) { _ in
            if remainingTime > 0 {
                remainingTime -= 1
            }}
    }
}

#if DEBUG
#Preview {
    Pie()
}
#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/PreviewWrapper.swift ===
//
//  PreviewWrapper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

#if DEBUG
import SwiftUI

@MainActor
struct PreviewWrapper<Content: View>: View {
    let content: () -> Content

    var body: some View {
        content()
            .environmentObject(PreviewMocks.theme)
            .environmentObject(PreviewMocks.prefs)
            .environmentObject(PreviewMocks.membershipVM)
            .environmentObject(PreviewMocks.history)        /// some subviews use HistoryVM via EnvironmentObject
            .environmentObject(PreviewMocks.stats)
    }
}
#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/OrganizerOverlayPreviewHost.swift ===
//
//  OrganizerOverlayPreviewHost.swift
//  intention
//
//  Created by Benjamin Tryon on 10/26/25.
//
#if DEBUG
import SwiftUI

struct OrganizerOverlayPreviewHost: View {
    @State var cats: [CategoriesModel] = [
        .init(id: UUID(),
              persistedInput: "Work",
              tiles: [TileM(text: "Scope product"), TileM(text: "Follow ups due Wednesday")]
             ),
        .init(id: UUID(),
              persistedInput: "Life",
              tiles: [TileM(text: "Groceries"), TileM(text: "squash")]
             )
    ]
    var body: some View {
        OrganizerOverlayChrome(onClose: {}) {
            OrganizerOverlayScreen(
                categories: $cats,
                onMoveTile: { _,_,_ in },
                onReorder: { _,_ in },
                onDone: {}
            )
        }
    }
}

#Preview {
    PreviewWrapper { OrganizerOverlayPreviewHost().previewTheme() }
}
#endif

#Preview("Organizer Overlay"){
    PreviewWrapper { OrganizerOverlayPreviewHost().previewTheme() }
}
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/PreviewMocks.swift ===
//
//  PreviewMocks.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

#if DEBUG
import SwiftUI

enum PreviewMocks {
    // One persistence for everything in previews
    @MainActor static let persistence = PersistenceActor()
    
    @MainActor static let history: HistoryVM = {
        let h = HistoryVM(persistence: persistence)
        h.generalCategoryID = UUID(uuidString: "11111111-1111-1111-1111-111111111111")!
        h.archiveCategoryID = UUID(uuidString: "22222222-2222-2222-2222-222222222222")!
        h.ensureGeneralCategory()
        h.ensureArchiveCategory()
        return h
    }()
    
    @MainActor static let stats: StatsVM = {
        StatsVM(persistence: persistence)
    }()
    
    // inject PaymentService(productIDs:) and use the VM‚Äôs debug setter
    @MainActor static let membershipVM: MembershipVM = {
        let svc = PaymentService(productIDs: ["com.argonnesoftware.intention"])
        let vm  = MembershipVM(payment: svc)
        #if DEBUG
        vm._debugSetIsMember(false)   // Preview non-member state; flip to true if needed
        #endif
        return vm
    }()
    
    @MainActor static let prefs: AppPreferencesVM = { AppPreferencesVM()
    }()
    
    @MainActor static let theme: ThemeManager = { ThemeManager()
    }()
    
    @MainActor static let focusSession: FocusSessionVM = {
        let vm = FocusSessionVM(previewMode: true,
                                haptics: NoopHapticsClient(),    // ‚Üê ignore haptics in previews
                                config: .current)                 // your TimerConfig already returns .shortDebug in previews
        vm.historyVM = history
        return vm
    }()
    
    @MainActor static let recal: RecalibrationVM = {
        RecalibrationVM(haptics: NoopHapticsClient())             // ‚Üê ignore in previews
        
    }()
//    
//    
//    // Simple visual data used by many previews
//    @MainActor static func organizerSampleCategories() -> [CategoriesModel] {
//        [
//            .init(id: UUID(), persistedInput: "Work",
//                  tiles: [TileM(text: "Write spec"), TileM(text: "Code review")]),
//            .init(id: UUID(), persistedInput: "Life",
//                  tiles: [TileM(text: "Laundry"), TileM(text: "Call mom")])
//        ]
//    }
    // A convenience Recalibration instance using the VM‚Äôs canonical debug factory:
    @MainActor static func recalibrationRunning() -> RecalibrationVM {
        RecalibrationVM.mockForDebug() // uses the helper defined in the VM file
    }

}
#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/ValidationDebugPreview.swift ===
//
//  ValidationDebugPreview.swift
//  intention
//
//  Created by Benjamin Tryon on 10/1/25.
//

#if DEBUG
import SwiftUI

// MARK: - Validation Debug Preview

/// Use this view to test all ValidationState cases, border colors, and captions.
@MainActor
struct ValidationDebugPreview: View {
    
    // 1. Fetch the necessary environment objects
    @EnvironmentObject var theme: ThemeManager
    
    // 2. State variables for testing
    @State private var inputText: String = ""
    @State private var showValidation: Bool = false // The 'on submit' gate
    @State private var scenario: Scenario = .default

    // Use the ThemeManager to get the current palette, just like FocusSessionActiveV
    private var p: ScreenStylePalette { 
        // Assuming you have a ScreenName for this preview, or use a known one
        theme.palette(for: .focus) 
    }
    
    // Mimics the vState computed property from FocusSessionActiveV
    private var computedValidationState: ValidationState {
        // This relies on the String extensions from ValidationResults+Fuzzy.swift
        guard showValidation else { return .none }
        
        // This calls your existing validation logic
        let msgs = inputText.taskValidationMessages 
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }

    // A simple enum to switch between demo cases quickly
    enum Scenario: String, CaseIterable, Identifiable {
        case `default` = "0. Initial: .none (Charcoal border)"
        case invalidEmpty = "1. Invalid: Empty (Red border + Caption)"
        case invalidLong = "2. Invalid: Too long (Red border + Caption)"
        case valid = "3. Valid (Standard border, No Caption)"
        var id: String { rawValue }
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 30) {
            
            Text("Validation Field Tester (iPhone 15, iOS 16+)")
                .font(.title2)
                .fontWeight(.bold)
                .foregroundStyle(p.text)
            
            // ------------------------------------
            // INTERACTIVE DEBUG CONTROLS
            // ------------------------------------
            Group {
                Picker("Debug Scenario", selection: $scenario) {
                    ForEach(Scenario.allCases) { s in
                        Text(s.rawValue).tag(s)
                    }
                }
                .pickerStyle(.menu)
                .onChange(of: scenario) { newValue in
                    applyScenario(newValue)
                }
                .animation(.none, value: scenario) // Prevent animation on scenario change

                Toggle("Show Validation Errors (Simulate Submit)", isOn: $showValidation)
            }
            .padding(10)
            .background(Color.gray.opacity(0.1))
            .clipShape(RoundedRectangle(cornerRadius: 8))

            // ------------------------------------
            // THE COMPONENT UNDER TEST
            // ------------------------------------
            VStack(alignment: .leading, spacing: 8) {
                Text("Your Task Input Field")
                    .font(.headline)
                    .foregroundStyle(p.text)
                
                // 1. The TextField using your ValidatingField modifier
                TextField("Add Your Intended Task", text: $inputText)
                    .validatingField(state: computedValidationState, palette: p)
                    .animation(.easeInOut(duration: 0.2), value: computedValidationState.isInvalid)

                // 2. The ValidationCaption below the field
                ValidationCaption(state: computedValidationState)
                    .animation(.easeInOut(duration: 0.2), value: computedValidationState.isInvalid)
            }
            
            Spacer()
        }
        .padding()
        .background(p.background.edgesIgnoringSafeArea(.all))
        .onAppear {
            applyScenario(scenario)
        }
    }

    // Function to apply the selected debug state
    func applyScenario(_ scenario: Scenario) {
        switch scenario {
        case .default:
            inputText = "Initial text."
            showValidation = false
        case .invalidEmpty:
            inputText = " "
            showValidation = true
        case .valid:
            inputText = "This is a great intention that is well within the 200 character limit."
            showValidation = true
        case .invalidLong:
            // Create a string over 200 characters
            inputText = String(repeating: "The task is to be repeated over and over and over and over and over and over and over and over and over.", count: 6)
            showValidation = true
        }
    }
}

// MARK: - Preview Setup

struct ValidationDebugPreview_Previews: PreviewProvider {
    static var previews: some View {
        // Use your existing wrapper to inject all required EnvironmentObjects
        PreviewWrapper { 
            ValidationDebugPreview()
        }
        .previewDevice("iPhone 15")
    }
}
#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/PreviewTheme+Ext.swift ===
//
//  File.swift
//  intention
//
//  Created by Benjamin Tryon on 10/24/25.
//

// MARK: Preview Convenience
#if DEBUG
import SwiftUI

extension View {
    func previewTheme() -> some View {
        self.environmentObject(PreviewMocks.theme)
    }
}
#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/PreviewsDebug.swift ===
//
//  PreviewsDebug.swift
//  intention
//
//  Created by Benjamin Tryon on 10/26/25.
//
#if DEBUG
import SwiftUI

// Recalibration - Running
#Preview("Recalibration * Running"){
    PreviewWrapper {
        RecalibrationV(vm: RecalibrationVM.mockForDebug()).previewTheme()
    }
}
// Organizer overlay ‚Äî mock binding
#Preview("Organizer Overlay") {
    MainActor.assumeIsolated {
        @State var cats: [CategoriesModel] = [
            // ‚Ä¶seed a couple of categories with a few tiles‚Ä¶
        ]
        return OrganizerOverlayChrome(onClose: {}) {
            OrganizerOverlayScreen(
                categories: $cats,
                onMoveTile: { _,_,_ in },
                onReorder: { _,_ in },
                onDone: {}
            )
        }
        .environmentObject(PreviewMocks.theme)
    }
}

// Membership sheet ‚Äî non-member
#Preview("Membership ‚Äî Not Active") {
    MainActor.assumeIsolated {
        let memberVM = MembershipVM(payment: PaymentService(productIDs: ["com.argonnesoftware.intention"]))
        memberVM._debugSetIsMember(false)
        return MembershipSheetV()
            .environmentObject(PreviewMocks.theme)
            .environmentObject(memberVM)
            .environmentObject(PreviewMocks.prefs)
            .environmentObject(PreviewMocks.history)
            .environmentObject(PreviewMocks.stats)
    }
}
#endif
-e \n\n
=== ./intention/Shared/Legal/LegalConfig.swift ===
//
//  LegalConfig.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI
import UIKit

// MARK: - File config (do NOT include .md)
/// Gate logic checks acceptedVersion < currentVersion. After you ship an update with currentVersion = 2, any user who previously accepted version 1 will see the legal sheet again on next launch.
enum LegalConfig {
    static let currentVersion = 1               // "bumping" this (1 to 2 to 3)
    static let termsFile   = "termsMarkdown"
    static let privacyFile = "privacyMarkdown"
    static let medicalFile = "medicalMarkdown"
}
-e \n\n
=== ./intention/Shared/Legal/LegalAgreementSheetV.swift ===
//
//  LegalAgreementSheetV.swift
//  intention
//
//  Created by Benjamin Tryon on 9/4/25.
//

import SwiftUI

struct LegalAgreementSheetV: View {
    let onAccept: () -> Void
    let onShowTerms: () -> Void
    let onShowPrivacy: () -> Void
    var onShowMedical: (() -> Void)?   // optional extra link
    
    // --- Local Color Definitions for Legal ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        NavigationStack {
        VStack(spacing: 14){
                Text("Please review the policies below. By tapping **Agree & Continue**, you accept them.")
                .multilineTextAlignment(.leading)
                .font(.subheadline)
                .foregroundStyle(.secondary)
                .lineSpacing(4)
                
                // Links row
                HStack(alignment: .center) {
                    Button("Terms") { onShowTerms() }
                        .buttonStyle(.plain).underline()
                    Text("‚Ä¢").foregroundStyle(.tertiary)
                    Button("Privacy Policy") { onShowPrivacy() }
                        .buttonStyle(.plain).underline()
                }
                .font(.subheadline)
                
                if let onShowMedical {
                    Button("Wellness Disclaimer") { onShowMedical() }
                        .buttonStyle(.plain)
                        .underline()
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
                
               
//                Spacer(minLength: 0)
            }
            .frame(maxWidth: 520)
            .navigationTitle("Legal")
            .navigationBarTitleDisplayMode(.inline)
            .interactiveDismissDisabled(true)
            // Full-screen style
            .presentationDetents([.large])
            .safeAreaInset(edge: .bottom){
                // Sticky, always-visible CTA area
                VStack(spacing: 8){
                    Button("Agree & Continue", action: onAccept)
                        .buttonStyle(.borderedProminent)
                        .tint(.blue)
                        .controlSize(.large)

                    Text("You can review these anytime in **Settings ‚Ä∫ Legal**.")
                        .font(.footnote)
                        .foregroundStyle(.tertiary)
                }
                .padding(.horizontal, 16)
                .padding(.top, 10)
                .padding(.bottom, 16)
                .background(.ultraThinMaterial)
            }
        }
    }
}

#if DEBUG
#Preview {
    LegalAgreementSheetV(
        onAccept: {},
        onShowTerms: {},
        onShowPrivacy: {}
    )
}
#endif
-e \n\n
=== ./intention/Shared/Legal/SimpleMarkdownView.swift ===
//
//  SimpleMarkdownView.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

/// Renders a very simple "paragraphs only" view from Markdown input.
/// - Strips markdown formatting (headers, lists, emphasis, code ticks, links),
///   collapses blank lines, and shows paragraphs with uniform spacing.
struct SimpleMarkdownView: View {
    let markdown: String
    
    // Layout ‚Äúdials‚Äù
    var h1Font: Font = .title.weight(.semibold)
    var h2Font: Font = .title2.weight(.semibold)
    var h3Font: Font = .headline
    var bodyFont: Font = .body
    
    var h1Top: CGFloat = 4, h1Bottom: CGFloat = 8
    var h2Top: CGFloat = 12,h2Bottom: CGFloat = 6
    var h3Top: CGFloat = 10, h3Bottom: CGFloat = 4
    var paragraphSpacing: CGFloat = 10
    var horizontalPadding: CGFloat = 20
    var verticalPadding: CGFloat = 24
    
    private var blocks: [Block] { Self.parse(markdown: markdown) }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            ForEach(blocks.indices, id:\.self) { i in
                let block = blocks[i]
                switch block {
                case .h1(let t):
                    Text(t)
                        .font(h1Font)
                        .padding(.top, h1Top)
                        .padding(.bottom, h1Bottom)
                case .h2(let t):
                    Text(t)
                        .font(h2Font)
                        .padding(.top, h2Top)
                        .padding(.bottom, h2Bottom)
                case .h3(let t):
                    Text(t)
                        .font(h3Font)
                        .padding(.top, h3Top)
                        .padding(.bottom, h3Bottom)
                case .p(let p):
                    Text(p)
                        .font(bodyFont)
                        .padding(.bottom, paragraphSpacing)
                }
            }
        }
        .padding(.horizontal, horizontalPadding)
        .padding(.vertical, verticalPadding)
    }
}

// MARK: - Parser
extension SimpleMarkdownView {
    enum Block { case h1(String), h2(String), h3(String), p(String) }

    static func parse(markdown: String) -> [Block] {
        // Normalize endings and strip BOM
        var s = markdown
            .replacingOccurrences(of: "\r\n", with: "\n")
            .replacingOccurrences(of: "\r", with: "\n")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        if s.hasPrefix("\u{FEFF}") { s.removeFirst() }

        // Build blocks
        var blocks: [Block] = []
        var paragraphBuffer: [String] = []

        func flushParagraph() {
            guard !paragraphBuffer.isEmpty else { return }
            let text = paragraphBuffer.joined(separator: " ").trimmingCharacters(in: .whitespacesAndNewlines)
            if !text.isEmpty { blocks.append(.p( stripInline(text) )) }
            paragraphBuffer.removeAll()
        }

        for rawLine in s.split(separator: "\n", omittingEmptySubsequences: false) {
            let line = String(rawLine).trimmingCharacters(in: .whitespaces)

            if line.isEmpty { flushParagraph();continue }

            // Headings only when the line *starts* with hashes
            if let h = headingText(line, level: 1) {
                flushParagraph()
                blocks.append(.h1( stripInline(h) ))
                continue
            }
            if let h = headingText(line, level: 2) {
                flushParagraph()
                blocks.append(.h2( stripInline(h) ))
                continue
            }
            if let h = headingText(line, level: 3) {
                flushParagraph()
                blocks.append(.h3( stripInline(h) ))
                continue
            }

            // Otherwise accumulate paragraph
            paragraphBuffer.append(line)
        }

        flushParagraph()
        return blocks
    }

    /// If line starts with `# ` (repeated `level` times), return text after the marker; else nil.
    private static func headingText(_ line: String, level: Int) -> String? {
        let prefix = String(repeating: "#", count: level) + " "
        return line.hasPrefix(prefix)
            ? String(line.dropFirst(prefix.count)).trimmingCharacters(in: .whitespaces)
        : nil
        }

    /// Strip simple inline markdown: **bold**, __bold__, *em*, _em_, `code`, and [text](url) ‚Üí text
    private static func stripInline(_ s: String) -> String {
        var out = s
        // Links: [text](url) -> text  (manual pass to avoid $1 issues)
        out = stripLinks(out)
        // Remove paired markers by just deleting the markers
        let markers = ["**", "__", "*", "_", "`"]
        for m in markers {
            out = out.replacingOccurrences(of: m, with: "")
        }
        // Collapse internal extra spaces
        while out.contains("  ") { out = out.replacingOccurrences(of: "  ", with: " ") }
        return out.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    /// Very small link stripper: replaces `[label](...)` with `label`
    private static func stripLinks(_ s: String) -> String {
        var result = ""
        var i = s.startIndex
        while i < s.endIndex {
            if s[i] == "[",
               // closeBracket, closeParen
                let closeBracket = s[i...].firstIndex(of: "]"),
               closeBracket < s.index(before: s.endIndex),
                   s[s.index(after: closeBracket)] == "(",
                   let closeParen = s[s.index(after: closeBracket)...].firstIndex(of: ")"){
                    // Append label only
                    let label = s[s.index(after: i)..<closeBracket]
                    result.append(contentsOf: label)
                    i = s.index(after: closeParen)
                    continue
                }
            result.append(s[i])
            i = s.index(after: i)
        }
        return result
    }
}
-e \n\n
=== ./intention/Shared/Legal/LegalDocV.swift ===
//
//  LegalDocV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: Reusable Markdown screen
struct LegalDocV: View {
    let title: String
    let markdown: String
    
    var body: some View {
        ScrollView {
            SimpleMarkdownView(
                markdown: markdown
            )
            //            VStack(alignment: .leading, spacing: 16) {
            //                if let attr = try? AttributedString(markdown: markdown) {
            //                    Text(attr).textSelection(.enabled)
            //                } else {
            //                Text(formatted(markdown: markdown)).textSelection(.enabled).tint(Color.blue).frame(maxWidth: .infinity, alignment: .leading)
            //            }
            .frame(maxWidth: 700)
        }
        .background(Color.white.ignoresSafeArea())
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
        .toolbarBackground(.visible, for: .navigationBar)
        .toolbarBackground(.visible, for: .navigationBar)
        .scrollIndicators(.hidden)
    }
}
-e \n\n
=== ./intention/Shared/Legal/LegalKeys.swift ===
//
//  LegalKeys.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: - Persisted acceptance state
struct LegalKeys {
    static let acceptedVersion = "legal.acceptedVersion"
    static let acceptedAtEpoch = "legal.acceptedAtEpoch"
}

enum LegalConsent {
    static func needsConsent(currentVersion: Int = LegalConfig.currentVersion) -> Bool {
        UserDefaults.standard.integer(forKey: LegalKeys.acceptedVersion) < currentVersion
    }
    static func recordAcceptance(currentVersion: Int = LegalConfig.currentVersion) {
        UserDefaults.standard.set(currentVersion, forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.set(Date().timeIntervalSince1970, forKey: LegalKeys.acceptedAtEpoch)
    }
    /// DEBUG: clear all acceptance so the sheet will show again
    static func clearForDebug() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
    }
}
-e \n\n
=== ./intention/Shared/Legal/MarkdownLoader.swift ===
//
//  MarkdownLoader.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: - Markdown loader (accepts base name; always reads .md from bundle)
enum MarkdownLoader {
    /// Loads a Markdown file from the app bundle by base name.
    /// - Parameter name: The file base name, with or without the `.md` suffix.
    /// - Returns: The normalized Markdown text, or an empty string if not found.
    static func load(named name: String) -> String {
        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
        let base = trimmed.lowercased().hasSuffix(".md") ? String(trimmed.dropLast(3)) : trimmed
        
        // Try locating "<base>.md" in the main bundle
        guard let url = Bundle.main.url(forResource: base, withExtension: "md") else {
            print("‚ö†Ô∏è MarkdownLoader: Missing \(base).md in the main bundle.")
            return ""
        }
        
        do {
            var text = try String(contentsOf: url, encoding: .utf8)
            // normalize endings + strip leading BOM in case an editor added it
            if text.hasPrefix("\u{FEFF}") { text.removeFirst() }
            text = text.replacingOccurrences(of: "\r\n", with: "\n")
                .replacingOccurrences(of: "\r", with: "\n")
            return text
        } catch {
            print("‚ö†Ô∏è MarkdownLoader: Failed to read \(base).md - \(error)")
            return ""
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/DragPayload.swift ===
//
//  DragPayload.swift
//  intention
//
//  Created by Benjamin Tryon on 9/20/25.
//

import Foundation
import UniformTypeIdentifiers
import SwiftUI

struct DragPayload: Codable, Hashable, Transferable {
    let tile: TileM
    let sourceCategoryID: UUID

    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CategoryTileList.swift ===
//
//  CategoryTileList.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI
import UniformTypeIdentifiers

// Rows only -> movement handled by VM via `.dropDestination`
struct CategoryTileList: View {
    @Binding var category: CategoriesModel
    @EnvironmentObject var viewModel: HistoryVM
    @EnvironmentObject var theme: ThemeManager
    @Environment(\.editMode) private var editMode
    let isArchive: Bool
    //    let saveHistory: () -> Void
    //    let palette: ScreenStylePalette
    //    let fontTheme: AppFontTheme
    //
    //        .font(fontTheme.toFont(.subheadline))
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        if category.tiles.isEmpty {
            theme.styledText(isArchive ? "No archived items yet." : "Completed", as: .caption, in: screen)
                .foregroundStyle(textSecondary)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(10)
                .background(p.background, in: RoundedRectangle(cornerRadius: 8, style: .continuous))
        } else {
            LazyVStack(spacing: 12) {
                ForEach(category.tiles, id: \.id) { tile in
                    VStack(spacing: 0) {
                        HStack(alignment: .firstTextBaseline) {
                            T(tile.text, .body)
                                .foregroundStyle(p.surface)
                                .multilineTextAlignment(.leading)
                            
                            //                        if isArchive {
                            //                            Image(systemName: "archivebox")
                            //                                .imageScale(.small)
                            //                                .secondaryActionStyle(screen: screen)
                            //                                .frame(maxWidth: .infinity)
                            //                        }
                            
                            Spacer()
                        }
                        .padding(10)
                        .background(Color(.secondarySystemBackground), in: RoundedRectangle(cornerRadius: 8, style: .continuous))
                        .draggable(DragPayload(tile: tile, sourceCategoryID: category.id))
                        .swipeActions(edge: .trailing, allowsFullSwipe: !isArchive) {
                            if !isArchive {
                                Button(role: .destructive) {
                                    if let idx = category.tiles.firstIndex(of: tile) {
                                        category.tiles.remove(at: idx)
                                        // Persist via VM reorderTiles already applies caps + persists, updateTiles() & saveHistory() redundant
                                        viewModel.reorderTiles(category.tiles, in: category.id)
                                    }
                                } label: { Label("Delete", systemImage: "trash") } //FIXME: how to conform to the thememanager?
                                
                                Button {
                                    Task {
                                        do {
                                            try await viewModel.moveTileThrowing(tile, fromCategory: category.id, toCategory: viewModel.archiveCategoryID)
                                        } catch { viewModel.lastError = error }
                                    }
                                } label: { Label("Archive", systemImage: "archivebox") }
                            }
                        }
                        // Per-tile light tan separator
                        if tile.id != category.tiles.last?.id {
                            Rectangle()
                                .fill(Color.intTan)         // light tan between tiles
                                .frame(height: 1)
                                .padding(.leading, 6)       // optional indent to look lighter
                                .padding(.trailing, 6)
                                .padding(.top, 6)
                        }
                    }
                }
            }
            // dropDestination applies to the LazyVStack
            .dropDestination(for: DragPayload.self) { items, _ in
                guard let payload = items.first else { return false }
                // from == category.id, lets sthe organizer or per-category reorder handle it.
                guard payload.sourceCategoryID != category.id else { return false }
                Task {
                    do { try await viewModel.moveTileThrowing(payload.tile, fromCategory: payload.sourceCategoryID, toCategory: category.id) }
                    catch { viewModel.lastError = error }
                }
                return true
            }
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/Math.swift ===
//
//  Math.swift
//  intention
//
//  Created by Benjamin Tryon on 9/16/25.
//

//      Add something tiny to test (in the app target)
//          create code ‚Üí make a test that passes ‚Üí then make it fail.
//      Create App/Helpers/Math.swift (target membership: your app target, not the test target):
import Foundation

// Minimal test seam
struct Math {
    static func sum(_ a: Int, _ b: Int) -> Int { a + b }
}
-e \n\n
=== ./intention/Shared/Helpers/DevButtonsInSettings.swift ===
//
//  DevButtonsInSettings.swift
//  intention
//
//  Created by Benjamin Tryon on 10/24/25.
//

import Foundation

extension Notification.Name {
    static let devOpenRecalibration      = Notification.Name("ShowRecalibrationToDebug")
    static let devOpenOrganizerOverlay   = Notification.Name("ShowOrganizerOverlayToDebug")
    static let devOpenMembership         = Notification.Name("ShowMembershipToDebug")
    static let debugShowSampleError       = Notification.Name("ShowSampleErrorToDebug")
    
}

// Helper struct for keys when passing data
enum DebugNotificationKey {
    static let errorTitle = "errorTitleKey"
    static let errorMessage = "errorMessageKey"
}
-e \n\n
=== ./intention/Shared/Helpers/KeychainHelper.swift ===
//
//  KeychainHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 7/10/25.
//

import Foundation
import Security

actor KeychainHelper {
    //    any issues with KeychainHelper as an actor,
    //    change to final class KeychainHelper: @unchecked Sendable { static let standard = KeychainHelper
    //      // _ same methods, but add 'async' AND call await KeychainHelper.shared.getUserIdentifier()
    
    static let shared = KeychainHelper()
    private init() {}
    
    /// Grabs system-provided bundle ID string - `private let` restrict `service` to that file
    private let service = Bundle.main.bundleIdentifier!
    private let account = "anonymousUserID"
    
    /// Returns the existing UUID, or generates+stores a new one
    func getUserIdentifier() -> String {
        if let existing = readUUID() {
            return existing
        } else {
            let newID = UUID().uuidString
            saveUUID(newID)
            #if DEBUG
            debugPrint("KeychainHelper: newID - \(newID)")
            #endif
            return newID
        }
    }
    
    /// Keep saveUUID() and readUUID() synchronous internally - no "async"
    private func saveUUID(_ uuid: String) {
            let data = Data(uuid.utf8)
            let query: [String: Any] = [
                kSecClass as String: kSecClassGenericPassword,
                kSecAttrService as String: service,
                kSecAttrAccount as String: account,
                kSecValueData as String: data
            ]
            // Remove any old and add new
            SecItemDelete(query as CFDictionary)
            SecItemAdd(query as CFDictionary, nil)
        }
    
    private func readUUID() -> String? {
            let query: [String: Any] = [
                kSecClass as String: kSecClassGenericPassword,
                kSecAttrService as String: service,
                kSecAttrAccount as String: account,
                kSecReturnData as String: true,
                kSecMatchLimit as String: kSecMatchLimitOne
            ]
            var result: AnyObject?
            let status = SecItemCopyMatching(query as CFDictionary, &result)
            guard status == errSecSuccess,
                  let data = result as? Data,
                  let str = String(data: data, encoding: .utf8)
            else { return nil }
            return str
        }
}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerWrapper.swift ===
//
//  TileOrganizerWrapper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/5/25.
//

import SwiftUI

// SwiftUI -> UIKit Bridge
struct TileOrganizerWrapper: UIViewControllerRepresentable {
    @EnvironmentObject var theme: ThemeManager
    
    // --- Local Color Definitions for Overlay ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    
    @Binding var categories: [CategoriesModel]
    let onMoveTile: (TileM, UUID, UUID) -> Void
    let onReorder: ([TileM], UUID) -> Void
    
    func makeUIViewController(context: Context) -> TileOrganizerVC {
        let vc = TileOrganizerVC()
        vc.onMoveTile = onMoveTile
        vc.onReorder = onReorder    // Hookup for persistence, called in/by HistoryVM
        
        // supply Organizer palette colors to UIKit
        //  - allows SwiftUI to access colors for it (the Overlay)
        
        let p = theme.palette(for: .organizer)
        vc.textColor = UIColor(p.accent)            //FIXME: is .accent correct?
        vc.tileSeparatorColor = UIColor(Color.intTan)   //FIXME: is .intTan correct?
        vc.sectionSeparatorColor = UIColor(colorBorder)
        vc.headerTextColor = UIColor(theme.palette(for: .history).text)
        vc.view.backgroundColor = .clear
        return vc
    }
    
    func updateUIViewController(_ uiViewController: TileOrganizerVC, context: Context) {
        uiViewController.update(categories: categories)
    }
}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerVC.swift ===
//
//  TileOrganizerVC.swift
//  intention
//
//  Created by Benjamin Tryon on 8/5/25.
//

import UIKit
// Authority on delegates and section headers - with reorder support and onReorder callback
//Within-category reorder (UIKit reordering, SwiftUI list drag end)

final class TileOrganizerVC: UICollectionViewController {
    var onMoveTile: (TileM, UUID, UUID) -> Void = { _, _, _ in }
    var onReorder: (([TileM], UUID) -> Void)?
    
    // injected from wrapper
    var textColor: UIColor = .label
    var tileSeparatorColor: UIColor = .separator
    var sectionSeparatorColor: UIColor = .separator
    var headerTextColor: UIColor = .label

    private var categories: [CategoriesModel] = []
    private var dragSourceIndexPath: IndexPath?

    init() {
        let layout = UICollectionViewFlowLayout()
        layout.sectionInset = UIEdgeInsets(top: 12, left: 16, bottom: 12, right: 16)
        // Self-sizing cells: give an estimated size, let Auto Layout compute height
        layout.estimatedItemSize = CGSize(width: UIScreen.main.bounds.width - 48, height: 56)
        layout.itemSize = UICollectionViewFlowLayout.automaticSize
        layout.headerReferenceSize = CGSize(width: UIScreen.main.bounds.width, height: 30)
        super.init(collectionViewLayout: layout)
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) not implemented") }

    override func viewDidLoad() {
        super.viewDidLoad()
        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "Cell")
        collectionView.register(HeaderView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: "Header")
        collectionView.dragDelegate = self
        collectionView.dropDelegate = self
        collectionView.dragInteractionEnabled = true
        collectionView.reorderingCadence = .immediate
        collectionView.backgroundColor = .clear
    }

    func update(categories: [CategoriesModel]) {
        self.categories = categories
        collectionView.reloadData()
    }

    override func numberOfSections(in collectionView: UICollectionView) -> Int {
        categories.count
    }

    override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        categories[section].tiles.count
    }

    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let tile = categories[indexPath.section].tiles[indexPath.row]
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)

        var config = UIListContentConfiguration.cell()
        config.text = tile.text
        config.textProperties.numberOfLines = 0          // allow wrapping
        config.textToSecondaryTextVerticalPadding = 6
        config.directionalLayoutMargins = .init(top: 10, leading: 12, bottom: 10, trailing: 12)
        
        config.textProperties.color = textColor             // accent label from struct TileOrganizerWrapper
        cell.contentConfiguration = config
        cell.backgroundColor = UIColor.secondarySystemBackground
        cell.layer.cornerRadius = 8
        cell.clipsToBounds = true
        
        // add/remove bottom separator (tan) except for the last row in the section
        cell.contentView.subviews.filter { $0.tag == 999 }.forEach { $0.removeFromSuperview() }
        let isLast = indexPath.row == collectionView.numberOfItems(inSection: indexPath.section) - 1
        if !isLast {
            let sep = UIView()
            sep.tag = 999
            sep.backgroundColor = tileSeparatorColor
            sep.translatesAutoresizingMaskIntoConstraints = false
            cell.contentView.addSubview(sep)
            NSLayoutConstraint.activate([
                sep.heightAnchor.constraint(equalToConstant: 1.0 / UIScreen.main.scale),
                sep.leadingAnchor.constraint(equalTo: cell.contentView.leadingAnchor, constant: 6),
                sep.trailingAnchor.constraint(equalTo: cell.contentView.trailingAnchor, constant: -6),
                sep.bottomAnchor.constraint(equalTo: cell.contentView.bottomAnchor)
        ])
        }

        return cell
    }
    
    // reordering within a single category, but prevents dragging into a different category via reorder
    override func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
        guard kind == UICollectionView.elementKindSectionHeader else { return UICollectionReusableView() }
        let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: "Header", for: indexPath) as! HeaderView
        header.label.text = categories[indexPath.section].persistedInput
        header.label.textColor = headerTextColor

                // bottom line between categories using "history" border
                header.subviews.filter { $0.tag == 777 }.forEach { $0.removeFromSuperview() }
                let line = UIView()
                line.tag = 777
                line.backgroundColor = sectionSeparatorColor
                line.translatesAutoresizingMaskIntoConstraints = false
                header.addSubview(line)
                NSLayoutConstraint.activate([
                    line.heightAnchor.constraint(equalToConstant: 1.0 / UIScreen.main.scale),
                    line.leadingAnchor.constraint(equalTo: header.leadingAnchor),
                    line.trailingAnchor.constraint(equalTo: header.trailingAnchor),
                    line.bottomAnchor.constraint(equalTo: header.bottomAnchor)
                ])
        return header
    }
    
    // reorders within a same section/ category persist with `moveItemAt()
    override func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
        guard sourceIndexPath.section == destinationIndexPath.section else {
            collectionView.reloadData()
            return
        }

        let categoryID = categories[sourceIndexPath.section].id
        var tiles = categories[sourceIndexPath.section].tiles
        let movedTile = tiles.remove(at: sourceIndexPath.row)
        tiles.insert(movedTile, at: destinationIndexPath.row)
        categories[sourceIndexPath.section].tiles = tiles

        // Persist the reorder
        onReorder?(tiles, categoryID)
    }
}

extension TileOrganizerVC: UICollectionViewDragDelegate, UICollectionViewDropDelegate {
    func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -> [UIDragItem] {
        dragSourceIndexPath = indexPath
        let tile = categories[indexPath.section].tiles[indexPath.row]
        let itemProvider = NSItemProvider(object: tile.text as NSString)
        let dragItem = UIDragItem(itemProvider: itemProvider)
        dragItem.localObject = tile
        return [dragItem]
    }

    func collectionView(_ collectionView: UICollectionView, canHandle session: UIDropSession) -> Bool {
        session.localDragSession != nil
    }

    func collectionView(_ collectionView: UICollectionView, dropSessionDidUpdate session: UIDropSession, withDestinationIndexPath indexPath: IndexPath?) -> UICollectionViewDropProposal {
        if let from = dragSourceIndexPath, let to = indexPath, from.section == to.section {
            return UICollectionViewDropProposal(operation: .move, intent: .insertAtDestinationIndexPath)
        } else {
            return UICollectionViewDropProposal(operation: .move, intent: .insertIntoDestinationIndexPath)
        }
    }

    func collectionView(_ collectionView: UICollectionView, performDropWith coordinator: UICollectionViewDropCoordinator) {
        guard
            let destinationIndexPath = coordinator.destinationIndexPath,
            let sourceIndexPath = dragSourceIndexPath,
            let item = coordinator.items.first,
            let tile = item.dragItem.localObject as? TileM
        else {
            return
        }
        // Reordering within section
        let fromCategoryID = categories[sourceIndexPath.section].id
        let toCategoryID = categories[destinationIndexPath.section].id

        onMoveTile(tile, fromCategoryID, toCategoryID)
        dragSourceIndexPath = nil
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CategoryHeaderRow.swift ===
//
//  CategoryHeaderRow.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//
//
import SwiftUI

struct CategoryHeaderRow: View {
    @EnvironmentObject var theme: ThemeManager
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    let title: String
    let count: Int
    let isArchive: Bool
    
    /// Only allow edit menu for user categories (not General/Archive).
    var allowEdit: Bool = true
    var onRename: () -> Void
    var onDelete: () -> Void
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        HStack(spacing: 10) {
            Image(systemName: isArchive ? "archivebox.fill" : "")
                .imageScale(.small)
                .foregroundStyle(isArchive ? p.text : p.accent)
            
            T("\(title)", .label)
                .lineLimit(2)
            
            Spacer()
            
            Text("\(count)")
                .font(.callout.monospacedDigit())
                .foregroundStyle(textSecondary)
            
            if allowEdit {
                Menu {
                    Button("Rename", action: onRename).padding()
                    Button("Delete", role: .destructive, action: onDelete)
                } label: {
                    Image(systemName: "ellipsis.circle").foregroundStyle(p.primary)
                        .imageScale(.medium)
                }
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(title), \(count) items")
    }
}
-e \n\n
=== ./intention/Shared/Helpers/AvailabilityTarget+.swift ===
//
//  AvailabilityTarget+.swift
//  intention
//
//  Created by Benjamin Tryon on 8/8/25.
//
import SwiftUI

// iOS 18-only helper so .bounce never appears in a broader-availability symbol
@available(iOS 18.0, *)
private extension View {
    @ViewBuilder
    func bounceSymbolEffect(isActive: Bool) -> some View {
        self.symbolEffect(.bounce, isActive: isActive)
    }
}

extension View {
    @ViewBuilder
    func symbolBounceIfAvailable(active: Bool = true) -> some View {
        if #available(iOS 18.0, *) {
            self.bounceSymbolEffect(isActive: active)               /// uses .bounce only in an iOS18 context
        } else if #available(iOS 17.0, *) {
            /// fallback for iOS 17
            self.symbolEffect(.pulse, isActive: active)
        } else {
            self
        }
    }
    
    //FIXME: -  affect does this have now?
    @ViewBuilder
    func safeAreaTopPadding() -> some View {
        if #available(iOS 17.0, *) {
            self.safeAreaPadding(.top)      /// adjusts with device & bars
        } else {
            self.padding(.top)              /// simple fallback
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/ProgressOverlay.swift ===
//
//  ProgressOverlay.swift
//  intention
//
//  Created by Benjamin Tryon on 9/20/25.
//

/*
 Use anywhere:
 @State private var isBusy = false body: some View {... .progressOverlay($isBusy, text: "Loading..."}
 func someLongAction() { isBusy = true;  Task { defer [ isBusy = false } try? await Task // do work } }
 */
import SwiftUI

struct ProgressOverlay: ViewModifier {
    @Binding var isPresented: Bool
    var text: String = "Loading..."
    
    func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                Color.black.opacity(0.2).ignoresSafeArea()
                VStack(spacing: 10){
                    ProgressView()
                    Text(text).font(.footnote).foregroundStyle(.secondary)
                }
                .padding(16)
                .background(.ultraThinMaterial)
                .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
                .shadow(radius: 3, y: 1)
                .transition(.opacity)
            }
        }
    }
}
extension View {
    func progressOverlay(_ isPresented: Binding<Bool>, text: String = "Loading...") -> some View {
        modifier(ProgressOverlay(isPresented: isPresented, text: text))
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CountBadge+Archive.swift ===
//
//  CountBadge+Archive.swift
//  intention
//
//  Created by Benjamin Tryon on 8/14/25.
//

import SwiftUI

struct CountBadge_Archive: View {
    let fontTheme: AppFontTheme
    let count: Int
    
    var body: some View {
        Text("\(count)")
            .font(fontTheme.toFont(.caption2))
            .padding(.horizontal, 6).padding(.vertical, 3)
            .background(.thinMaterial)
            .clipShape(Capsule())
    }
}
-e \n\n
=== ./intention/Shared/Helpers/HeaderView.swift ===
//
//  HeaderView.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

import UIKit

final class HeaderView: UICollectionReusableView {
    let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        label.translatesAutoresizingMaskIntoConstraints = false
        addSubview(label)
        NSLayoutConstraint.activate([
            label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            label.topAnchor.constraint(equalTo: topAnchor),
            label.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
-e \n\n
=== ./intention/Shared/Helpers/ActionButtonStyle.swift ===
//
//  ActionButtonStyle.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.

import SwiftUI

struct PrimaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    @Environment(\.colorScheme) private var scheme
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .frame(maxWidth: .infinity)
            .foregroundStyle(palette.text)
            .padding(.vertical, 12)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(fillColor(isPressed: configuration.isPressed))
            )
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
    
    private func fillColor(isPressed: Bool) -> Color {
        let base = palette.accent
        if !isEnabled { return base.opacity(0.85) }         // slightly dim
        return isPressed ? base.opacity(0.90) : base
    }
}

struct SecondaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    @Environment(\.colorScheme) private var scheme
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .frame(maxWidth: .infinity)
            .foregroundStyle(palette.surface)
            .padding(.vertical, 12)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(fillColor(isPressed: configuration.isPressed))
            )
            .clipShape( RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
    private func fillColor(isPressed: Bool) -> Color {
        let base = palette.surface.opacity(0.80)
        if !isEnabled { return base.opacity(0.70) }     // slightly dim
        return isPressed ? base.opacity(0.85) : base
    }
}
struct RecalibrationActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    @Environment(\.colorScheme) private var scheme
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .frame(maxWidth: .infinity)
            .foregroundStyle(palette.accent)
            .padding(.vertical, 12)
            .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(fillColor(isPressed: configuration.isPressed))
        )
        .clipShape( RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
    private func fillColor(isPressed: Bool) -> Color {
        let base = palette.accent
        if !isEnabled { return base.opacity(0.85) }         // slightly dim
        return isPressed ? base.opacity(0.90) : base
    }
}

extension View {
    func primaryActionStyle(screen: ScreenName) -> some View {          modifier(_PrimaryActionStyleMod(screen: screen)) }
    func secondaryActionStyle(screen: ScreenName) -> some View {        modifier(_SecondaryActionStyleMod(screen: screen)) }
    func recalibrationActionStyle(screen: ScreenName) -> some View {    modifier(_RecalibrationActionStyleMod(screen: screen)) }
}

// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct _PrimaryActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(PrimaryActionStyle(palette: p))
    }
}
// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct _SecondaryActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(SecondaryActionStyle(palette: p))
    }
}

private struct _RecalibrationActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(RecalibrationActionStyle(palette: p))
    }
}

/// Helper to apply ButtonStyle inside a View modifier chain
private struct _ButtonStyleWrapper<S: ButtonStyle>: ViewModifier {
    let style: S
    func body(content: Content) -> some View { content.buttonStyle(style) }
}
-e \n\n
=== ./intention/Shared/Helpers/DynamicCountdown.swift ===
//
//  DynamicCountdown.swift
//  intention
//
//  Created by Benjamin Tryon on 8/13/25.
//

import SwiftUI

struct DynamicCountdown: View {
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var fVM: FocusSessionVM
    let palette: ScreenStylePalette
    
    /// Current progress sizes (0.0 to 1.0), passed from FocusSessionActiveV
    let progress: CGFloat
    private let activeSize: CGFloat = 220
    private let compactSize: CGFloat = 60
    let digitSize: CGFloat = 56
    
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: .focus) }
    }
    
    private var isActive: Bool {
        fVM.phase == .running ||
        fVM.phase == .paused  ||
        (fVM.phase == .finished && fVM.currentSessionChunk == 2)
    }
    
    private var isBetweenChunks: Bool {
        let oneDone = fVM.phase == .finished && fVM.currentSessionChunk == 1
        return oneDone
    }
    
    private var isBothChunksDone : Bool {
        let oneDone = fVM.phase == .finished && fVM.currentSessionChunk == 1
        let twoDone = fVM.phase == .finished && fVM.currentSessionChunk == 2
        return oneDone && twoDone
    }
    
    private func handleTap() {
        if fVM.phase == .running {
            fVM.performAsyncAction { await fVM.pauseCurrent20MinCountdown() }
        } else if fVM.phase == .paused {
            fVM.performAsyncAction { try await fVM.resumeCurrent20MinCountdown() }
        }
    }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        if isActive {
            ZStack {
                // Background circle
                Circle()
                    .fill(palette.background.opacity( 0.2))     // Use opacity(0.2) or Color.clear here, the dimmed effect is applied below
                
                // Pause overlay -- appears last, on top of everything
                if fVM.phase == .paused {
                    // PAUSED STATE
                    ZStack {
                        // The translucent opaque background for the pause state
                        Circle().fill(Color.black.opacity(0.35))     // Uses black for a better opaque look
                        
                        VStack(spacing: 8) {
                            Image(systemName: "pause.circle.fill")
                                .resizable()
                                .frame(width: 40, height: 40)
                                .foregroundStyle(palette.accent)
                                .shadow(radius: 2)
                            
                            T("Paused", .title3)
                                .foregroundStyle(palette.text)
                                .fontWeight(.bold)
                        }
                    }
                    .clipShape(Circle())                        // Clips ZStack to the circle area so it doesn't cover surrounding content
                    .transition(.opacity)
                } else {
                    // RUNNING/ACTIVE STATE
                    // Pie slicing
                    UnwindingPieShape(progress: progress)
                        .fill(palette.accent)
                    //                    .fill(palette.primary.opacity(fVM.phase == .paused ? 0.4 : 1.0))
                    
                    // Time text in the center - always present, but lower Z-index than the pause overlay
                    VStack(spacing: 4) {
                        let digits = T("\(fVM.formattedTime)", .largeTitle)
                            .font(.system(size: digitSize, weight: .bold, design: .monospaced))
                        
                        // Main fill color
                        digits
                        foregroundStyle(palette.text) // dark gray over light areas
                        // Soft outline intText(F5F5F5)
                            .overlay(
                                ZStack {
                                    digits.foregroundStyle(Color.intText).offset(x:  0.75, y:  0.75)
                                    digits.foregroundStyle(Color.intText).offset(x: -0.75, y:  0.75)
                                    digits.foregroundStyle(Color.intText).offset(x:  0.75, y: -0.75)
                                    digits.foregroundStyle(Color.intText).offset(x: -0.75, y: -0.75)
                                }
                            )
                        // Drop shadow for depth
                            .shadow(color: .black.opacity(0.20), radius: 2, x: 0, y: 1)
                    }
                    //                .opacity(fVM.phase == .paused ? 0.2 : 1.0)      // Modifier to dim the time text when paused
                    
                    // add a subtle transition
                }
            }
            .frame(width: activeSize, height: activeSize)
            .contentShape(Circle())                             // tap target matches the circle
            .onTapGesture { handleTap() }                       // Keep as-is: the tap target persists across both `paused` and `running`, applies to entire ZStack, which is what is wanted
            .accessibilityAddTraits(.isButton)
            .accessibilityLabel(fVM.phase == .paused ? "Resume" : "Pause")
            .accessibilityHint("Tap to \(fVM.phase == .paused ? "resume" : "pause") the countdown")
            .animation(.easeInOut(duration: 0.2), value: progress)
            
        } else if isBetweenChunks {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(palette.background.opacity(0.1))
                //                Text("‚úì").font(.largeTitle).foregroundStyle(palette.primary)
                
            }
            .frame(width: compactSize, height: compactSize)
            .transition(.opacity)
            .animation(.easeInOut(duration: 0.2), value: isBetweenChunks)
        } else if isBothChunksDone {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(palette.background.opacity(0.1))
                //                Text("‚úì").font(.largeTitle).foregroundStyle(palette.primary)
            }
            .frame(width: compactSize, height: compactSize)
            .transition(.opacity)
            .animation(.easeInOut(duration: 0.2), value: isBothChunksDone)
        } else {
            EmptyView()             /// Releases vertical space
        }
    }
}
//
//    var body: some View {
//
//
//        Group {
//            if shouldShowFullTimer {
//                ZStack {
//                    Circle()
//                        .fill(palette.background.opacity(0.2))
//                        .frame(width: 200, height: 200)
//
//                    UnwindingPieShape(progress: progress)
//                        .fill(palette.primary)
//
//                    Text("\(viewModel.formattedTime)")
//                        .font(.system(size: 48, weight: .bold, design: .monospaced))
//                        .id("countdownTimer")
//                        .transition(.opacity)
//                        .foregroundStyle(palette.text)
//                }
//                .animation(.easeInOut(duration: 0.2), value: progress)
//            } else if shouldShowCompactCheckmark {
//                ZStack {
//                    Circle()
//                        .fill(palette.background.opacity(0.1))
//                        .frame(width: 60, height: 60)
//
//                    Text("‚úì")
//                        .font(.title)
//                        .foregroundStyle(palette.primary)
//                }
//                .transition(.opacity)
//                .animation(.easeInOut(duration: 0.2), value: progress)
//            }
//        }
//    }
//    private var shouldShowFullTimer: Bool {
//        viewModel.phase == .running ||
//        (viewModel.phase == .finished && viewModel.currentSessionChunk == 2)
//    }
//
//    private var shouldShowCompactCheckmark: Bool {
//        viewModel.phase == .finished && viewModel.currentSessionChunk == 1
//    }
// }
-e \n\n
=== ./intention/Shared/Helpers/Text+StatStyles.swift ===
//
//  Text+StatStyles.swift
//  intention
//
//  Created by Benjamin Tryon on 10/3/25.
//

import SwiftUI

struct StatNumberStyle: ViewModifier {
    let p: ScreenStylePalette
    
    func body(content: Content) -> some View {
        content
            .bold()
            .monospacedDigit()
            .lineLimit(1)                           // never wrap
            .minimumScaleFactor(0.6)                // shrink, instead
            .allowsTightening(true)
            .foregroundStyle(p.text)
            .layoutPriority(2)
    }
}
struct StatCaptionStyle: ViewModifier {
    //    let p: ScreenStylePalette
    
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    
    func body(content: Content) -> some View {
        content
            .lineLimit(1)                           // never wrap
            .minimumScaleFactor(0.6)                // shrink, instead
            .allowsTightening(true)
            .foregroundStyle(textSecondary)
            .layoutPriority(1)
    }
}
extension View {
    func statNumberStyle(_ p: ScreenStylePalette) -> some View { modifier(StatNumberStyle(p:p)) }
    //    func statCaptionStyle(_ p: ScreenStylePalette) -> some View { modifier(StatCaptionStyle(p:p)) }
    func statCaptionStyle(_ p: ScreenStylePalette) -> some View { modifier(StatCaptionStyle()) }
}
-e \n\n
=== ./intention/Shared/Helpers/CategorySection.swift ===
////
////  CategorySection.swift
////  intention
////
////  Created by Benjamin Tryon on 7/21/25.
////
//
//import SwiftUI
//
//struct CategorySection: View {
//    @Binding var categoryItem: CategoriesModel
//    let palette: ScreenStylePalette
//    let fontTheme: AppFontTheme
//    let saveHistory: () -> Void
//    let isArchive: Bool
//    var autoFocus: Bool = false
//    @Binding var newTextTiles: [UUID: String]
//    @State private var collapsed: Set<UUID> = []
//
//    var body: some View {
//        VStack(alignment: .leading, spacing: 8) {
//            CategoryHeaderRow(
//                categoryItem: $categoryItem,
//                palette: palette,
//                fontTheme: fontTheme,
//                newTextTiles: $newTextTiles,
//                saveHistory: saveHistory,
//                isArchive: isArchive,
//                autoFocus: autoFocus
//            )
//            
//            if !collapsed.contains(categoryItem.id) {
//                CategoryTileList(
//                    category: $categoryItem,
//                    palette: palette,
//                    fontTheme: fontTheme,
//                    saveHistory: saveHistory,
//                    isArchive: isArchive
//                )
//            }
//        }
//        .padding(.horizontal)
//        .padding(.bottom, 12)
//    }
//}
-e \n\n
=== ./intention/Shared/Helpers/GlowingTextModifier.swift ===
//
//  GlowingTextModifier.swift
//  intention
//
//  Created by Benjamin Tryon on 8/26/25.
//
import SwiftUI

struct PulsingBorderModifier: ViewModifier {
    @State private var pulse: Bool = false
    let isSelected: Bool                    // Uses a binding to determine if the button is active
    
    func body(content: Content) -> some View {
        content
            .padding()
            .background(Capsule().fill(Color.purple)) // The main fill remains purple
            .overlay(
                Capsule()
                    .stroke(
                        isSelected ? Color.clear : (pulse ? Color.purple.opacity(0.8) : Color.purple.opacity(0.4)), /// Pulsing effect for inactive
                        lineWidth: isSelected ? 0 : (pulse ? 4 : 2)     /// Pulse
                    )
                    .shadow(
                        color: isSelected ? Color.clear : (pulse ? Color.purple.opacity(0.7) : Color.purple.opacity(0.2)),
                        radius: isSelected ? 0 : (pulse ? 10 : 5),
                        x: 0, y: 0
                    )
            )
            .animation(
                isSelected ? .none : .easeInOut(duration: 1.5).repeatForever(autoreverses: true),
                value: pulse
            )
            .onAppear {
                if !isSelected {
                    pulse = true
                }
            }
            .onChange(of: isSelected) { newValue in
                if !newValue {
                    pulse = true
                } else {
                    pulse = false
                }
            }
    }
}

extension View {
    func notActivePulsingEffect(isSelected: Bool) -> some View {
        self.modifier(PulsingBorderModifier(isSelected: isSelected))
    }
}
-e \n\n
=== ./intention/Shared/Helpers/DynamicMessageAndActionArea.swift ===
//
//  DynamicMessageAndActionArea.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

struct DynamicMessageAndActionArea: View {
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var focusVM: FocusSessionVM
//    let fontTheme: AppFontTheme       // Pass directly, is an AppStorage value
//    let palette: ScreenStylePalette   // Pass directly, is an AppStorage value
    let onRecalibrateNow: () -> Void    // Define sheet closure property, from parent (FocusSessionActiveV) to trigger logic
    
    private let screen: ScreenName = .focus
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
//    init(focusVM: FocusSessionVM,
//         onRecalibrateNow: @escaping () -> Void) {
//        self._focusVM = ObservedObject(initialValue: focusVM)
//        self.onRecalibrateNow = onRecalibrateNow
//    }
            var body: some View {
                VStack(spacing: 16) {
                    if focusVM.showRecalibrate {
                        T("""
                        Session complete!
                        Time to Rest and Recalibrate Your Mind.
                        """, .title3)
                            .foregroundStyle(p.text)
                            .multilineTextAlignment(.center)

                        VStack(spacing: 10) {
                            /// Allow wrapping, or text overflowing doesn't function correctly as a VStack ,not HStack
                            Button { onRecalibrateNow() } label: { T("Recalibrate Now", .action) }
                                .primaryActionStyle(screen: screen)

                            Button { focusVM.performAsyncAction { try await focusVM.beginOverallSession() } }
                            label: { T("Start", .action) }
                                .primaryActionStyle(screen: screen)
                                .primaryActionStyle(screen: screen)

                            Button(role: .destructive) {
                                focusVM.performAsyncAction { await focusVM.resetSessionStateForNewStart() }
                            } label: { T("End Early", .action) }
                        }
                    } else if focusVM.currentSessionChunk == 1 && focusVM.phase == .finished {
                        T("Done, Continue Your Streak to the Next One?", .title3)
                            .foregroundStyle(p.text)
                            .multilineTextAlignment(.center)

                        Button { focusVM.performAsyncAction { try await focusVM.beginOverallSession() } }
                        label: { T("Start Next", .action) }
                            .primaryActionStyle(screen: screen)

                        Button(role: .destructive) {
                            focusVM.performAsyncAction { await focusVM.resetSessionStateForNewStart() }
                        } label: { T("End Early", .action) }
//                    } else if focusVM.phase == .running {
//                        T("Session in progress‚Ä¶", .body)
//                            .foregroundStyle(p.textSecondary)
//                            .multilineTextAlignment(.center)
                    } else if focusVM.tiles.count < 2, focusVM.phase == .running {
//                        T("", .body)
//                            .foregroundStyle(p.textSecondary)
//                            .multilineTextAlignment(.center)
                    } else if focusVM.phase == .idle {
//                        T("To Activate Focus, Press the Button Below", .caption)
//                            .foregroundStyle(p.textSecondary)
//                            .multilineTextAlignment(.center)
                    } else if focusVM.phase == .paused {
                        // no text needed - handled in DynamicCountdown()
                    }
                }
                .padding(.vertical, 8)
            }
        }
-e \n\n
=== ./intention/Shared/Helpers/Helper_AppIconV.swift ===
//
//  Helper_AppIconV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

// MARK: - AppIconView
struct Helper_AppIconV: View {
    @State var isBusy = false
    var body: some View {
        // safely unwraps uiimage from bundle extension
        if let uiImage = AppIconProvider.icon {
            // Good: have a non-optional UIImage to create a SwiftUI Image
            Image(uiImage: uiImage)
                .resizable()
                .aspectRatio(contentMode: .fit) // maintain aspect ratio
        } else {
            Image(systemName: "app.fill")   // Generic app icon SF Symbol
                .resizable()
                .aspectRatio(contentMode: .fit)
                .foregroundStyle(.intGreen)
                .progressOverlay($isBusy, text: "Loading...")
        }
    }
}

#if DEBUG
#Preview {
    Helper_AppIconV()
        .frame(width: 50, height: 50)
        .padding()
}
#endif
-e \n\n
=== ./intention/Shared/Helpers/AppEnvironment.swift ===
//
//  AppEnvironment.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

struct AppEnvironment {
    static let isAppStoreReviewing: Bool = {
        #if DEBUG
        return false
        #else
        return true
        #endif
    }()
}
-e \n\n
=== ./intention/Shared/Services/MembershipCodeService.swift ===
//
//  MembershipCodeService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

// Apple Pay: users expect no codes. Just the StoreKit sheet ‚Üí done.
// Stripe/web: a simple redeem code screen is the most anonymous and familiar approach without accounts.
//Redeem Code Screen:
//
//They pay, see a short code (6‚Äì10 chars).
//
//In the app, they go to ‚ÄúEnter Code‚Äù, type/paste it.
//
//App unlocks.
//
//--Familiar from gift cards and beta programs.
//
//-- No email or account but still feels anonymous but valid.

actor MembershipCodeService {
    
    enum VerificationResult {
        case success
        case invalid
        case networkError
    }
    
    // Replace with backend URL
    private let verifyEndpoint = URL(string: "https://argonnesoftware.com/api/verify")!
    
    func verify(code: String, deviceID: String) async -> VerificationResult {
        // FIXME: Placeholder - similate network verification
        try? await Task.sleep(nanoseconds: 500_000_000)       // 0.5s delay

        // FIXME: In production: POST code to backend and check response
        if code.uppercased() == "INTENTION-BETA" {
            UserDefaults.standard.set(true, forKey: "isMember")
            return .success
        } else {
            return .invalid
        }
    }
}
-e \n\n
=== ./intention/Shared/Services/PersistenceActor.swift ===
//
//  PersistenceActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import Foundation

// All I/O (encoding/decoding) logic here

/// Testing seam
public protocol Persistence: Sendable {
    func write<T: Codable & Sendable>(_ object: T, to key: String) async throws
    func readIfExists<T: Codable & Sendable>(_ type: T.Type, from key: String) async throws -> T?
    func clear(_ key: String) async
}

/// All business logic (when to save, what to save) belongs in the VM
/// VM decides when to persist; PersistenceActor decides how (encode/decode, storage)
///     PersistenceActor continues to store the **categories list**
public actor PersistenceActor {
    public enum PersistenceActorError: Error {
        case encodingFailed(Error)
        case decodingFailed(Error)
    }
    
    // Isolated - no need for .detach elsewhere
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    
    public init() {}
}

/// Actor conforms
extension PersistenceActor: Persistence {
    
    // MARK: Generic write; crossing int othis actor requires `await` from outside
    /// Encode and Save any Codable object and write it (to UserDefaults)
    public func write<T: Codable>(_ object: T, to key: String) async throws {
        do {
            let data = try encoder.encode(object)   // object is `categories` here
            UserDefaults.standard.set(data, forKey: key)
        } catch {
            debugPrint("[PersistenceActor.saveHistory] failed to encode and save:", error)
            throw PersistenceActorError.encodingFailed(error)
        }
    }
    
    // MARK: Load a Codable object from UserDefaults
    public func readIfExists<T: Codable>(_ type: T.Type, from key: String) async throws -> T? {
        guard let data = UserDefaults.standard.data(forKey: key) else { return nil }
        do {
            return try decoder.decode(T.self, from: data)
        } catch {
            debugPrint("[PersistenceActor.loadHistory] deocding failed: ", error)
            throw PersistenceActorError.decodingFailed(error)
        }
    }
    
    // MARK: Clear stored value at a key (from UserDefaults)
    public func clear(_ key: String) async {
        UserDefaults.standard.removeObject(forKey: key) // keeps in-memory state (like categories), is seralized and background-safe
    }
}
-e \n\n
=== ./intention/Shared/Services/PaymentService.swift ===
//
//  PaymentService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/3/25.
//

import StoreKit

// Service = "how". Actor is concurrency-safe and long-term correct.
// Owns StoreKit logic of products, entitlement refresh, refunds/cancellations
/// Apple processes payment; app never sees card info; Only reads entitlements (transactions) and set isMember; keeping app "anonymous" (device-scoped)
public struct PaymentState: Sendable, Equatable {
    public var isMember: Bool
    public var products: [Product]
}

public actor PaymentService {
    private let productIDs: [String]
    private var productsCache: [Product] = []
    private var isMemberCache: Bool = false
    
    // Async plumbing
    private var continuations: [UUID: AsyncStream<PaymentState>.Continuation] = [:]
    private var updatesTask: Task<Void, Never>?
    
    public init(productIDs: [String]) {
        self.productIDs = productIDs
    }
    
    // RootView calls this once, at launch
    public func configure() async {
        await refreshProducts()
        await refreshEntitlementStatus()
        // Start listening for transaction updates
        updatesTask?.cancel()
        updatesTask = listenForTransactions()
    }
    
    deinit { updatesTask?.cancel() }
    
    //
    //    public func updates() -> AsyncStream<PaymentState> {
    //        AsyncStream { cont in
    //            continuations.append(cont)
    //            // Immediately emit current snapshot
    //            cont.yield(.init(isMember: isMemberCache, products: productsCache))
    //            cont.onTermination = { [weak self] _ in
    //                guard let self else { return }
    //                self.continuations.removeAll { $0 === cont }
    //            }
    //        }
    //    }
    
    public func updates() -> AsyncStream<PaymentState> {
        AsyncStream { cont in
            let id = UUID()
            continuations[id] = cont
            // Immediately emit current snapshot
            cont.yield(.init(isMember: isMemberCache, products: productsCache))
            cont.onTermination = { [weak self] _ in
                Task { await self?.removeContinuation(id) }
            }
        }
    }
    
    // MARK: Queries
    public func products() -> [Product] { productsCache }
    public func isMember() -> Bool { isMemberCache }
    
    // MARK: Entitlement hydration
    // ‚û≥ this is where membership flips as verified
    public func refreshEntitlementStatus() async {
        var active = false
        for await entitlement in Transaction.currentEntitlements {
            guard case .verified(let t) = entitlement else { continue }
            if t.productID == productIDs.first, t.revocationDate == nil {
                active = true
            }
        }
        isMemberCache = active
        notify()
    }
    
    // MARK: Products
    public func refreshProducts() async {
        do {
            let prods = try await Product.products(for: productIDs)
            productsCache = prods.sorted(by: { $0.price < $1.price })
            notify()
        } catch {
            // leave cache as-is
        }
    }
    
    // MARK: Purchase/Restore
    // Does NOT set isMember diretly (good)
    @discardableResult
    public func purchaseMembership() async throws -> Bool {
        let product: Product
        if let first = productsCache.first {
            product = first
        } else {
            await refreshProducts()
            guard let loaded = productsCache.first else { throw StoreKitError.unknown }
            product = loaded
        }
        
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            switch verification {
            case .verified(let transaction):
                await transaction.finish()
                await refreshEntitlementStatus()        // ‚úÖ flip driven by entitlement re-read
                return true
            case .unverified:
                return false
            }
        case .userCancelled, .pending:
            return false
        @unknown default:
            return false
        }
    }
    
    public func restorePurchases() async throws {
        try await AppStore.sync()
        await refreshEntitlementStatus()             // ‚úÖ flip driven by entitlement re-read
    }
    
    
    // MARK: Dependencies
    private func listenForTransactions() -> Task<Void, Never> {
        // Capture while on the actor
        let targetID = self.productIDs.first
        
        return Task { [weak self] in
            guard let self else { return }
            for await result in Transaction.updates {
                do {
                    // Pure helper, no actor state involved
                    let transaction = try checkVerified(result)
                    
                    if transaction.productID == targetID {
                        await self.refreshEntitlementStatus()       // ‚úÖ flip driven by entitlement re-read
                    }
                    await transaction.finish()
                } catch {
                    // ignore unverified
                }
            }
        }
    }
    
    private nonisolated func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let value): return value
        case .unverified(_, let err): throw err
        }
    }
    
    private func notify() {
        let snapshot = PaymentState(isMember: isMemberCache, products: productsCache)
        for cont in continuations.values { cont.yield(snapshot) }
    }
    
    private func removeContinuation(_ id: UUID) {
        continuations.removeValue(forKey: id)
    }
    
    
    
    private let membershipProductID = "com.argonnesoftware.intention"
    //
    //    init() {
    //        /// Start updates (refunds/cancellation)  listener and hydrate state
    //        updatesTask = listenForTransactions()
    //        Task { await loadProducts(); await refreshEntitlementStatus() }
    //    }
    

}
-e \n\n
=== ./intention/Shared/Services/AppIconProvider.swift ===
//
//  AppIconProvider.swift
//  intention
//
//  Created by Benjamin Tryon on 6/10/25.
//

import UIKit

struct AppIconProvider {
    // Returns runtime display of icon
    static var icon: UIImage? {
        UIImage(named: "RuntimeAppIcon") // From AppDisplayIcon.imageset
    }
}
-e \n\n
=== ./intention/Shared/HelperLayout/Layout+Helpers.swift ===
//
//  Layout+Helpers.swift
//  intention
//
//  Created by Benjamin Tryon on 8/27/25.
//

import SwiftUI
/// Only the Page applies horizontal padding. Children don‚Äôt.
/// Add to any top-level screen container (ScrollView or VStack)
struct Page<Content: View>: View {
    let top: CGFloat
    let alignment: HorizontalAlignment
    let content: () -> Content
    init(top: CGFloat = 8,
         alignment: HorizontalAlignment = .leading,
         @ViewBuilder _ content: @escaping () -> Content) {
        self.top = top; self.alignment = alignment; self.content = content
    }
    var body: some View {
        /// One horizontal margin to rule them all
        VStack(alignment: alignment, spacing: 16, content: content)
            .padding(.horizontal, 16)
            .padding(.top, 8)                       /// Small top; adjust per screen
            .frame(maxWidth: .infinity, alignment: .leading)
    }
}

/// Card section with consistent look for Settings, History blocks
struct Card<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        VStack(alignment: .leading, spacing: 16, content: content)
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

/// Bottom toast that clears tab bar safely on all devices
struct BottomToast<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        content()
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
            .shadow(radius: 2, y: 1)
    }
}

struct TileCell: View {
    let tile: TileM
    
    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(tile.text).font(.callout)
        }
        .padding(12)
//        .background(RoundedRectangle(cornerRadius: 12).fill(.ultraThinMaterial))
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationCaption.swift ===
//
//  ValidationCaption.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct ValidationCaption: View {
    let state: ValidationState

    // --- Local Color Definitions for Validations ---
    private let colorDanger = Color.red

    var body: some View {
        if case .invalid (let msgs) = state {
            HStack(spacing: 6) {
                Image(systemName: "exclamationmark.triangle.fill")
                Text(msgs.joined(separator: " "))
            }
            .font(.footnote)
            .foregroundStyle(colorDanger)
            .accessibilityLabel("Validation error")
            .accessibilityHint(msgs.joined(separator: " "))
            .transition(.opacity.combined(with: .move(edge: .top)))     //TODO: Test this Aim for a 0.2-second transition
        }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationResults+Fuzzy.swift ===
//
//  ValidationResults+Fuzzy.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.
//

import Foundation
//
// MARK: - non-fragile assertions and Generic Result Validations
//count matches the message and gate display via a flag
extension String {
    // FIXME: THIS SHOULD RENDER THE HELPERS NIL-SAFE (that is, prevents trying to append `String?` into `[String]`
    var isEmptyValidationMessage: String? {
        isEmpty ? "The field cannot be empty or just spaces." : nil
    }

    var taskValidationMessages: [String] {
        var messages: [String] = []
        let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.count > 200 { messages.append("200 character limit.") }
        if trimmed.isEmpty, let m = isEmptyValidationMessage { messages.append(m) }
        return messages
    }

        // NOTE: if ever necessary, uncomment... below are known "bad actor" threat patterns
//        let consecutiveCharacterPattern = "(&{3,}|={3,}|<{3,}|>{3,}|\\+{3,}|,{3,}|\\.{4,})"
//        let consecutiveCharacterRegex = try! NSRegularExpression(pattern: consecutiveCharacterPattern)
//        if consecutiveCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Avoid long runs of special symbols.")
//        }
//
//        let invalidCharacterPattern = "[^A-Za-z0-9 .,!?'-@#$%^&*()_+=/\\`~{}\\[\\]|:;\"\\\\]"
//        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
//        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Contains unsupported characters.")
//        }
//        
//        return messages
//    }
    
    var categoryTitleMessages: [String] {
        var messages: [String] = []
        let trimmedTitle = trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedTitle.count > 15 { messages.append("15 character limit.") }
        if trimmedTitle.isEmpty, let m = isEmptyValidationMessage { messages.append(m) }
        return messages
    }
}

        // NOTE: if ever necessary, uncomment... below are known "bad actor" threat patterns
//        let consecutiveCharacterPattern = "([.,?!'#@&-]){3,}"
//        if trimmedTitle.range(of: consecutiveCharacterPattern, options: .regularExpression) != nil {
//            messages.append("Avoid 3 or more consecutive symbols.")
//        }
//
//        let invalidCharacterPattern = "(?i)[^a-z0-9 .,?!#'@()&]"
//        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
//        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Title contains unsupported characters.")
//        }
//
//        return messages
//    }
//}
-e \n\n
=== ./intention/Shared/Validation/ValidationState.swift ===
//
//  ValidationState.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import Foundation
/// decide when to surface errors in the view (on submit / CTA) instead of by default while the field is empty
enum ValidationState: Equatable {
    case none
    case valid
    case invalid(messages: [String])

    var isInvalid: Bool {
        if case .invalid = self { return true } else { return false }
    }
    var message: String? {
        if case .invalid(let msgs) = self { return msgs.joined(separator: " ") } else { return nil }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidatingField.swift ===
//
//  ValidatingField.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

/// Text always charcoal; change border color when invalid:
///         Visual treatment for validated fields using your ScreenStylePalette tokens
struct ValidatingField: ViewModifier {
    let state: ValidationState
    let p: ScreenStylePalette
    
    // --- Local Color Definitions ---
    let textSecondary = Color(red: 0.286, green: 0.290, blue: 0.290)
    let colorDanger = Color.red
    let colorBorder = Color(red: 0.286, green: 0.290, blue: 0.290).opacity(0.4) // or use neutralBorderColor: Color
    
    func body(content: Content) -> some View {
        content
            .textFieldStyle(.plain)                                 // no background/box
            .foregroundStyle(textSecondary)                   // Always charcoal text
            .tint(p.text)                                     // selection = charcoal
            .padding(12)
            .background(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                // transparent fill, allow parent view background to show throw
                    .fill(Color.clear)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                // Set stroke color based on validation state
                    .stroke(state.isInvalid ? colorDanger : colorBorder, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
    }
}

extension View {
    func validatingField(
        state: ValidationState,
        palette: ScreenStylePalette
    ) -> some View {
        modifier(
            ValidatingField(state: state, p: palette)
        )
    }
}
-e \n\n
=== ./intention/Shared/Debug/debugModifier.swift ===
//
//  debugModifier.swift
//  intention
//
//  Created by Benjamin Tryon on 6/13/25.
//
import SwiftUI

extension View {
    @ViewBuilder
    func debugModifier<T: View>(_ modifier: (Self) -> T) -> some View {
        #if DEBUG
        modifier(self)
        #else
        self
        #endif
    }
    
    //  append a call at the end of view { }.here declaration, just like any other modifier
    //      only actually prints a value within debug builds if used as `.debugPrint()`
    @discardableResult
        func debugAction(_ closure: () -> Void) -> Self {
        #if DEBUG
        closure()
        #endif
            return self
        }

    /*
     example:
     extension View {
         func debugPrint(_ value: Any) -> Self {
             debugAction { print(value) }
         }
     }

     struct EventView: View {
         @ObservedObject var viewModel: EventViewModel

         var body: some View {
             VStack {
                 ...
             }
             .debugPrint(viewModel.bannerImage.size)
         }
     }
     */

    // Convenience wrappers
    func debugBorder(_ on: Bool = true) -> some View {
        overlay(on ? Rectangle().strokeBorder(.red, lineWidth: 1) : nil )
    }
    
    func debugBackground(_ color: Color = .red) -> some View {
        debugModifier { $0.background(color) }
    }
}

/*
 
 Text(viewModel.formattedDate)
                .debugBackground(.green)
 or
 
 VStack {
        // code
    }
    .debugBorder()
 */
-e \n\n
=== ./intention/Shared/Debug/DebugKeys.swift ===
//
//  DebugKeys.swift
//  intention
//
//  Created by Benjamin Tryon on 9/12/25.
//

import SwiftUI

struct DebugKeys {
    static let forceLegalNextLaunch = "debug.forceLegalNextLaunch"
}

/// Call once at app startup (e.g., in App/RootView.onAppear)
func bootstrapLegalGate() {
    // Test plan env var still works if you keep using it
    if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
        LegalConsent.clearForDebug()
    }
    if UserDefaults.standard.bool(forKey: DebugKeys.forceLegalNextLaunch) {
        LegalConsent.clearForDebug()
        UserDefaults.standard.set(false, forKey: DebugKeys.forceLegalNextLaunch)
    }
}
-e \n\n
=== ./intention/Models/ActivityAndDataIdentifier.swift ===
//
//  ActivityAndDataIdentifier.swift
//  intention
//
//  Created by Benjamin Tryon on 7/8/25.
//

import Foundation

//  Generate UUID on first launch
//      - user identified anonymously but trackable
//  Store (locally) UUID for persistence
//  Use to track history and sessions, no User input needed
func getUserIdentifier() -> String {
    if let storedUUID = UserDefaults.standard.string(forKey: "userUUID") {
        return storedUUID
    } else {
        let newUUID = UUID().uuidString
        UserDefaults.standard.set(newUUID, forKey: "userUUID")
        return newUUID
    }
}
-e \n\n
=== ./intention/Models/TileM.swift ===
//
//  TileM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import Foundation

// DragPayload: Transferable handles drag and drop
struct TileM: Identifiable, Sendable, Codable, Hashable {
    let id: UUID
    var text: String
//    var timeStamp: Date
    
    init(id: UUID = UUID(), text: String) {
//        self.id = UUID()
        self.id = id
        self.text = text
//        self.timeStamp = Date()
    }
}
-e \n\n
=== ./intention/Models/CategoriesModel.swift ===
//
//  Categories.swift
//  intention
//
//  Created by Benjamin Tryon on 7/12/25.
//

import Foundation
import SwiftUI

// MARK: - Inject a known, stable ID
// DragPayload: Transferable handles drag and drop
struct CategoriesModel: Identifiable, Codable, Hashable {
    let id: UUID
    var persistedInput: String
    var tiles: [TileM]
    
    init(id: UUID = UUID(), persistedInput: String, tiles: [TileM] = []) {
        self.id = id
        self.persistedInput = persistedInput
        self.tiles = tiles
    }
}
-e \n\n
=== ./intention/Models/ActiveSessionSnapshot.swift ===
//
//  ActiveSessionSnapshot.swift
//  intention
//
//  Created by Benjamin Tryon on 9/18/25.
//

import SwiftUI

/// Preserve session state (so tiles/timer don‚Äôt vanish on relaunch)
struct ActiveSessionSnapshot: Codable, Sendable {
    let tileTexts: [String]
    let phase: FocusSessionVM.Phase
    let chunkIndex: Int
    let deadline: Date       // <- single source of truth
}
-e \n\n
=== ./HistoryV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/27/25.
//


import SwiftUI

/// content-management screen with an explicit Edit/Done mode
struct HistoryV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var viewModel: HistoryVM
    @Environment(\.editMode) private var editMode
    
    // UI State
    //    @State private var newTextTiles: [UUID: String] = [:]       /// Store new tile text per category using its `id` as key
    @State private var isOrganizing = false
    @State private var showOrganizerOverlay = false
    @State private var showErrorOverlay = false
    @State private var createdCategoryID: UUID?
    @State private var targetCategoryID: UUID?
    @State private var showRenamePicker = false
    @State private var showDeletePicker = false
    @State private var showRenameSheet = false
    @State private var renameText = ""
    @State private var showDeleteConfirm = false
    @State private var isBusy = false
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ScrollView {
            Page(top: 6, alignment: .center) {
                
                LazyVStack(alignment: .leading, spacing: 8) {
                    // $Bindings are so rows can edit categories
                    ForEach($viewModel.categories) { $category in
                        CategoryCard(
                            category: $category,
                            isArchive: category.id == viewModel.archiveCategoryID,
                            onRename: { id in
                                targetCategoryID = id
                                renameText = viewModel.name(for: id)
                                showRenameSheet = true
                            },
                            onDelete: { id in
                                targetCategoryID = id
                                showDeleteConfirm = true
                            }
                        )
                        .id(category.id)
                        //                        .padding(.vertical, 12)
                        //                        .padding(.horizontal, 16)
                        //                        .environmentObject(theme)
                        // -- category separator --
                        Rectangle()
                            .fill(colorBorder)
                            .frame(height: 1)
                            .padding(.vertical, 4)
                    }
                }
                //                Divider().overlay(Color.intTan)
                //                .padding(.vertical, 12)
            }
            // Toasts
            VStack(spacing: 8) {
                if let move = viewModel.lastUndoableMove {
                    HStack {
                        //                        Text("\(move.tile.text) moved").font(.footnote)
                        //                        Spacer()
                        Button {viewModel.undoLastMove()} label: { T("Undo?", .action) }.primaryActionStyle(screen: screen)
                    }
                    .padding(.horizontal, 12)           // Card instead?
                    .padding(.vertical, 10)             // Card instead?
                    .background(.ultraThinMaterial, in: Capsule())
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
                
                if viewModel.tileLimitWarning {
                    T("Archive capped at 200; oldest items were removed.", .caption)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 10)
                        .background(.ultraThinMaterial, in: Capsule())
                        .task {
                            try? await Task.sleep(nanoseconds: 2_000_000_000)
                            await MainActor.run { viewModel.tileLimitWarning = false }
                        }
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
        }
        .background(p.background)
        .tint(p.accent)
        .animation(.easeInOut(duration: 0.2), value: viewModel.lastUndoableMove != nil)
        .toolbar { historyToolbar }.environmentObject(theme)
        /// [.medium] is half-screen, .visible affordance
        .sheet(isPresented: $showRenameSheet) {
            renameSheet
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
        .alert("Delete category?", isPresented: $showDeleteConfirm) {
            Button("Delete", role: .destructive) {
                if let id = targetCategoryID {
                    Task { _ = viewModel.deleteCategory(id: id) }
                }
            }
            Button("Cancel", role: .cancel) { }
        } message: { Text("Tiles will be moved to Archive.") }
        
//        // Organizer overlay (your fullScreenCover is driven by isOrganizing)
//            .onReceive(NotificationCenter.default.publisher(for: .devOpenOrganizerOverlay)) { _ in
//                withAnimation { isOrganizing = true }
//            }
        
        // Error overlay
//            .onReceive(NotificationCenter.default.publisher(for: .debugShowSampleError)) { _ in
//                showErrorOverlay = true
//            }
//            .overlay {
//                if showErrorOverlay {
//                    ErrorOverlayV(onClose: { showErrorOverlay = false })
//                }
//            }
            .fullScreenCover(isPresented: $isOrganizing
                             //                             //FIXME: - Does this =work without onDismiss?
                             //                             onDismiss: { viewModel.flushPendingSaves() }
            ) {
                OrganizerOverlayChrome(onClose: {
                    //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                    //                    viewModel.flushPendingSaves()
                    isOrganizing = false
                }) {
                    OrganizerOverlayScreen(
                        categories: $viewModel.categories,
                        onMoveTile: { tile, fromID, toID in
                            Task { @MainActor in
                                do { try await viewModel.moveTileThrowing(tile, from: fromID, to: toID) }
                                catch { viewModel.lastError = error }
                            }
                        },
                        onReorder: { newTiles, categoryID in
                            // reorderTiles already applies caps AND persists, saveHistory() isn't needed
                            viewModel.reorderTiles(newTiles, in: categoryID)
                        },
                        onDone: {
                            // close path X/drag like RecalibrationChrome
                            //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                            // viewModel.flushPendingSaves()
                            isOrganizing = false
                        }
                    )
                    .environmentObject(theme)
                }
                // Chrome owns gesture/X dismissal
                .interactiveDismissDisabled(true)
            }
        // HistoryV: the flush in .task(id: isOrganizing) when it becomes false,
        // - happens ONCE here, when the cover closes
            .task(id: isOrganizing) {
                // On leaving organize mode, force-flush pending saves.
                if !isOrganizing { viewModel.flushPendingSaves() }
            }
        Spacer(minLength: 0)
    }
    
    //    @ToolbarContentBuilder private var historyToolbar: some ToolbarContent {
    //        ToolbarItemGroup(placement: .topBarTrailing) {
    @ToolbarContentBuilder
    private var historyToolbar: some ToolbarContent {
        ToolbarItemGroup(placement: .topBarTrailing) {
            Button {
                if isOrganizing { viewModel.flushPendingSaves() }
                withAnimation { isOrganizing.toggle() }
            } label: {
                Label(
                    isOrganizing ? "Done" : "Edit", systemImage: "arrow.up.arrow.down"
                ).foregroundStyle(p.primary)
            }
            
            Menu {
                Button("Rename Category") {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        renameText = viewModel.name(for: only)
                        showRenameSheet = true
                    } else {
                        showRenamePicker = true
                    }
                }
                
                Button("Delete Category", role: .destructive) {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        showDeleteConfirm = true
                    } else {
                        showDeletePicker = true
                    }
                }
                
                Divider()
                
                Button("Add Category") {
                    if let id = viewModel.addEmptyUserCategory() {
                        createdCategoryID = id
                    }
                }
                .disabled(!viewModel.canAddUserCategory())
            } label: {
                Image(systemName: "ellipsis.circle").foregroundStyle(p.primary)
            }
        }
    }
    
    
    @ViewBuilder private var renameSheet: some View {
        NavigationStack {
            Form {
                Section("New Name") {
                    TextField("Category name", text: $renameText)
                        .textInputAutocapitalization(.words)
                        .disableAutocorrection(true)
                    
                    Button { Task { viewModel.canAddUserCategory() } } label: { T("Rename Category", .action) }
                        .primaryActionStyle(screen: screen)
                }
            }
            .navigationTitle("Rename")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { showRenameSheet = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        if let id = targetCategoryID {
                            viewModel.renameCategory(id: id, to: renameText.trimmingCharacters(in: .whitespacesAndNewlines))
                        }
                        showRenameSheet = false
                    }
                    .disabled(renameText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
        }
        .presentationDetents([.medium])
    }
}-e \n\n
=== ./IntentionTests/IntentionTests.swift ===
//
//  IntentionTests.swift
//  IntentionTests
//
//  Created by Benjamin Tryon on 9/16/25.
//

@testable import intention
import XCTest

final class IntentionTests: XCTestCase {

}
-e \n\n
=== ./IntentionTests/MathTests.swift ===
//
//  MathTests.swift
//  IntentionTests
//
//  Created by Benjamin Tryon on 9/16/25.
//

//
//      Write the test (in the IntentionTests target)

//      Create IntentionTests/MathTests.swift (target membership: IntentionTests):
//  Create App/Helpers/Math.swift (target membership: your app target, not the test target):
//  App/Helpers/Math.swift
//  import Foundation

///   Minimal test seam: pure, deterministic
//  struct Math {
//      static func sum(_ a: Int, _ b: Int) -> Int { a + b }
//  }

@testable import intention
import XCTest

final class MathTests: XCTestCase {

   // naming pattern: test_Method_Scenario_Expected
    func test_Sum_TwoNumbers_ReturnSum() {
        XCTAssertEqual(Math.sum(1, 2), 3)
        
//        // Arrange (set up the needed objects)
//        let a = 1, b = 2
//        
//        // Act (run the method you want to test)
//        let result = Math.sum(a, b)
//        
//        // Assert (test that the behavior is as expected)
//        XCTAssertEqual(result, 3)
    }

}
-e \n\n
