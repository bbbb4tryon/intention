=== ./intention/App/intentionApp.swift ===
//
//  intentionApp.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

@main
struct intentionApp: App {
    // Theme is the source of truth - and remains here, not in RootView itself
//    @StateObject var theme = ThemeManager()
    
    var body: some Scene {
        WindowGroup {
            RootView()
//                .environmentObject(theme)
        }
    }
}
-e \n\n
=== ./intention/App/RootView.swift ===
//
//  RootView.swift
//  intention
//
//  Created by Benjamin Tryon on 6/19/25.
//

import SwiftUI

// MARK: - FocusShell
/// Tiny shell that centralizes shared chrome per screen (backgrounds, overlays).
/// Keep it intentionally small so it composes well and doesn't re-introduce big chains.
struct FocusShell<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    @ViewBuilder var content: Content
    
    var body: some View {
        let pal = theme.palette(for: screen)
//        let base = content
        let backgrounded = content.background(pal.surface)    // card/surface under widgets
        
        ZStack {
            if let g = pal.gradientBackground {
                LinearGradient(colors: g.colors, startPoint: g.start, endPoint: g.end)
                    .ignoresSafeArea()
            } else {
                pal.background.ignoresSafeArea()
            }
            backgrounded
        }
    }
}

// MARK: - sheets presented from the root
enum RootSheet: Identifiable, Equatable {
    case legal, membership, terms, privacy, medical
    var id: String {
        switch self {
        case .legal: return "legal"
        case .membership: return "membership"
        case .terms: return "terms"
        case .privacy: return "privacy"
        case .medical: return "medical"
        }
    }
}


#if DEBUG
extension RootView {
    func _resetLegalGate() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
        activeSheet = .legal
    }
}
#endif


/// App entry content. Owns all VMs and injects them downward; owns the single paywall sheet
/// - Keeps VMs in the parent (single source of truth)
/// - Uses a FocusShell to centralize background/toolbar/handlers
/// - Breaks long chains into locals to help the type-checker (iOS 16-friendly)

/// RootView wires shared VMs, persistence, and the single paywall sheet.
struct RootView: View {
  
    // MARK: legal gate (AppStorage)
    @AppStorage(LegalKeys.acceptedVersion) private var acceptedVersion: Int = 0
    @AppStorage(LegalKeys.acceptedAtEpoch) private var acceptedAtEpoch: Double = 0
    
    // MARK: presentation
    @State private var activeSheet: RootSheet? = nil

    // MARK: scene
    @Environment(\.scenePhase) private var scenePhase
    
    // MARK: single source of truth (owned at the root)
    // Owns shared services / VMs and injected downwards
    @StateObject private var theme: ThemeManager
    @StateObject private var memVM: MembershipVM
    @StateObject private var historyVM: HistoryVM
    @StateObject private var focusVM: FocusSessionVM
    @StateObject private var recalVM: RecalibrationVM
    @StateObject private var statsVM: StatsVM
    @StateObject private var prefs: AppPreferencesVM
    @StateObject private var hapticsEngine: HapticsService            // warmed generators (UI object)
    
    // MARK: initializer: build dependencies, wire once, then assign to @StateObject wrappers
    init() {
        // infrastructure actors/services
        let persistence     = PersistenceActor()
        let config          = TimerConfig.current
        
        // plain instances (no self usage allowed inside init)
        let theme           = ThemeManager()
        let membership      = MembershipVM()
        let prefs           = AppPreferencesVM()
        let engine          = HapticsService()
        let liveHaptics     = LiveHapticsClient(prefs: prefs, engine: engine)
        
        let history         = HistoryVM(persistence: persistence)
        let focus           = FocusSessionVM(previewMode: false, haptics: liveHaptics, config: config)
        let recal           = RecalibrationVM(haptics: liveHaptics)
        let stats           = StatsVM(persistence: persistence)
        
        // "Single point" of wiring (create) across VMs
        focus.historyVM     = history                               // Focus writes completions into History
        stats.memVM         = membership                         // Stats can query membership state
        
        _theme = StateObject(wrappedValue: ThemeManager())
        _memVM = StateObject(wrappedValue: MembershipVM())
        
        // recalibration completion → Stats + reset focus flow
        recal.onCompleted = { [weak stats, weak focus] mode in
            guard let stats = stats else { return }
               let texts = focus?.tiles.map(\.text) ?? []
               stats.logSession(CompletedSession(
                   date: .now,
                   tileTexts: texts,
                   recalibration: mode
               ))
               Task { @MainActor in
                   try? await focus?.resetSessionStateForNewStart()
               }
        }
        
        // assign to the wrappers
        _theme          = StateObject(wrappedValue: theme)
        _memVM          = StateObject(wrappedValue: membership)
        _historyVM      = StateObject(wrappedValue: history)
        _focusVM        = StateObject(wrappedValue: focus)
        _recalVM        = StateObject(wrappedValue: recal)
        _statsVM        = StateObject(wrappedValue: stats)
        _prefs          = StateObject(wrappedValue: prefs)
        _hapticsEngine  = StateObject(wrappedValue: engine)
    }
    
    // MARK: - body
    var body: some View {
        // shared palette locals help calm the swift type-checker
        let palFocus    = theme.palette(for: .homeActiveIntentions)
        let palHist     = theme.palette(for: .history)
        let palSettings = theme.palette(for: .settings)
        let tabBG       = palFocus.background.opacity(0.88)          // Makes tab bar match app theme (iOS 16+)
        
        //FIXME: MAY NEED TO REMOVE?
        let palRecal    = theme.palette(for: .recalibrate)
        let palMem      = theme.palette(for: .membership)
        
        // Focus tab
        let focusContent    = FocusSessionActiveV(
            focusVM: focusVM,     // not viewModel:focusVM - focusVM: focusVM matches view's property name
            recalibrationVM: recalVM
            )
        
        let focusScreen     = FocusShell(screen: .homeActiveIntentions) {
            focusContent
        }
        
        let focusNav        = NavigationStack {
            focusScreen
                .navigationTitle("Focus")
                .navigationBarTitleDisplayMode(.inline)
        }
        .tabItem { Image(systemName: "timer") }

        
        // History tab
        let historyContent  = HistoryV(viewModel: historyVM)
        let historyScreen   = FocusShell(screen: .history) { historyContent }
        let historyNav      = NavigationStack {
            historyScreen
                .navigationTitle("History")
                .navigationBarTitleDisplayMode(.inline)
        }
        .tabItem { Image(systemName: "clock") }
        
        // Settings tab (drives stats, membership, ...)
        let settingsContent = SettingsV(statsVM: statsVM)
        let settingsScreen  = FocusShell(screen: .settings) { settingsContent }
        let settingsNav     = NavigationStack {
            settingsScreen
                .navigationTitle("Settings")
                .navigationBarTitleDisplayMode(.inline)
        }
        .tabItem { Image(systemName: "gear") }
        
        // Tabs built as a *local* keeps long chains out of top-level expression
        let tabs    = TabView {
            focusNav
            historyNav
            settingsNav
        }
        
        // Wrap here to apply shared toolbars, backgrounds
        let content = tabs
            .toolbarBackground(tabBG, for: .tabBar)
            .toolbarBackground(.visible, for: .tabBar)
        
        content
        // the shared environment
            .environmentObject(theme)
            .environmentObject(statsVM)
            .environmentObject(memVM)
            .environmentObject(historyVM)
            .environmentObject(prefs)
            .environmentObject(hapticsEngine)
        
        // Keep nav bars coherent with theme - applied per screen via FocusShell/background
            .toolbarBackground(tabBG, for: .navigationBar)
        
        // MARK: App lifecycle (guardrail: scene handling lives at root)
            .onChange(of: scenePhase) { phase in
                switch phase {
                case .inactive, .background:
                    historyVM.flushPendingSaves()
                    // If you want auto-pause on background:
                    // if focusVM.phase == .running {
                    //     focusVM.performAsyncAction { await focusVM.pauseCurrent20MinCountdown() }
                    // }
                case .active: break
                @unknown default: break
                }
            }
        // MARK: App launch + legal gate
        .onAppear {
            if LegalConsent.needsConsent() {
                activeSheet = .legal
            }
            
            // Wrapped in #if debug to not affect release
            #if DEBUG
            if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
                UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
                UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
                activeSheet = .legal
            }
            #endif
            
//            /// First-run categories
//            if !hasInitializedGeneralCategory {
//                historyVM.ensureGeneralCategory()
//                hasInitializedGeneralCategory = true
//                debugPrint("Default category initialized from RootView")
//            }
//            if !hasInitializedArchiveCategory {
//                historyVM.ensureArchiveCategory()
//                hasInitializedArchiveCategory = true
//                debugPrint("Archive category initialized from RootView")
//            }
        }
        // Membership prompt choreography
        .onChange(of: memVM.shouldPrompt) { show in
            if show, activeSheet == nil { activeSheet = .membership }
        }
        .onChange(of: activeSheet) { sheet in
            if sheet == nil, memVM.shouldPrompt { activeSheet = .membership }
        }
        // MARK: Sheets
                   .sheet(item: $activeSheet) { sheet in
                       switch sheet {
                       case .legal:
                           LegalAgreementSheetV(
                               onAccept: {
                                   LegalConsent.recordAcceptance()
                                   acceptedVersion = LegalConfig.currentVersion
                                   acceptedAtEpoch = Date().timeIntervalSince1970
                                   activeSheet = nil
                               },
                               onShowTerms:   { activeSheet = .terms },
                               onShowPrivacy: { activeSheet = .privacy },
                               onShowMedical: { activeSheet = .medical }
                           )

                       case .membership:
                           NavigationStack {
                               MembershipSheetV()
                                   .environmentObject(memVM)
                                   .environmentObject(theme)
                           }
                           .onDisappear { memVM.shouldPrompt = false }

                       case .terms:
                           NavigationStack {
                               LegalDocV(
                                   title: "Terms of Use",
                                   markdown: MarkdownLoader.load(named: LegalConfig.termsFile)
                               )
                           }

                       case .privacy:
                           NavigationStack {
                               LegalDocV(
                                   title: "Privacy Policy",
                                   markdown: MarkdownLoader.load(named: LegalConfig.privacyFile)
                               )
                           }

                       case .medical:
                           NavigationStack {
                               LegalDocV(
                                   title: "Wellness Disclaimer",
                                   markdown: MarkdownLoader.load(named: LegalConfig.medicalFile)
                               )
                           }
                       }
                   }
           }
       }
        
//        
//        
//        TabView {
//            /// allows `RootView` supply navigation via `NavigationStack`, pass in VMs
//            NavigationStack {
//                FocusSessionActiveV(viewModel: focusVM, recalibrationVM: recalVM)
//                    .navigationTitle("Focus")
//                    .navigationBarTitleDisplayMode(.inline)
//                    .toolbarBackground(theme.palette(for: .homeActiveIntentions).background, for: .navigationBar)
//                    .toolbarBackground(tabBG, for: .tabBar)
//                    .toolbarBackground(.visible, for: .tabBar)
//                    .toolbarBackground(tabBG, for: .navigationBar)
//                    .toolbarBackground(.visible, for: .navigationBar)
//                    .friendlyHelper()
//            }
//            .tabItem { Image(systemName: "house.fill") }
//            
//            NavigationStack {
//                HistoryV(viewModel: historyVM)
//                    .navigationTitle("History")
//                    .navigationBarTitleDisplayMode(.inline)
//            }
//            .tabItem {  Image(systemName: "book.fill").accessibilityAddTraits(.isHeader)  }
//            
//            NavigationStack {
//                SettingsV(viewModel: statsVM)
//                    .navigationTitle("Settings")
//                    .navigationBarTitleDisplayMode(.inline)
//            }
//            .tabItem {  Image(systemName: "gearshape.fill").accessibilityAddTraits(.isHeader) }
//        }
//
//        /// consistent color schemes for app tab bar
//        .toolbarBackground(tabBG, for: .tabBar)
//        .toolbarBackground(.visible, for: .tabBar)
//        /// consistent color schemes for nav bars
//        .toolbarBackground(tabBG, for: .navigationBar)
//
//        // MARK: App launch + legal gate
//        .onAppear {
//            
//            
//            private var ifLegalGateNeeded: Bool { LegalConsent.needsConsent() }
//            if ifLegalGateNeeded { activeSheet = .legal }
//            
//            // Wrapped in #if debug to not affect release
//            #if DEBUG
//            if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
//                UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
//                UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
//                activeSheet = .legal
//            }
//            #endif
//            
////            /// First-run categories
////            if !hasInitializedGeneralCategory {
////                historyVM.ensureGeneralCategory()
////                hasInitializedGeneralCategory = true
////                debugPrint("Default category initialized from RootView")
////            }
////            if !hasInitializedArchiveCategory {
////                historyVM.ensureArchiveCategory()
////                hasInitializedArchiveCategory = true
////                debugPrint("Archive category initialized from RootView")
////            }
//        }
//        .onChange(of: scenePhase ) { phase in
//            if phase == .inactive || phase == .background {
//                historyVM.flushPendingSaves()
//            }
//        }
//        .onChange(of: memVM.shouldPrompt) { show in
//            // Queue membership only if nothing else (e.g., Legal) is showing.
//            if show, activeSheet == nil { activeSheet = .membership }
//        }
//        .onChange(of: activeSheet) { sheet in
//            // If Legal just dismissed and membership is pending, present it next.
//            if sheet == nil, memVM.shouldPrompt { activeSheet = .membership }
//        }
//        
//        .sheet(item: $activeSheet) { sheet in
//            switch sheet {
//            case .legal:
//                LegalAgreementSheetV(
//                    onAccept: {
//                        LegalConsent.recordAcceptance()
//                        acceptedVersion = LegalConfig.currentVersion
//                        acceptedAtEpoch = Date().timeIntervalSince1970
//                        activeSheet = nil
//                    },
//                    onShowTerms:   { activeSheet = .terms },
//                    onShowPrivacy: { activeSheet = .privacy },
//                    onShowMedical: { activeSheet = .medical }
//                )
//                
//            case .membership:
//                NavigationStack {
//                    MembershipSheetV()
//                        .environmentObject(memVM)
//                        .environmentObject(theme)
//                }
//                    .onDisappear { memVM.shouldPrompt = false }
//                
//            case .terms:
//                NavigationStack {
//                    LegalDocV(title: "Terms of Use",
//                              markdown: MarkdownLoader.load(named: LegalConfig.termsFile))
//                }
//                
//            case .privacy:
//                NavigationStack {
//                    LegalDocV(title: "Privacy Policy",
//                              markdown: MarkdownLoader.load(named: LegalConfig.privacyFile))
//                }
//                
//            case .medical:
//                NavigationStack {
//                    LegalDocV(title: "Wellness Disclaimer",
//                              markdown: MarkdownLoader.load(named: LegalConfig.medicalFile))
//                }
//            }
//        }
//        /// Provide shared environment objects once, from the root/ so SwiftUI views can call it easily if they want to.
//        .environmentObject(theme)
//        .environmentObject(statsVM)
//        .environmentObject(memVM)
//        .environmentObject(historyVM)
//        .environmentObject(prefs)
//        .environmentObject(haptics)
//    }
//}

#if DEBUG
#Preview {
    RootView()
        .previewTheme()
}
#endif
-e \n\n
=== ./intention/App/Debug/debugModifier.swift ===
//
//  debugModifier.swift
//  intention
//
//  Created by Benjamin Tryon on 6/13/25.
//
import SwiftUI

extension View {
    @ViewBuilder
    func debugModifier<T: View>(_ modifier: (Self) -> T) -> some View {
        #if DEBUG
        modifier(self)
        #else
        self
        #endif
    }
    //  append a call at the end of view { }.here declaration, just like any other modifier
    //      only actually prints a value within debug builds if used as `.debugPrint()`
    @discardableResult
        func debugAction(_ closure: () -> Void) -> Self {
        #if DEBUG
        closure()
        #endif
            return self
        }

    /*
     example:
     extension View {
         func debugPrint(_ value: Any) -> Self {
             debugAction { print(value) }
         }
     }

     struct EventView: View {
         @ObservedObject var viewModel: EventViewModel

         var body: some View {
             VStack {
                 ...
             }
             .debugPrint(viewModel.bannerImage.size)
         }
     }
     */

    // Convenience wrappers
    func debugBorder(_ color: Color = .red, width: CGFloat = 1) -> some View {
        debugModifier { $0.border(color, width: width) }
    }
    
    func debugBackground(_ color: Color = .red) -> some View {
        debugModifier { $0.background(color) }
    }
}

/*
 
 Text(viewModel.formattedDate)
                .debugBackground(.green)
 or
 
 VStack {
        // code
    }
    .debugBorder()
 */



-e \n\n
=== ./intention/App/Debug/DebugKeys.swift ===
//
//  DebugKeys.swift
//  intention
//
//  Created by Benjamin Tryon on 9/12/25.
//

import SwiftUI

struct DebugKeys {
    static let forceLegalNextLaunch = "debug.forceLegalNextLaunch"
}

/// Call once at app startup (e.g., in App/RootView.onAppear)
func bootstrapLegalGate() {
    // Test plan env var still works if you keep using it
    if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
        LegalConsent.clearForDebug()
    }
    if UserDefaults.standard.bool(forKey: DebugKeys.forceLegalNextLaunch) {
        LegalConsent.clearForDebug()
        UserDefaults.standard.set(false, forKey: DebugKeys.forceLegalNextLaunch)
    }
}
-e \n\n
=== ./intention/Features/Settings/SettingsLegalSection.swift ===
//
//  SettingsLegalSection.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

import SwiftUI

struct SettingsLegalSection: View {
    var onShowTerms: () -> Void
    var onShowPrivacy: () -> Void
    var onShowMedical: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Legal").font(.headline)
            HStack(spacing: 10) {
                Button("Terms of Use") { onShowTerms() }.buttonStyle(.plain).underline()
                Text("•")
                Button("Privacy Policy") { onShowPrivacy() }.buttonStyle(.plain).underline()
                Text("•")
                Button("Wellness Disclaimer") { onShowMedical() }.buttonStyle(.plain).underline()
            }
            .font(.footnote)
            .foregroundStyle(.secondary)
        }
    }
}

#if DEBUG
#Preview {
    SettingsLegalSection(onShowTerms: {}, onShowPrivacy: {}, onShowMedical: {})
        .padding()
}
#endif
-e \n\n
=== ./intention/Features/Settings/SettingsV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import UserNotifications

struct SettingsV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    @EnvironmentObject var memVM: MembershipVM
    @ObservedObject var statsVM: StatsVM
    @AppStorage(DebugKeys.forceLegalNextLaunch) private var debugShowLegalNextLaunch = false
    
    @State private var userID: String = ""      /// aka deviceID
    @State private var showTerms = false
    @State private var showPrivacy = false
    @State private var showMedical = false
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    var body: some View {
        ScrollView {
            Page(top: 4, alignment: .center) {
        #if DEBUG
        Section("Developer") {
            Button("Reset Legal Gate Now") {
                LegalConsent.clearForDebug() // your helper that clears acceptance
            }
            Toggle("Show Legal on Next Launch", isOn: $debugShowLegalNextLaunch)
        }
        #endif


                Card {
                    VStack(alignment: .leading, spacing: 8){
                        T("Membership", .section)
                        //                        .friendlyHelper()
                        (memVM.isMember
                         ? T("Status: Active", .secondary) : T("Status: Not Active", .secondary)
                        )
                        .foregroundStyle(memVM.isMember ? .green : .secondary)
                        
                        T("Your user ID/device ID: \(userID)", .caption)
                            .foregroundStyle(p.textSecondary)
                        HStack(spacing: 12){
                            Button (action: {
                                /// Instead of Link()
                                if let url = URL(string: "https://apps.apple.com/account/subscriptions") {
                                    UIApplication.shared.open(url)
                                }
                            }) {
                                T("Manage Subscription", .header)
                            }
                            .primaryActionStyle(screen: .settings)
                            .tint(p.accent)
                        }
                    }
                }
                
                /// Stats
                Card {
                    HStack(spacing: 20) {
                        StatPill(icon: "list.bullet",
                                  value: "\(statsVM.totalCompletedIntentions)",
                                  caption: "Accomplished",
                                  screen: .settings)
                        
                        StatPill(icon: "rosette",
                                  value: "\(statsVM.longestStreak)",
                                  caption: "Streak",
                                  screen: .settings)
                    }
                    Divider()
                    HStack(spacing: 20) {
                        StatPill(icon: "leaf.fill",
                                  value: "\(statsVM.recalibrationCounts[.breathing,  default: 0])",
                                  caption: "Breathing",
                                  screen: .settings)
                        StatPill(icon: "figure.walk",
                                  value: "\(statsVM.recalibrationCounts[.balancing,  default: 0])",
                                  caption: "Balancing",
                                  screen: .settings)
                    }
                    
                }
                
                Divider()
                
                /// Preferences Section
                Card {
                    VStack(alignment: .leading,spacing: 8){
                        T("Preferences", .section)
                        Toggle(isOn: .constant(true)) { T("Enable Notification", .caption) }
                        Toggle(isOn: $prefs.hapticsOnly) { T("Haptics Only: Vibration cues only", .caption)
                            .foregroundStyle(p.textSecondary) }
                        Toggle(isOn: .constant(false)) { T("Sound Off", .caption) }
                            .controlSize(.small)        /// Toggle size
                            .toggleStyle(SwitchToggleStyle(tint: p.accent))
                    }
                    .friendlyAnimatedHelper("hapticsOnly-\(prefs.hapticsOnly ? "on" : "off")")
                }
                
                /// Color Theme Picker
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Personalization", .section)
                        
                        // Color Theme Picker
                        Picker(selection: $theme.colorTheme) {
                            ForEach(AppColorTheme.allCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Color", .label)          // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)                 // segment highlight color
                        
                        // Font Theme Picker
                        Picker(selection: $theme.fontTheme) {
                            ForEach(AppFontTheme.allCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Font", .section)     // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)
                        .friendlyAnimatedHelper(theme.fontTheme.rawValue)
                    }
                }
                
                /// Legal (reprise)
                Card {
                    VStack(alignment: .leading, spacing: 8){
                        
                        SettingsLegalSection(
                          onShowTerms:   { showTerms = true },
                          onShowPrivacy: { showPrivacy = true },
                          onShowMedical: { showMedical = true }
                        )
                        .sheet(isPresented: $showTerms) {
                          NavigationStack { LegalDocV(title: "Terms of Use",
                            markdown: MarkdownLoader.load(named: LegalConfig.termsFile)) }
                        }
                        .sheet(isPresented: $showPrivacy) {
                          NavigationStack { LegalDocV(title: "Privacy Policy",
                            markdown: MarkdownLoader.load(named: LegalConfig.privacyFile)) }
                        }
                        .sheet(isPresented: $showMedical) {
                          NavigationStack { LegalDocV(title: "Wellness Disclaimer",
                            markdown: MarkdownLoader.load(named: LegalConfig.medicalFile)) }
                        }
                    }
                }
                
            }
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .task {
        /// Read it directly from your keychain on-demand - actor requires only await, not async here
            userID = await KeychainHelper.shared.getUserIdentifier()
        }
    }

    func requestNotificationPermissions() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            if let error = error {
                print("Notification permission error: \(error.localizedDescription)")
            }
            print("Permission granted: \(granted)")
        }
    }
}

#if DEBUG
#Preview("Stats & Settings") {
    MainActor.assumeIsolated {
        let stats = PreviewMocks.stats
        stats.logSession(CompletedSession(date: .now, tileTexts: ["By Example", "Analysis checklist"], recalibration: .breathing))

        return PreviewWrapper {
            SettingsV(statsVM: PreviewMocks.stats)
                .previewTheme()
        }
    }
}
#endif
-e \n\n
=== ./intention/Features/ErrorOverlay/ErrorOverlay.swift ===
//
//  ErrorOverlay.swift
//  intention
//
//  Created by Benjamin Tryon on 7/1/25.
//

import SwiftUI

// `self.lastError = error` to trigger the ErrorOverlay
struct ErrorOverlay: View {
    @EnvironmentObject var theme: ThemeManager
    let error: Error
    let dismissAction: () -> Void
    
    var body: some View {
        VStack(spacing: 12) {
            Text("⚠️ Something went wrong")
                .bold()
            Text(displayMessage(for: error))
                .multilineTextAlignment(.center)
                .foregroundStyle(.secondary)
            
            Button("dismiss", action: dismissAction)
                .secondaryActionStyle(screen: .recalibrate)
        }
        .padding()
        .background(.ultraThinMaterial)
        .cornerRadius(16)
        .shadow(radius: 10)
        .padding()
    }
    
    private func displayMessage(for error: Error) -> String {
        let description = error.localizedDescription
        if description == "The operation could not be completed." {
            return "Something went wrong, please try again"
    }
            return description
    }
}

/*
 Currently, error displays FocusSessionError.unexpected or HistoryError.categoryNotFound, etc.
 Meaning enums fall back to String(describing:) so you see FocusSessionError.unexpected or HistoryError.categoryNotFound

 Later: As soon as you add `LocalizedError` with `custom errorDescription`, the nicer user message shows:
 enum HistoryError: LocalizedError {
     case categoryNotFound
     var errorDescription: String? { "The category could not be found. Tile not added." }
 }
 …the overlay will automatically show "The category could not be found. Tile not added." without any changes to the view
 */
-e \n\n
=== ./intention/Features/Focus/FocusTimerActor.swift ===
//
//  FocusTimerActor.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import Foundation

// Concurrency-Safe focusCountdownTask
// session's start time and the tiles that have been added within that session context
actor FocusTimerActor {
    /// Short debug/UI tests without touching production logic
    private let config: TimerConfig
    init(config: TimerConfig) { self.config = config }
    
    private(set) var sessionStartDate: Date?
    private(set) var currentTiles: [TileM] = [] // NOTE: adding = [] dismisses 'has no initializers'
    
    /// Starts a new session window; clears actor's tile buffer.
    func startSessionTracking() {
        sessionStartDate = Date()
        currentTiles = []           /// Clear tiles for new session
    }
    
    /// Attempts to append a tile; returns false if limit (2) already reached.
    func addTile(_ tile: TileM) -> Bool {
        guard currentTiles.count < 2 else { return false }
        currentTiles.append(tile)
        return true
    }
    
    func shouldCheckIn() -> Bool {
        guard let start = sessionStartDate else { return false }
        return Date().timeIntervalSince(start) >= Double(config.chunkDuration)      /// Should be 1200 - don't hardcode
    }
    
    func resetSessionTracking() {
        sessionStartDate = nil
        currentTiles = []
    }
}
-e \n\n
=== ./intention/Features/Focus/FocusSessionVM.swift ===
//
//  FocusSessionVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import Foundation

/// Error cases for focus session flow
enum FocusSessionError: Error, Equatable {
    case emptyInput
    case tooManyTiles(limit: Int = 2)
    case invalidBegin(phase: FocusSessionVM.Phase, tilesCount: Int)
    case persistenceFailed
    case unexpected
    
    var errorDescription: String? {
        switch self {
        case .emptyInput: return "Please enter a task, what you intend to do."
        case .tooManyTiles(let limit): return "You can only add \(limit) intentions."
        case .invalidBegin(_, let count): return "Can't begin with \(count) tiles."
        case .persistenceFailed: return "Saving failed. Try again."
        case .unexpected: return "Something went wrong. Please try again."
        }
    }
    
}

/// FocusSessionVM talks to FocusTimerActor and drives the UI
/// Errors: make UI-called methods async throws (no wrapper)
@MainActor
final class FocusSessionVM: ObservableObject {
    
    /// UI state of the current 20-min chunk
    enum Phase {
        case notStarted, running, finished, paused
    }
    
    // MARK: - Published UI State
    @Published var tileText: String = ""  { didSet { validationMessages = tileText.taskValidationMessages }}         /// Input field for tiles' text;   Validate whenever tileText changes
    @Published var tiles: [TileM] = []              /// List of current session tiles (max 2)
    @Published var canAdd: Bool = true              /// Flag if user can add more tiles at that point
    @Published var sessionActive: Bool = false      /// Overall session state (two 20-min chunks)
    @Published var showRecalibrate: Bool = false    /// Whether to show recalibration
    @Published var countdownRemaining: Int          /// Secs remaining in 20 minutes for individual tile task - set via config
    @Published var phase: Phase = .notStarted       /// State of the *current* 20-min countdown chunk
    @Published var currentSessionChunk: Int = 0     /// Index of current chunk (0 or 1): Tracks which 20-min chunk of the session is active
    @Published var sessionHistory: [[TileM]] = []   /// Array of tiles completed in this session of 2 chunks
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    @Published var validationMessages: [String] = []
    
    // MARK: - Internal Properties
    private let haptics: HapticsClient
    private let config: TimerConfig
    private let tileAppendTrigger: FocusTimerActor
    private var chunkCountdown: Task<Void, Never>? = nil        /// background live time keeper/ticker
    private var sessionCompletionTask: Task<Void, Never>? = nil /// background timer for the entire session (2x 20-min chunks)
    weak var historyVM: HistoryVM?                      /// Link to history view model for/to save completed sessions
    var chunkDuration: Int { config.chunkDuration }     /// Default 20 min chunk duration constant
    
    // MARK: - Cancel or teardown
    deinit {
        chunkCountdown?.cancel()
        sessionCompletionTask?.cancel()
    }
    
    // Preview-friendly Initializer of session state
    init(previewMode: Bool = false, haptics: HapticsClient, config: TimerConfig = .current) {
        self.haptics = haptics
        self.config = config
        self.countdownRemaining = config.chunkDuration
        self.tileAppendTrigger = FocusTimerActor(config: config)
        
        if previewMode {
            tiles = [TileM(text: "Tile 1"), TileM(text: "Tile 2")]
            tileText = "Start another..."
            canAdd = false
            sessionActive = true
            currentSessionChunk = 1
            phase = .running
            countdownRemaining = config.chunkDuration / 20
        }
    }
    
    // MARK: - Tile Submission Logic
    
    /// Adds a new tile to the session if under limit
    func addTileAndPrepareForSession(_ text: String) async throws {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {   throw FocusSessionError.emptyInput    }
        guard tiles.count < 2 else {    throw FocusSessionError.tooManyTiles()    }
        
        let newTile = TileM(text: trimmed)
        
        /// Cross-actor hop; no 'try' becuase the actor method doesn't throw
        let accepted = await tileAppendTrigger.addTile(newTile)
        guard accepted else { throw FocusSessionError.tooManyTiles(limit: 2) }
        
        tiles.append(newTile)
        tileText = ""
        canAdd = tiles.count < 2       /// Keeps flag in sync
        // Wrap noisy debug prints in if debug
        haptics.added()
        #if DEBUG
        debugPrint("[FocusSessionVM.addTileAndPrepareForSession] did not occur")
        #endif
    }
    
    /// Starts the 20-min countdown for the current focus session.
    func startCurrent20MinCountdown() throws {
        guard tiles.count == 2, phase != .running else {
            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        }
        stopCurrent20MinCountdown()         /// cancels any existing timers
        
        // ContinuousClock avoids wall-clock jumps from time/date changes
        phase = .running
        let seconds = chunkDuration
        let clock = ContinuousClock()
        let deadline = clock.now.advanced(by: .seconds(seconds))
        
        //        countdownRemaining = chunkDuration  /// resets to 20 minutes
        chunkCountdown = Task { [weak self] in
            guard let self else { return }
            while !Task.isCancelled {
                let remaining = max(0, Int(clock.now.duration(to: deadline).components.seconds))
                await MainActor.run { self.countdownRemaining = remaining }
                if remaining == 0 { break }
                try? await clock.sleep(for: .seconds(1))
            }
            //            try? await clock.sleep(for: .seconds(1))
            //            await MainActor.run { self.countdownRemaining -= 1 }
            
            
            //        guard !Task.isCancelled else { return }     //FIXME: what's this?
            /// >>> All post-finish work happens INSIDE the Task <<<
            await MainActor.run {
                guard self.phase == .running else { return }
                self.phase = .finished
                self.haptics.notifyDone()
                self.naturallyAdvanceSessionChunk()
            }
            //        await MainActor.run { self.naturallyAdvanceSessionChunk() }
            // Clear the task
            await MainActor.run { self.chunkCountdown = nil }
        }
    }

//            if self.countdownRemaining <= 0 && self.phase == .running {
//                self.phase = .finished
//                self.haptics.notifyDone()
//            }
//        }
//        self.chunkCountdown = nil
//        await MainActor.run { self.naturallyAdvanceSessionChunk() }
//    }
        
//        chunkCountdown = Task {
//            for await _ in Timer.publish(every: 1, on: .main, in: .common).autoconnect().values {
//                guard !Task.isCancelled else {  debugPrint("Countdown task cancelled"); return  }
//                if countdownRemaining > 0 { countdownRemaining -= 1; debugPrint("Session countdown: \(formattedTime)")
//                } else {    debugPrint("40 min session completed"); break   }
//            }
//            
//            /// Block executes when countdownRemaining reaches 0 or is cancelled
//            if self.countdownRemaining <= 0 && self.phase == .running {
//                await MainActor.run {
//                    self.phase = .finished
//                    self.haptics.notifyDone()
//                    debugPrint("`Haptic.notifyDone()` triggered? Current 20-min chunk completed")
//                }
//                self.chunkCountdown?.cancel()
//                self.chunkCountdown = nil
//                naturallyAdvanceSessionChunk()
//            }
    
    /// Advances chunk index and checks session completion
    func naturallyAdvanceSessionChunk(){
        currentSessionChunk += 1
        self.checkSessionCompletion()   /// check if chunks session is completed
    }
    
    /// Stops and resets the current countdown timer
    func stopCurrent20MinCountdown() {
        chunkCountdown?.cancel()
        chunkCountdown = nil
        phase = .notStarted
        countdownRemaining = chunkDuration
        #if DEBUG
        debugPrint("Current 20-min countdown stoppped and reset")
        #endif
    }
    
    func pauseCurrent20MinCountdown() async {
        guard phase == .running else { return }
        chunkCountdown?.cancel()
        chunkCountdown = nil
        phase = .paused
    }
    
    func resumeCurrent20MinCountdown() async throws {
        guard phase == .paused else { throw FocusSessionError.unexpected }
        let seconds = countdownRemaining
        guard seconds > 0 else {
            // Nothing to resume; treat as finished
            phase = .finished
            naturallyAdvanceSessionChunk()
            return
        }

        phase = .running
        let clock = ContinuousClock()
        let deadline = clock.now.advanced(by: .seconds(seconds))

        chunkCountdown = Task { [weak self] in
                guard let self else { return }
                while !Task.isCancelled {
                    let remaining = max(0, Int(clock.now.duration(to: deadline).components.seconds))
                    await MainActor.run { self.countdownRemaining = remaining }
                    if remaining == 0 { break }
                    try? await clock.sleep(for: .seconds(1))
                }

                await MainActor.run {
                    // Only mark finished if we actually were running when the task ended
                    guard self.phase == .running else { return }
                    self.phase = .finished
                    self.haptics.notifyDone()
                    self.naturallyAdvanceSessionChunk()
                    self.chunkCountdown = nil
                }
            }
        }
    
    // MARK: - Session Lifecycle/Flow
    
    /// Combined Trigger of Chunks Session (via "Begin")
    func beginOverallSession() async throws {
        /// Use the *current* phase for the error payload
        guard tiles.count == 2, phase == .notStarted else {
            debugPrint("Begin pressed and [FocusSessionVM.beginOverallSession] triggered.")
            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        }
        await tileAppendTrigger.startSessionTracking()
        sessionActive = true                                /// Overall session activated
        try startCurrent20MinCountdown()                    /// First Chunk started
    }
    
    /// Adds a tile or starts session, depending on context
    func beginSessionFlow() async throws {
        if tiles.count < 2 {
            try await addTileAndPrepareForSession(tileText)
        } else {
            // NOTE: -
            /*
             If two tiles are already present, and a countdown just finished,
            this button could be used to explicitly start the *next* 20-min chunk
            if the user chose not to immediately continue.
            For now, based on your description, this button mainly triggers `addTileAndPrepareForSession`.
            // We might need more explicit UI for "Start next 20-min chunk".
             */
            print("All tiles added. Consider adding logic for starting next chunk explicitly.")
            try await beginOverallSession()
        }
    }
    
    /// Resets the session state for a new start - non-throwing; async because we `await` the actor
    func resetSessionStateForNewStart() async {
        stopCurrent20MinCountdown()                     /// Ensures any running countdown is stopped
        tiles = []
        tileText = ""
        canAdd = true
        sessionActive = false
        showRecalibrate = false
        currentSessionChunk = 0
        await tileAppendTrigger.resetSessionTracking()
        debugPrint("ViewModel state reset for a new session.")
    }
    
    func handlePrimaryTap() async {
        if tiles.count < 2 { try? await addTileAndPrepareForSession(tileText) }
        else if tiles.count == 2 && phase == .notStarted { try? await beginOverallSession() }
    }
    
   /// Chunks session for completion, triggers recalibration **uses HistoryVM canonical IDs**
    private func checkSessionCompletion() {
        if currentSessionChunk >= 2 {                               /// both chunks done
            sessionActive = false                                   /// 40-min overall session done
            showRecalibrate = true                                  /// modal triggered
            debugPrint("Recalibration choice modal should display")
            /// Bounded tile history call, add tiles to category
            guard let targetCategoryID = historyVM?.generalCategoryID else {
                debugPrint("[FocusSessionVM.checkSessionCompletion] missing historyVM.generalCategoryID"); return
            }
            for tile in tiles.prefix(2){
                historyVM?.addToHistory(tile, to: targetCategoryID)
            }
            /// NOTE: - Don't reset actor for new session here - user will on modal
        } else {
            print("""
                  Completed the \(currentSessionChunk)!
                  Well done!
                  On to the next one
                  """)
            /// If currentSessionChunk is 1 and phase==finished, the UI will show "Start Next 20 Minutes"
        }
    }

    
    
    // MARK: - Helpers
    
    /// MM:SS helper to format time
    var formattedTime: String {
        let minutes = countdownRemaining / 60
        let seconds = countdownRemaining % 60
        return String(format: "%02d:%02d", minutes,seconds)
    }
    
    /// Sets flag to trigger recalibration modal
    func checkRecalibrationNeeded() {
        if tiles.count == 2 {
            showRecalibrate = true
        }
    }
    

    //  NOTE: Do not set as a global function - needs to modify `lastError`
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do {
                try await action()
            } catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
    
    // MARK: Helpers + Throwing Core
    var canPrimary: Bool {
        if tiles.count < 2 {
            let trimmed = tileText.trimmingCharacters(in: .whitespacesAndNewlines)
            return !trimmed.isEmpty && tileText.taskValidationMessages.isEmpty && phase != .running
        } else {
            // Ready to begin when exactly 2 tiles and not already running
            return phase == .notStarted
        }
    }
    
    ///Throwing core (async throws): use when the caller wants to decide how to handle the error
}
extension FocusSessionVM {
    var inputValidationState: ValidationState {
        let msgs = tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    
    /// A tile is "completed" iff its index is below the currentSessionChunk (0 or 1).
       func isCompleted(_ tile: TileM) -> Bool {
           guard let idx = tiles.firstIndex(of: tile) else { return false }
           return idx < currentSessionChunk
       }
}
-e \n\n
=== ./intention/Features/Focus/FocusSessionActiveV.swift ===
//
//  FocusSessionActiveV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

// FocusSessionActiveV <--> ContentView
// MARK: - Folder Layout (Feature-Based, SwiftUI + UIKit + Actors)

/* Handle, not crash unless app is in danger;
 - fast, well-isolated unit tests
 - performance tests to provide regression coverage of performance-critical regions of code
 - create a test plan to run only the unit tests for a module while developing and debugging that module,
 - a second test plan to run all unit, integration, and UI tests before submitting your app to the App Store
 git commit -m "feat: Add SwiftLint and improve documentation style" -m "This commit adds SwiftLint with a missing_docs rule to enforce documentation standards.
 It also refactors existing comments and documentation to a new, standardized style:
 - Use /// for one-liners.
 - Only use @param and @throws where necessary.
 - Preserve existing clean MARK structures.
 "


 1. Where are resources for quickly getting up to speed EXCEPT apple documentation, which is not my favorite resource to start anything on?
 2. I think a generic test result is best, that is, instead of the test requiring the specific text, I'd rather have test require not empty, not gobbledegook, not malicious and with character and string-length limits or other limits.

 */
import SwiftUI

/// Error types specific to the active session/chunk
enum ActiveSessionError: Error, Equatable {
    case submitFailed, sessionAlreadyRunning
}

/// MembershipSheetV modal sheet presentation handling enum
enum ActiveSheet: Equatable {
    case none, membership
}

/// The main view for running a focus session, accepting two intention tiles of text inpit
/// Displays countdown timer, text input for intention tiles, recalibration sheet
struct FocusSessionActiveV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var statsVM: StatsVM
    @EnvironmentObject var memVM: MembershipVM
    @Environment(\.dismiss) var dismiss
    @Environment(\.scenePhase) private var phase
    @Environment(\.accessibilityDifferentiateWithoutColor) private var diffNoColor
    
    /// Session state and session logic container
    @ObservedObject var focusVM: FocusSessionVM
    
    /// Recalibration session VM (ObservedObject for ViewModel owned by parent)
    @ObservedObject var recalibrationVM: RecalibrationVM
    
    /// Gated behind interaction and state
    @FocusState private var intentionFocused: Bool
    @State private var showValidation: Bool = false
    
    private var shouldShowValidation: Bool {
        // Show only when user has interacted (failed submit) AND we're not mid-session
        showValidation
        && focusVM.phase == .notStarted
        && !focusVM.tileText.isEmpty
        && !focusVM.tileText.taskValidationMessages.isEmpty
    }
    
    // Keeps call sites short and every string goes through the style system - provides a closure that returns a `LocalizedStringKey` using `theme.styledText(_:as:in:)`
    /// Theme hooks
    private let screen: ScreenName = .homeActiveIntentions
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // Convenience
    private var isInputActive: Bool { focusVM.phase != .running && focusVM.tiles.count < 2 }
    private var vState: ValidationState {
        let msgs = focusVM.tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    
    var body: some View {
        ZStack {
            ScrollView {                            /// Allows content to breath on small screens
                Page(top: 4, alignment: .center) {
                    StatsSummaryBar()
                        .padding(.top, 4)
                    
                    // Text input + validation
                    VStack(alignment: .leading, spacing: 6) {
                        ZStack(alignment: .leading) {
                            TextField("", text: $focusVM.tileText, axis: .vertical)
                            // FIXME: is this correcting the validation messages (103-110 with 116-118)?
                                .focused($intentionFocused)
                                .submitLabel(.done)
                                .onSubmit {
                                    Task {
                                        do { try await focusVM.addTileAndPrepareForSession(focusVM.tileText); showValidation = false }
                                        catch { showValidation = true }
                                    }
                                }
                                .validatingField(state: vState, palette: p)
                                .disabled(!isInputActive)
                                .autocorrectionDisabled()
                                .textInputAutocapitalization(.sentences)
                            
                            if focusVM.tileText.isEmpty {
                                T("Add intention", .caption)
                                    .padding(.horizontal, 16)
                                    .focused($intentionFocused)
                                    .submitLabel(.done)
                                    .allowsHitTesting(false)        // so taps go into the TextField
                            }
                        }
                        if shouldShowValidation {
                            ValidationCaption(state: vState, palette: p)
                        }
                    }
                    // Guidance + Messages (no Add/Begin here)
                    DynamicMessageAndActionArea(
                        focusVM: focusVM,
                        onRecalibrateNow: { focusVM.showRecalibrate = true }
                    )
                    .environmentObject(theme)
                    
                    // Centered countdown
                    if focusVM.phase == .running {
                        DynamicCountdown(
                            fVM: focusVM,
                            palette: p,
                            progress: Double(focusVM.countdownRemaining) / Double(TimerConfig.current.chunkDuration)
                        )
                        .frame(maxWidth: .infinity) // centers fixed-size content
                    }
                }
            }
            .background(p.background.ignoresSafeArea())
            .ignoresSafeArea(.keyboard, edges: .bottom)
            
            
            // Sheets
            .sheet(isPresented: $focusVM.showRecalibrate) {
                RecalibrationV(vm: recalibrationVM)
                // FIXME: which looks better:
                    .presentationDetents([.large])  // avoids "medium" overlap
                    .presentationDragIndicator(.visible)
                    .ignoresSafeArea()              // if the sheet edges are tight
                // FIXME: or this at line 150, replacing current:
                // Bottom inset: only when sheet is NOT showing
//                    .safeAreaInset(edge: .bottom) {
//                        if !focusVM.showRecalibrate { BottomComposer }
//                    }
            }
            // FIXME: or this option is a "no overlap at all" look
//            .fullScreenCover(isPresented: $focusVM.showRecalibrate) { RecalibrationV(vm: recalibrationVM) }

            
            // Bottom inset: slots + single CTA
            .safeAreaInset(edge: .bottom, spacing: 10) { BottomComposer }
//            .safeAreaInset(edge: .bottom) {  if !focusVM.showRecalibrate { BottomComposer }}
        }
    }
    
    // MARK: Bottom composer
    @ViewBuilder
    private var BottomComposer: some View {
        let completedSlotIndex: Int? = (focusVM.currentSessionChunk >= 1) ? 1 : nil  // slots = [second, first]
        VStack(spacing: 10) {
            // two rows, bottom fills first
            ForEach(0..<slots.count, id: \.self) { idx in
                let txt = slots[idx]
                let filled = (txt?.isEmpty == false)
                let tileIsCompleted = (completedSlotIndex == idx)
                let slotBg = filled ? p.surface.opacity(0.9) : p.surface.opacity(0.35)
                
                ZStack {
                    // card
                    RoundedRectangle(cornerRadius: 10, style: .continuous)
                        .fill(slotBg)
                        .overlay(
                            RoundedRectangle(cornerRadius: 10, style: .continuous)
                                .stroke(p.border, lineWidth: 1)
                        )
                        .frame(height: 50)
                        .contentShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
                        .overlay {
                            if diffNoColor && !filled {
                                RoundedRectangle(cornerRadius: 10, style: .continuous)
                                    .stroke(style: StrokeStyle(lineWidth: 1, dash: [5]))
                                    .foregroundStyle(p.border)
                            }
                        }
                    
                    // content
                    if let text = txt, !text.isEmpty {
                        HStack(spacing: 8) {
                            Text(text)
                                .lineLimit(1)
                                .minimumScaleFactor(0.9)
                                .foregroundStyle(tileIsCompleted ? p.text.opacity(0.55) : p.text)
                            
                            if tileIsCompleted {
                                Image(systemName: "checkmark.circle")
                                    .foregroundStyle(p.accent)
                                    .accessibilityHidden(true)
                            }
                        }
                            .padding(.horizontal, 8)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    } else {
                        Image(systemName: "plus")
                            .font(.headline)
                            .foregroundStyle(p.accent.opacity(0.6))
                            .accessibilityHidden(true)
                    }
                }
                .opacity(tileIsCompleted ? 0.7 : 1.0)
                .accessibilityElement(children: .combine)
                .accessibilityLabel(filled ? (tileIsCompleted ? "Intention completed" : "Intention") : "Empty slot")
                            .accessibilityHint(filled ? "" : "Add an intention above, then press Add.")
            }
            
            Button {
                Task { await focusVM.handlePrimaryTap() }
            } label: {
                T(ctaTitle, .action) .monospacedDigit()
            }
            .primaryActionStyle(screen: screen)
            .disabled(!focusVM.canPrimary)
        }
        .padding(.horizontal, 16)
        .padding(.bottom, 12)
        .background(.thinMaterial)
        .animation(.easeInOut(duration: 0.2), value: focusVM.tiles)
    }
 
    private var ctaTitle: String {
        focusVM.tiles.count < 2 ? "Add" : "Begin"
    }
    
    private var slots: [String?] {
           let first  = focusVM.tiles.indices.contains(0) ? focusVM.tiles[0].text : nil
           let second = focusVM.tiles.indices.contains(1) ? focusVM.tiles[1].text : nil
           return [second, first]
       }
   }

   // MARK: - Preview
#if DEBUG
   #Preview("Focus") {
       PreviewWrapper {
           FocusSessionActiveV(
               focusVM: PreviewMocks.focusSession,
               recalibrationVM: RecalibrationVM(haptics: NoopHapticsClient())
           )
           .previewTheme()
       }
   }
#endif
-e \n\n
=== ./intention/Features/Social/ShareService.swift ===
//
//  ShareService.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct ShareService: View {
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/"Hello, World!"/*@END_MENU_TOKEN@*/)
    }
}

#if DEBUG
#Preview {
    ShareService()
}
#endif
-e \n\n
=== ./intention/Features/History/HistoryV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct HistoryV: View {
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var viewModel: HistoryVM
    
    // UI State
    @State private var newTextTiles: [UUID: String] = [:]       /// Store new tile text per category using its `id` as key
    @State private var isOrganizing = false
    @State private var createdCategoryID: UUID?
    @State private var targetCategoryID: UUID?
    //
    @State private var showRenamePicker = false
    @State private var showDeletePicker = false
    @State private var showRenameSheet = false
    @State private var renameText = ""
    @State private var showDeleteConfirm = false
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    var body: some View {
        ZStack(alignment: .bottom) {
            ScrollView {
                Page(top: 4, alignment: .center){
                    header
                    categoriesList(p: p)
                    Spacer(minLength: 16)
                }
                .alert("Delete category?",
                       isPresented: $showDeleteConfirm) {
                    Button("Delete", role: .destructive) {
                        if let id = targetCategoryID { _ = viewModel.deleteCategory(id: id) }
                    }
                    Button("Cancel", role: .cancel) { }
                } message: {
                    Text("Tiles will be moved to Archive.")
                }
                
                // Sheet for renaming (iOS 16-friendly)
                .sheet(isPresented: $showRenameSheet) {
                    NavigationStack {
                        Form {
                            Section("New Name") {
                                TextField("Category name", text: $renameText)
                                    .textInputAutocapitalization(.words)
                                    .disableAutocorrection(true)
                            }
                        }
                        .navigationTitle("Rename")
                        .navigationBarTitleDisplayMode(.inline)
                        .toolbar {
                            ToolbarItem(placement: .cancellationAction) {
                                Button("Cancel") { showRenameSheet = false }
                            }
                            ToolbarItem(placement: .confirmationAction) {
                                Button("Save") {
                                    if let id = targetCategoryID {
                                        viewModel.renameCategory(id: id, to: renameText.trimmingCharacters(in: .whitespacesAndNewlines))
                                    }
                                    showRenameSheet = false
                                }
                                .disabled(renameText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                            }
                        }
                    }
                    .presentationDetents([.medium])
                }
            }
            
            /// Kept outside ScrollView - gives space to GeometryReader
            organizerOverlay
        }
        .safeAreaInset(edge: .bottom, spacing: 10) { VStack(spacing: 10){ undoToast; capToast } }
        .animation(.easeInOut(duration: 0.2), value: viewModel.lastUndoableMove != nil)
        .toolbar { historyToolbar }
        .navigationBarTitleDisplayMode(.inline) // optional, for a tighter header
    }
    
    /// Splitting subviews
    @ViewBuilder
    private var header: some View {
        T("Tap a category title to edit and group.", .body)
            .foregroundStyle(p.textSecondary)
            .accessibilityAddTraits(.isHeader)
    }
    
    @ViewBuilder
    private func categoriesList(p: ScreenStylePalette) -> some View {
        LazyVStack(alignment: .leading, spacing: 16) {
            ForEach($viewModel.categories, id: \.id) { $categoryItem in   // mutate individual category fields
                /// Disables inputs and editing/ Provides subtle "card" treatment
                /// Derive isArchive from the VM
                let isArchive = categoryItem.id == viewModel.archiveCategoryID
                
                CategorySection(
                    categoryItem: $categoryItem,
                    palette: p,
                    fontTheme: theme.fontTheme,
                    newTextTiles: $newTextTiles,
                    saveHistory: { viewModel.saveHistory()  },
                    isArchive: isArchive,
                    autoFocus: createdCategoryID == categoryItem.id
                )
            }
        }
    }
    
    @ViewBuilder private var undoToast: some View {
        if let move = viewModel.lastUndoableMove {
            BottomToast {
                HStack {
                    T("Moved: \(move.tile.text)", .caption)
                    Spacer()
                    Button( action: { viewModel.undoLastMove() }) {
                        T("Undo", .action)
                    }
                    .secondaryActionStyle(screen: .history)
                }
            }
            .padding(.horizontal, 16)
            .transition(.move(edge: .bottom).combined(with: .opacity))
        } else {
            EmptyView()
        }
    }
    
    @ViewBuilder private var capToast: some View {
        if viewModel.tileLimitWarning {
            BottomToast {
                HStack {
                    T("Archive capped at 200; oldest items were removed.", .caption)
                    Spacer()
                    Button { viewModel.tileLimitWarning = false } label: { T("OK", .action) }
                        .secondaryActionStyle(screen: .history)
                }
            }
            .padding(.horizontal, 16)
            .task {
                try? await Task.sleep(nanoseconds: 3_000_000_000)
                viewModel.tileLimitWarning = false
            }
            .transition(.move(edge: .bottom).combined(with: .opacity))
        }
    }
    
    
    /// Organizer show as an overlay so it doesn't fight ScrollView dimensions
    @ViewBuilder private var organizerOverlay: some View {
        if isOrganizing {
            GeometryReader { proxy in
                let targetH = min(proxy.size.height * 0.75, 600)    // Use available height, avoid UIScreen.*
                
                VStack(spacing: 12) {
                    T("Organize Tiles", .section)
                        .padding(.top, 12)
                    
                    TileOrganizerWrapper(
                        categories: $viewModel.categories,
                        onMoveTile: { tile, fromID, toID in
                            Task { @MainActor in                /// Using the throwing async core
                                do { try await viewModel.moveTileThrowing(tile, from: fromID, to: toID) }
                                catch { viewModel.lastError = error }
                            }
                        },
                        onReorder: { newTiles, categoryID in
                            viewModel.updateTiles(in: categoryID, to: newTiles)
                            // save (debounced by VM if possible)
                            viewModel.saveHistory()
                        }
                    )
                    .frame(height: targetH)
                    .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                    .shadow(radius: 3, y: 1)
                    
                    
                    Button { viewModel.flushPendingSaves(); withAnimation { isOrganizing = false }} label: {
                        T("Done", .section)
                    }
                    .secondaryActionStyle(screen: .history)
                    .padding(.bottom, 12)
                }
                //FIXME: use my button of this?
                .padding(12)
                .background(.ultraThinMaterial)
                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
                .padding(.horizontal, 16)
                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .bottom)
                .transition(.move(edge: .bottom).combined(with: .opacity))
            }
            .ignoresSafeArea(.keyboard) // keep organizer steady while keyboard shows
            .zIndex(1)
        }
    }
    
    @ToolbarContentBuilder private var historyToolbar: some ToolbarContent {
        ToolbarItemGroup(placement: .topBarTrailing) {
            
            // Organize / Done toggle
            Button {
                if isOrganizing { viewModel.flushPendingSaves() }
                withAnimation { isOrganizing.toggle() }
            } label: {
                Label {
                    T(isOrganizing ? "Done" : "Organize", .section)
                } icon: {
                    Image(systemName: "arrow.up.arrow.down")
                }
            }
            .secondaryActionStyle(screen: screen)
            
            // More menu
            Menu {
                Button {
                    // If only one user cat, go straight to rename sheet; else pick first
                    if let only = viewModel.userCategoryIDs.only {
                        targetCategoryID = only
                        renameText = viewModel.name(for: only)
                        showRenameSheet = true
                    } else {
                        showRenamePicker = true
                    }
                } label: { T("Rename Category", .section) }
                
                
                Button {
                    // If only one user cat, confirm delete directly; else choose which
                    if let only = viewModel.userCategoryIDs.only {
                        targetCategoryID = only
                        showDeletePicker = true
                    } else {
                        showDeletePicker = true
                    }
                } label: { T("Delete Category", .section) }
                
                Divider()
                
                Button {
                    if let id = viewModel.addEmptyUserCategory() { createdCategoryID = id }
                } label: { T("Add Category", .section) }
                    .disabled(!viewModel.canAddUserCategory())
                
            } label: {
                Label { T("More", .section) } icon: { Image(systemName: "ellipsis.circle") }
            }
            .secondaryActionStyle(screen: screen)
            
            // Rename picker
            .confirmationDialog("Choose category to rename",
                isPresented: $showRenamePicker,
                titleVisibility: .visible
            ) {
                ForEach(viewModel.userCategoryIDs, id: \.self) { id in
                    let label = viewModel.name(for: id).ifEmpty("Untitled")
                    Button(label) {
                        targetCategoryID = id
                        renameText = viewModel.name(for: id)
                        showRenameSheet = true
                    }
                }
                Button("Cancel", role: .cancel) { }
            }

            // Delete picker (note the role initializer)
            .confirmationDialog("Choose category to delete",
                isPresented: $showDeletePicker,
                titleVisibility: .visible
            ) {
                ForEach(viewModel.userCategoryIDs, id: \.self) { id in
                    let label = viewModel.name(for: id).ifEmpty("Untitled")
                    Button(role: .destructive) {
                        targetCategoryID = id
                        showDeleteConfirm.toggle()
                    } label: {
                        Text(label)
                    }
                }
                Button("Cancel", role: .cancel) { }
            }

        }
    }
}

// UUID helper
extension Array {
    var only: Element? { count == 1 ? first : nil }
}

extension String {
    func ifEmpty(_ replacement: String) -> String { isEmpty ? replacement : self }
}
    
    // MARK: extracted CategorySectionRow
    /// Extracted row to simplify type-checking
private struct CategorySectionRow: View {
    @Binding var categoryItem: CategoriesModel
    let palette: ScreenStylePalette
    let fontTheme: AppFontTheme
    @Binding var newTextTiles: [UUID: String]
    let saveHistory: () -> Void
    let isArchive: Bool
    let autoFocus: Bool

    var body: some View {
        let background = isArchive ? palette.surface : .clear
        let stroke     = isArchive ? palette.border  : .clear

        CategorySection(
            categoryItem: $categoryItem,
            palette: palette,
            fontTheme: fontTheme,
            newTextTiles: $newTextTiles,
            saveHistory: saveHistory,
            isArchive: isArchive,
            autoFocus: autoFocus
        )
        .background(background)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(stroke, lineWidth: 1)
        )
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }
}

                            

                        
//                        Spacer(minLength: 16)
//                    }       //FIXME: IS LazyVStack screwing up the look?
//                    if let error = viewModel.lastError {
//                        ErrorOverlay(error: error) {
//                            viewModel.lastError = nil
//                        }
//                        .zIndex(1)  // Keeps the above the context of it's error
//                    }
//                }
//            }
//            .safeAreaInset(edge: .bottom, spacing: 10) {
//                if let move = viewModel.lastUndoableMove {
//                    BottomToast {
//                        HStack {
//                            Text("Moved: \(move.tile.text)").font(.footnote)
//                            Spacer()
//                            Button("Undo") {    viewModel.undoLastMove()    }
//                        }
//                    }
//                    .padding(.horizontal, 16)
//                    .transition(.move(edge: .bottom).combined(with: .opacity))
//                }
//            }
//        }
////        .friendlyAnimatedHelper(viewModel.lastUndoableMove != nil)
//    }
//}

// Mock/ test data prepopulated
#if DEBUG
#Preview("Populated Preview History") {
    MainActor.assumeIsolated {
        let historyVM = HistoryVM(persistence: PersistenceActor())
        historyVM.ensureGeneralCategory()
        
        if let generalID = historyVM.categories.first?.id {
            historyVM.addToHistory(TileM(text: "Do item"), to: generalID)
            historyVM.addToHistory(TileM(text: "Get other item"), to: generalID)
        }

        return PreviewWrapper {
            HistoryV(viewModel: historyVM)
                .previewTheme()
        }
    }
}
#endif
-e \n\n
=== ./intention/Features/History/ArchiveActor.swift ===
//
//  ArchiveActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/26/25.
//

import Foundation
// dedicated actor to handle offloading old tiles
// receives a [CategoriesModel], trims tiles beyond the 200 tile cap and persist

/// Purpose: points to a tile where it lives without copying text or timeStamp. Different than TileM (the full model) and different than TileOrganizerVM (a ViewModel for UI organizing)
/// Identity used for offloading between actors
struct TileRef: Hashable, Codable, Sendable {
    let categoryID: UUID
    let tileID: UUID
}

/// Purpose: archives tiles into persistent list
/// dedicated, thread-safe manager - handles offloading into archive from "live" categories dedicated, thread-safe manager for archiving tiles. It handles offloading old tiles from live categories to a persistent archive, ensuring the total count of tiles remains below a specified limit.
/// The **only store of Archive tiles** (authoritative for Archive contents

actor ArchiveActor {
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let archiveKey = "archivedTiles"
//
//    struct OffloadResult: Sendable, Codable {
//        let archived: [TileM]           /// full tiles archived first, and in the bottom most location of the archive
//        let refs: [TileRef]             /// exact locations the tiles came from
//    }
//    
//    /// Offload tiles to archive storage, top-first, **excluding** Archive category
//    /// - Parameters:
//    ///     - categories: to consider
//    ///     - maxTiles: cap for *live* tiles (General + user categories)
//    /// - Returns: OffloadResult with exact refs & tiles archived; Empty if no overflow
//    func offloadOldTiles(from categories: [CategoriesModel], maxTiles: Int) async throws {
//        // 1) Flatten only non-Archive categories (HistoryVM will pass those; this is defensive)
//        let live = categories
//        // 2) oldest/bottom first across live times
//        let all = live.flatMap(\.tiles).sorted { $0.timeStamp < $1.timeStamp }
//        let overflowCount = max(0, all.count - maxTiles)
//        guard overflowCount > 0 else { return }
//        
//        // the oldest overflow that must be offloaded
//        let toArchive = Array(all.prefix(overflowCount))  // take the oldest overflow
//
//        // 3) Append to existing archive (keep newest at top in storage)
//        let existing = await loadArchivedTiles()
//        var combined = toArchive.reversed() + existing     // put “newly archived” on top
//        if combined.count > maxTiles {
//            combined.removeLast(combined.count - maxTiles) // drop oldest from bottom
//        }
//
//        let data = try encoder.encode(combined)
//        UserDefaults.standard.set(data, forKey: archiveKey)
//        #if DEBUG
//        debugPrint("ArchiveActor: Archived \(toArchive.count) tiles. Archive total: \(combined.count)")
//        #endif
//    }
    
    
    // Write/load archived tiles for testing or restoration.
    func loadArchivedTiles() async -> [TileM] {
        guard let data = UserDefaults.standard.data(forKey: archiveKey) else { return [] }
        do { return try decoder.decode([TileM].self, from: data) }
        catch { debugPrint("ArchiveActor: decode archived tiles failed:", error); return [] }
    }
    
    // Update on every Archive mutation
    func saveArchivedTiles(_ tiles: [TileM]) async {
        if let data = try? encoder.encode(tiles) {
            UserDefaults.standard.set(data, forKey: archiveKey)
        }
    }
    
    // Clear archive for testing/reset
    func clearArchive() { UserDefaults.standard.removeObject(forKey: archiveKey) }
}
-e \n\n
=== ./intention/Features/History/HistoryVM.swift ===
//
//  HistoryVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

enum HistoryError: Error, Equatable, LocalizedError {
    case categoryNotFound, historyNotLoaded, saveHistoryFailed, moveFailed

    var errorDescription: String? {
        switch self {
        case .categoryNotFound: return "Category not found."
        case .historyNotLoaded: return "History not loaded."
        case .saveHistoryFailed: return "Could not save history."
        case .moveFailed: return "Tile move failed."
        }
    }
}

/// VM decides *when*, Persistence decides *how*
///         HistoryVM stays the **orchestrator** (decides *when* to persist
/// Single source of truth for category IDs
/// Deinit/cleanup: rely on the lifecycle flush you already added (scenePhase .inactive / .background) and your explicit UI boundaries (e.g., “Done” in organizing)
@MainActor
final class HistoryVM: ObservableObject {   
    @Published var categoryValidationMessages: [UUID: [String]] = [:]           /// Validate category text changes
    @Published var categories: [CategoriesModel] = []
    @Published var tileLimitWarning: Bool = false
    @Published var lastUndoableMove: (tile: TileM, from: UUID, to: UUID)? = nil
    @Published var lastError: Error?
    
    private let persistence: any Persistence
    private let archiveActor = ArchiveActor()
    private let storageKey = "categoriesData"
    private let tileSoftCap = 200
    private var pendingSnapshot: [CategoriesModel]? = nil
    private var debouncedSaveTask: Task<Void, Never>? = nil     ///Coalesced save task; only latest survives
    private var lastSavedSignature: Int = 0                     /// VM computes a lightweight signature and coalesces writes
    private let saveDebouncedDelayNanos: UInt64 = 300_000_000   /// 300 ms
    
    
    /// HistoryVM owns IDs
    @AppStorage("generalCategoryID") private var generalCategoryIDString: String = ""
    @AppStorage("archiveCategoryID") private var archiveCategoryIDString: String = ""
    
    var generalCategoryID: UUID {
        get { UUID(uuidString: generalCategoryIDString) ?? { let u = UUID(); generalCategoryIDString = u.uuidString; return u }() }
        set { generalCategoryIDString = newValue.uuidString }
    }
    var archiveCategoryID: UUID {
        get { UUID(uuidString: archiveCategoryIDString) ?? { let u = UUID(); archiveCategoryIDString = u.uuidString; return u }() }
        set { archiveCategoryIDString = newValue.uuidString }
    }
    
    
    // AppStorage wrapper (private, not accessed directly from the view)
    // since `historyVM` is injected into `FocusSessionVM` at startup via `RootView`
    //  the `FocusSessionVM` `func checkSessionCompletion()`'s `addSession(tiles)`
    //  method successfully archives each 2-tile session in and survives app restarts:

    /// `saveHistory` calls keep storage synced, the program will rehydrate using `loadHistory()` on launch only, don't watch `categoryData`
    // Don't use any `onChange`
    // `InMemoryPersistence conforms `Persistence` protocol - the VM depends on *protocol*, not the concrete actor
    init(persistence: any Persistence) {
        self.persistence = persistence
        Task {  await loadHistory() }
    }
    
    private func loadHistory() async {
        do {
              // 1) Load categories from disk
              if let loaded: [CategoriesModel] = try await persistence.readIfExists([CategoriesModel].self, from: storageKey) {
                  self.categories = loaded
              } else {
                  self.categories = []
              }

              // 2) Reconcile built-in IDs by name (if present in loaded data)
              if let g = categories.first(where: { $0.persistedInput == "General" }) {
                  generalCategoryID = g.id
              }
              if let a = categories.first(where: { $0.persistedInput == "Archive" }) {
                  archiveCategoryID = a.id
              }

              // 3) Ensure both built-ins exist using the reconciled IDs
              if !categories.contains(where: { $0.id == generalCategoryID }) {
                  categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
              }
              if !categories.contains(where: { $0.id == archiveCategoryID }) {
                  categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
              }

              // 4) Hydrate archive tiles (now that the archive ID is canonical)
              let archived = await archiveActor.loadArchivedTiles()
              if let idx = categories.firstIndex(where: { $0.id == archiveCategoryID }) {
                  categories[idx].tiles = archived
                  applyCaps(afterInsertingIn: idx)
              }

              // 5) Persist if anything changed during steps 2–4
            // save the sanitized (Archive-empty) snapshot
              saveHistory()

          } catch {
              debugPrint("[HistoryVM.loadHistory] error:", error)
              await MainActor.run { self.lastError = error }
          }
    }
    
    func reconcileAndEnsureBuiltIns() {
        // 1) If categories already contain built-ins, prefer those IDs and write them back to AppStorage.
        if let g = categories.first(where: { $0.persistedInput == "General" }) {
            generalCategoryID = g.id
        }
        if let a = categories.first(where: { $0.persistedInput == "Archive" }) {
            archiveCategoryID = a.id
        }

        // 2) Ensure both exist using the canonical IDs (lazily created if empty).
        if !categories.contains(where: { $0.id == generalCategoryID }) {
            categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
        }
        if !categories.contains(where: { $0.id == archiveCategoryID }) {
            categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
        }
        // the debounced/immediate server
        saveHistory()
    }
    
    // sanitizedForSave() and performSaveIfChanged - Persist categories without the Archive tiles. Hydrate Archive tiles on load from ArchiveActor
    private func sanitizedForSave(_ cats: [CategoriesModel]) -> [CategoriesModel] {
        cats.map { category in
            var copy = category
            if category.id == archiveCategoryID { copy.tiles = [] }     // keep Archive empty in categoriesData
            return copy
            
        }
    }
    // Writes only if content changed since last success - if `snapshot` is nil, uses live `categories`
    private func performSaveIfChanged(_ snapshot: [CategoriesModel]? = nil) async {
        let raw = snapshot ?? categories
        let toWrite = sanitizedForSave(raw)
        let signature = saveSignature(for: toWrite)               // compare sanitized - not raw
        guard signature != lastSavedSignature else { return }
        do {
            try await persistence.write(toWrite, to: storageKey)
            lastSavedSignature = signature
        } catch {
            debugPrint("[HistoryVM.performSaveIfChanged] error: ", error)
            await MainActor.run { self.lastError = HistoryError.saveHistoryFailed }
        }
    }
    private func saveSignature(for categories: [CategoriesModel]) -> Int {
        var acc = categories.count
        for cat in categories {
            acc = acc &* 31 &+ cat.id.hashValue &+ cat.tiles.count  //// Mixes ID + tile count
        }
        return acc
    }
    
    // MARK: - Sets automatic "General" category aka "bootstrapping"
    func ensureGeneralCategory(named name: String = "General") {
        let generalID = generalCategoryID
        if !categories.contains(where: { generalCategoryItem in generalCategoryItem.id == generalID }) {
            let new = CategoriesModel(id: generalID, persistedInput: name)
            categories.insert(new, at: 0)
            debugPrint("HistoryVM.ensureGeneralCategory: created 'General'")
            saveHistory()
        }
    }
    
    // MARK: - Sets automatic Archive category aka "bootstrapping"
    func ensureArchiveCategory(named name: String = "Archive") {
        let archiveID = archiveCategoryID
        if !categories.contains(where: { archiveCategoryItem in archiveCategoryItem.id == archiveID }) {
            let new = CategoriesModel(id: archiveID, persistedInput: name)
            categories.insert(new, at: 0)
            debugPrint("HistoryVM.ensureArchiveCategory: created 'Archive'")
            saveHistory()
        }
    }

    
    // MARK: - Non-throwing convenience (fire-and-forget)
    /// Non-throwing wrapper, background with a UI signal; catch internally, debugPrints, sets VM lasterror; saveHistory() calls saveHistoryThrowing() inside a Task
    /// Save the current categories array -> wrapper of PersistenceActor.saveHistory
    /// Public entry: schedule or force-save now.
    /// Call with `immediate: true` when the user completes an explicit action (e.g., Done, drop ended).
    func saveHistory(immediate: Bool = false) { //wrapper
        if immediate {
            let snapshot = categories               // Capture current state and write right away
            pendingSnapshot = nil
            debouncedSaveTask?.cancel()
            debouncedSaveTask = nil
            Task { await performSaveIfChanged(snapshot) }
        } else {
            scheduleDebouncedSave()
        }
    }
    
    private func scheduleDebouncedSave() {
        let snapshot = categories       // Capture now; UI may keep mutating
        pendingSnapshot = snapshot

        debouncedSaveTask?.cancel()
        debouncedSaveTask = Task { [weak self, snapshot ] in
        // Coalesce bursts of calls into one
            guard let self else { return }
            try? await Task.sleep(nanoseconds: saveDebouncedDelayNanos)
            await self.performSaveIfChanged(snapshot)
            await MainActor.run { self.pendingSnapshot = nil }
        }
    }
    
    // MARK: - Forces any pending debounced save to run now
    /// Cancels the debounce and forces the latest pending snapshot (or live state) to disk now
    func flushPendingSaves() {
        // Runs any pending debounce, immediate save and cancel
        let snapshot = pendingSnapshot
        pendingSnapshot = nil
//        if debouncedSaveTask != nil {
            debouncedSaveTask?.cancel()
            debouncedSaveTask = nil
        Task { [snapshot] in await performSaveIfChanged(snapshot) } // uses live categories if nil
    }
    
    // MARK: - Add a tile to a specific category (non-throwing convenience)
    func addToHistory(_ newTile: TileM, to categoryID: UUID) {
        guard let index = categories.firstIndex(where: {  categoryItem in       // $0.id == categoryID
            categoryItem.id == categoryID
        }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            self.lastError = HistoryError.categoryNotFound
            return
        }
        /// Newest-first for UI display
        categories[index].tiles.insert(newTile, at: 0)
        
        /// Enforcing Archive=200 cap or General/selected=10
        applyCaps(afterInsertingIn: index)
        
        /// Once *only* tiles equal 200, offload oldest tile added, from the bottom
//        let totalTileCount = categories.reduce(0) { $0 + $1.tiles.count }
//        if totalTileCount > tileSoftCap {
//            limitCheck()
//        }
        
        // saveHistory() is inside addToHistory() to persist automatically
        saveHistory()
        /// If you do want a click here later, trigger it from the view after a successful action using your HapticsService env object, not from the VM
    }
    
    
    // MARK: - Add a new category
    func addCategory(persistedInput: String){
        let newCategory = CategoriesModel(persistedInput: persistedInput)
        categories.append(newCategory)
        saveHistory()
    }
    
    // MARK: Category logic rules where the data lives
    /// Excluding built-ins, user-defined category limits
    var userDefinedCategoryCount: Int {
        categories.filter { $0.id != generalCategoryID && $0.id != archiveCategoryID }.count
    }
    
    func canAddUserCategory(limit: Int = 2) -> Bool {
        userDefinedCategoryCount < limit
    }
    /// Adds an empty user category if allowed and returns its id (for autofocus)
    @discardableResult
    func addEmptyUserCategory(limit: Int = 2) -> UUID? {
        guard canAddUserCategory(limit: limit) else { return nil }
        let new = CategoriesModel(persistedInput: "")
        categories.append(new)
        saveHistory()
        return new.id
    }
    /// Rename category and persist. Validates and coalesces via saveHistory().
       func renameCategory(id: UUID, to newName: String) {
           guard let idx = categories.firstIndex(where: { $0.id == id }) else {
               lastError = HistoryError.categoryNotFound
               return
           }
           categories[idx].persistedInput = newName
           validateCategory(id: id, title: newName)
           saveHistory()
       }

       /// Delete a user-defined category. Tiles are moved to Archive first (safe).
       @discardableResult
       func deleteCategory(id: UUID) -> Bool {
           // prevent deleting built-ins
           guard id != generalCategoryID, id != archiveCategoryID else { return false }
           guard
               let delIdx = categories.firstIndex(where: { $0.id == id }),
               let archIdx = categories.firstIndex(where: { $0.id == archiveCategoryID })
           else {
               lastError = HistoryError.categoryNotFound
               return false
           }

           // Move tiles (newest-first) to Archive top, then enforce caps
           let moving = categories[delIdx].tiles
           if !moving.isEmpty {
               categories[archIdx].tiles.insert(contentsOf: moving, at: 0)
               applyCaps(afterInsertingIn: archIdx)
               let arch = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
               Task { await archiveActor.saveArchivedTiles(arch) }
           }

           categories.remove(at: delIdx)
           saveHistory()
           return true
       }

       /// Convenience: list of user-defined categories (not General/Archive)
       var userCategoryIDs: [UUID] {
           categories
               .map(\.id)
               .filter { $0 != generalCategoryID && $0 != archiveCategoryID }
       }

       func name(for id: UUID) -> String {
           categories.first(where: { $0.id == id })?.persistedInput ?? ""
       }
    
    // MARK: - Validation function to be called from the view
    func validateCategory(id: UUID, title: String) {
        let messages = title.categoryTitleMessages
        if messages.isEmpty {
            categoryValidationMessages.removeValue(forKey: id)
        } else {
            categoryValidationMessages[id] = messages
        }
    }
    
    
    // MARK: valid target to call to move tiles within categories
    // Caps enforced
    func moveTile(_ tile: TileM, from fromID: UUID, to toID: UUID) async throws {
        guard
            let fromIndex = categories.firstIndex(where: { $0.id == fromID }),
            let toIndex = categories.firstIndex(where: { $0.id == toID }),
            let tileIndex = categories[fromIndex].tiles.firstIndex(of: tile)
        else {
            debugPrint("Move failed: could not locate source or destination HistoryVM.moveTile")
            throw HistoryError.moveFailed
        }
        
        let movingTile = categories[fromIndex].tiles.remove(at: tileIndex)
        // Insert at top - consistent newest-first UI
        categories[toIndex].tiles.insert(movingTile, at: 0)
        
        // Enforce per-category cap (Archive = 200, General/selected = 10
        applyCaps(afterInsertingIn: toIndex)
        
        let generator = UIImpactFeedbackGenerator(style: .medium)
        generator.impactOccurred()
        
        try await saveHistoryThrowing()
        lastUndoableMove = (movingTile, fromID, toID)
        
        /// Clear undo after 3s
        Task { @MainActor in
            try? await Task.sleep(nanoseconds: 3_000_000_000)
            self.lastUndoableMove = nil         // clear undo after 3s if not acted upon (via toast)
        }
    }
    
    func undoLastMove() {
        guard let move = lastUndoableMove else { return }
        Task {
            do {
                try await moveTileThrowing(move.tile, from: move.to, to: move.from)
                self.lastUndoableMove = nil
            } catch {
                debugPrint("[HistoryVM.undoLastMove] error: ", error)
                self.lastError = error
            }
        }
    }
    // Category title change, enforce caps when replacing a category’s tiles (organizer reorder)
    func updateTiles(in categoryID: UUID, to newTiles: [TileM]) {
        if let index = categories.firstIndex(where: { $0.id == categoryID }) {
            categories[index].tiles = newTiles
            /// does the Archive=200 / General+2=10 trims
            applyCaps(afterInsertingIn: index)
            saveHistory()       /// Persist change
        }
    }
    
    /// Cap rules for all categories
    private func applyCaps(afterInsertingIn idx: Int){
        let catID = categories[idx].id
        
        // 1) Archive cap: 200 (drop bottom)
        if catID == archiveCategoryID {
            let overflow = categories[idx].tiles.count - tileSoftCap    // tileSoftCap == 200
            if overflow > 0 {
                categories[idx].tiles.removeLast(overflow)
                tileLimitWarning = true                             // An FYI for the user
            }
            // Mirror out to ArchiveActor to keep it authoritative as archive writer/updater
            let intoArchive = categories[idx].tiles
            Task { await archiveActor.saveArchivedTiles(intoArchive) }
            return
        }

        // 2) Build the dynamic "capped@10" set: General + first two user-defined categories
        //    (user-defined = not General, not Archive). Uses current array order.
        let userIDs = categories
            .map(\.id)
            .filter { $0 != generalCategoryID && $0 != archiveCategoryID }

        var capped10 = Set<UUID>()
        capped10.insert(generalCategoryID)
        for id in userIDs.prefix(2) { capped10.insert(id) }

        if capped10.contains(catID) {
            let overflow = categories[idx].tiles.count - 10
            if overflow > 0 { categories[idx].tiles.removeLast(overflow) }
        }
    }
    
    // MARK: reset all categories
    func clearHistory() {
        categories = []     // clears model first
        saveHistory()       // persists a cleared list
        Task {  await persistence.clear(storageKey); await archiveActor.clearArchive() }   // clear storage safely: see PersistenceActor
    }

    
    // MARK: Helpers + Throwing Core
    
    /// Throwing immediate save - also persist sanitized data
    func saveHistoryThrowing() async throws { //core
        try await persistence.write(sanitizedForSave( categories ), to: storageKey)
    }
    
    func addToHistoryThrowing(_ tile: TileM, to categoryID: UUID) async throws {
        guard let index = categories.firstIndex(where: {  categoryItem in
            categoryItem.id == categoryID
        }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            throw HistoryError.categoryNotFound
        }
        categories[index].tiles.insert(tile, at: 0)
        try await saveHistoryThrowing()
    }
    
    func moveTileThrowing(_ tile: TileM, from fromID: UUID, to toID: UUID) async throws {
        guard
            let fromIndex = categories.firstIndex(where: { $0.id == fromID }),
            let toIndex = categories.firstIndex(where: { $0.id == toID }),
            let tileIndex = categories[fromIndex].tiles.firstIndex(of: tile)
        else {
            debugPrint("HistoryVM.moveTileThrowing //core] Category ID not found. Tile not added.")
            throw HistoryError.moveFailed
        }
        let moving = categories[fromIndex].tiles.remove(at: tileIndex)
        
        // Keep newest at the top for UI when moving *into* the Archive
        categories[toIndex].tiles.insert(moving, at: 0)
        /// single source of truth for all caps
        applyCaps(afterInsertingIn: toIndex)
        // Mirror in places that move tiles into Archive
        if fromID == archiveCategoryID || toID == archiveCategoryID {
            let intoArchive = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
            Task { await archiveActor.saveArchivedTiles(intoArchive) }
        }
        try await saveHistoryThrowing()
    }
    
    func autoSaveIfNeeded() {
        Task {
            do { try await saveHistoryThrowing()    }
            catch {
                debugPrint("[HistoryVM.autoSaveIfNeeded] error: ", error)
                self.lastError = error
            }
        }
    }
}
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationKind.swift ===
//
//  RecalibrationKind.swift
//  intention
//
//  Created by Benjamin Tryon on 9/3/25.
//


import Foundation

enum RecalibrationKind: String, Codable, Hashable {
    case breathing, balancing
}

struct RecalibrationRecord: Codable, Identifiable, Equatable {
    let id: UUID
    let date: Date
    let kind: RecalibrationKind
    let durationSeconds: Int
}
-e \n\n
=== ./intention/Features/Recalibration/BalanceSideDots.swift ===
//
//  BalanceSideDots.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BalanceSideDots: View {
    let activeIndex: Int   // 0 = Left, 1 = Right
    let p: ScreenStylePalette

    var body: some View {
        HStack(spacing: 16) {
            dot(label: "Left",  isActive: activeIndex == 0)
            dot(label: "Right", isActive: activeIndex == 1)
        }
        .frame(maxWidth: .infinity)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(activeIndex == 0 ? "Left foot" : "Right foot")
    }

    private func dot(label: String, isActive: Bool) -> some View {
        HStack(spacing: 6) {
            Circle()
                .fill(isActive ? p.accent : p.border)
                .frame(width: isActive ? 10 : 8, height: isActive ? 10 : 8)
                .overlay(Circle().stroke(p.border, lineWidth: isActive ? 0 : 1))
                .animation(.spring(response: 0.22, dampingFraction: 0.85), value: isActive)
            Text(label)
                .font(.footnote.weight(isActive ? .semibold : .regular))
                .foregroundStyle(isActive ? p.text : p.textSecondary)
        }
    }
}
-e \n\n
=== ./intention/Features/Recalibration/BreathingPhaseGuide.swift ===
//
//  BreathingPhaseGuide.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BreathingPhaseGuide: View {
    @EnvironmentObject var theme: ThemeManager
    
    let phases: [String]
    let activeIndex: Int
    let p: ScreenStylePalette
    
    var body: some View {
        HStack(spacing: 10){
            ForEach(phases.indices, id: \.self) { i in
                Text(phases[i])
                    .font(.footnote.weight(i == activeIndex ? .semibold : .regular))
                    .padding(.horizontal, 10).padding(.vertical, 6)
                    .background(
                        Capsule().fill(i == activeIndex ? p.surface.opacity(0.9) : .clear)
                        )
                    .overlay(
                        Capsule().stroke(i == activeIndex ? p.border : .clear, lineWidth: 1)
                    )
                    .foregroundStyle(i == activeIndex ? p.text : p.textSecondary)
                    .scaleEffect(i == activeIndex ? 1.06 : 1.0)
                    .animation(.spring(response: 0.22, dampingFraction: 0.85), value: activeIndex)
                    .accessibilityLabel("\(phases[i])\(i == activeIndex ? ", current" : "")")
            }
        }
        .frame(maxWidth: .infinity)
    }
}
-e \n\n
=== ./intention/Features/Recalibration/RecalibrateV.swift ===
//
//  RecalibrateV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

extension View {
    func forceLabelWhite() -> some View { self.foregroundStyle(.white).tint(.white) }
}

struct RecalibrationV: View {
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var vm: RecalibrationVM
    @State private var breathingChoice: Int = 2
    @State private var balancingChoice: Int = 2
    
    // Tunable presets users expect: quick, obvious, one tap.
    private let breathePreset = 60   // 1 min
    private let balancePreset = 60   // 1 min
    
    private let screen: ScreenName = .recalibrate
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    var body: some View {
        ScrollView {
                Page {
                    // H1 centered; prose left-aligned = calmer eye path
                    T("Reset & Recalibrate", .largeTitle).underline()
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.top, 12)
                    
                    // Supporting copy: left-aligned, subdued
                    T("Short resets help you start your next 20-minute focus chunk fresh.", .body)
                        .foregroundStyle(p.textSecondary)
                    
                    T("Choose one below:", .caption)
                        .foregroundStyle(p.textSecondary)

                    
                    actionArea                          // the ONLY CTA/timer block
                    
                    // Lightweight guidance
                    if vm.phase == .idle, let theMode = vm.mode {
                        InstructionList( items: theMode.instructions, p: p, theme: theme )
                            .padding(.top, 8)
                    }
                    
                    // Live indicators
                    if vm.mode == .balancing {
                        if !vm.eyesClosedMode {
                            Text(vm.promptText) // “Switch feet” flashes briefly each minute
                                .font(.title3).fontWeight(.semibold)
                        }
                        BalanceSideDots(activeIndex: vm.balancingPhaseIndex, p: p)
                            .padding(.top, 6)
                    } else if vm.mode == .breathing, vm.phase != .idle {
                        BreathingPhaseGuide(
                            phases: vm.breathingPhases,
                            activeIndex: vm.breathingPhaseIndex,
                            p: p
                        )
                        .padding(.top, 6)
                    }
                }
            }
            .background(p.background.ignoresSafeArea())
            .task { breathingChoice = vm.currentBreathingMinutes }
            .presentationDetents([.fraction(0.4), .medium])   // iOS 16-friendly
            .presentationDragIndicator(.visible)
            .overlay {
                if let err = vm.lastError {
                    ErrorOverlay(error: err) { vm.lastError = nil }
                }
            }
    }
        
        // MARK: Helpers
        private var PresetPicker: some View {
            HStack(spacing: 8){
                T("Breathing length", .caption).foregroundStyle(.secondary)
                Picker("", selection: $breathingChoice) {
                    Text("2m").tag(2); Text("3m").tag(3); Text("4m").tag(4)
                }
                .pickerStyle(.segmented)
                .frame(maxWidth: 220)
            }
            .onChange(of: breathingChoice) { new in
                do { try vm.setBreathingMinutes(new) } catch { vm.lastError = error }
            }
        }
    private var PresetPickerBal: some View {
        HStack(spacing: 8){
            Toggle (isOn: $vm.eyesClosedMode) {
                T("Eyes-closed expert mode", .caption).foregroundStyle(.secondary)
            }
                .toggleStyle(.switch)
//            Picker("", selection: $balancingChoice) {
//                Text("Yes").tag(2); Text("No").tag(3)
//            }
//            .pickerStyle(.segmented)
            .frame(maxWidth: 320)
            
        }
        .onChange(of: balancingChoice) { new in
            do { try vm.setBalancingMinutes(new) } catch { vm.lastError = error }
        }
    }
        
        @ViewBuilder
           private var actionArea: some View {
               switch vm.phase {
               case .idle:
                   VStack(spacing: 12) {
                       if vm.phase == .idle { PresetPicker }   // 2m / 3m / 4m
                       Button {
                           vm.performAsyncAction { try await vm.start(mode: .breathing) }
                       } label: { T("Breathing", .action).foregroundColor(.white) }
                       .recalibrationActionStyle()

                       if vm.phase == .idle { PresetPickerBal }   // 2m / 3m / 4m
                       Button {
                           vm.performAsyncAction { try await vm.start(mode: .balancing) }
                       } label: { T("Balancing", .action) }
                           .recalibrationActionStyle()
                   }
                   

               case .running, .pause:
                   VStack(spacing: 8) {
                       T(vm.mode == .breathing ? "Breathing" : "Balancing", .section)
                           .frame(maxWidth: .infinity, alignment: .center)

                       Text(vm.formattedTime)
                           .font(.system(size: 56, weight: .semibold, design: .rounded))
                           .monospacedDigit()
                           .frame(maxWidth: .infinity, alignment: .center)

                       Button(role: .destructive) {
                           vm.performAsyncAction { try await vm.stop() }
                       } label: { T("Cancel", .action) }
                   }

               case .finished:
                   EmptyView()
               }
           }
       }
    // Tiny, reusable instruction list (keeps body tidy)
    private struct InstructionList: View {
        let items: [String]
        let p: ScreenStylePalette
        let theme: ThemeManager
        var body: some View {
            VStack(alignment: .leading, spacing: 4) {
                ForEach(items, id: \.self) { Text("• \($0)") }
            }
            .font(theme.fontTheme.toFont(.footnote))
            .foregroundStyle(p.text)
        }
    }

    
    
    
//
//                    
//                    /// users tap a length first (2/3/4), then “Breathe.”
//                    if vm.phase == .idle {
//                        HStack(spacing: 8) {
//                            T("Breathing length", .caption)
//                                .foregroundStyle(.secondary)
//                            Picker("", selection: $breathingChoice) {
//                                Text("2m").tag(2)
//                                Text("3m").tag(3)
//                                Text("4m").tag(4)
//                            }
//                            .pickerStyle(.segmented)
//                            .frame(maxWidth: 220)
//                        }
//                        .onChange(of: breathingChoice) { new in
//                            do { try vm.setBreathingMinutes(new) }
//                            catch { vm.lastError = error }
//                        }
//                    }
//                    
//                    /// When inactive, show simple, obvious choices
//                    if vm.phase != .running {
//                        VStack(spacing: 12) {
//                            if vm.mode == nil {
//                                Button { start(.breathing) } label: {
//                                    HStack(spacing: 8){
//                                        Image(systemName: RecalibrationMode.breathing.iconName)
//                                        T(activeTitle, .largeTitle)
//                                    }
//                                    .frame(maxWidth: .infinity)
//                                }
//                                .primaryActionStyle(screen: .recalibrate)
//                                
//                                Button { start(.balancing) } label: {
//                                    HStack(spacing: 8){
//                                        Image(systemName: RecalibrationMode.balancing.iconName)
//                                        T(activeTitle, .largeTitle)
//                                    }
//                                    .frame(maxWidth: .infinity)
//                                }
//                                .primaryActionStyle(screen: .recalibrate)
//                            }
//                        }
//                    } else {
//                        /// Active countdown view: big, legible, tappable cancel
//                        VStack(spacing: 16) {
//                            Text(activeTitle)
//                                .font(.headline)
//                            Text(vm.formattedTime)
//                                .font(.system(size: 56, weight: .semibold, design: .rounded))
//                                .monospacedDigit()
//                            Button(role: .destructive) { stop() } label: {
//                                Label("Cancel", systemImage: "xmark.circle")
//                                    .frame(maxWidth: .infinity)
//                                    .tint(.red)
//                            }
//                        }
//                        .padding(.top, 8)
//                    }
//                    // instructions for the selected mode:
//                    if let m = vm.mode, vm.phase != .running {
//                        VStack(alignment: .leading, spacing: 4) {
//                            ForEach(m.instructions, id: \.self) { Text("• \($0)") }
//                        }
//                        .font(theme.fontTheme.toFont(.footnote))
//                        .foregroundStyle(p.text)
//                        .padding(.top, 8)
//                    }
//                    
//                    VStack(spacing: 8) {
//                        if vm.mode == .balancing {
//                            Text(vm.promptText) // shows “Switch feet” briefly each minute
//                                .font(.title3).fontWeight(.semibold)
//                        } else if vm.mode == .breathing {
//                            BreathingPhaseGuide(
//                                phases: vm.breathingPhases,
//                                activeIndex: vm.breathingPhaseIndex,
//                                p: p
//                            )
//                            HStack(spacing: 6) {
//                                ForEach(Array(vm.breathingPhases.enumerated()), id: \.0) { idx, name in
//                                    if idx == vm.breathingPhaseIndex { Text("• \(name)") } else { Text(name) }
//                                    if idx != vm.breathingPhases.count - 1 { Text("·").opacity(0.6) }
//                                }
//                            }
//                            .font(.headline)
//                            .monospacedDigit()
//                        }
//                        //                    Text(vm.formattedTime).font(.system(.largeTitle, design: .rounded)).monospacedDigit()
//                    }
//                    
//                }
//                .task { breathingChoice = vm.currentBreathingMinutes }
//                .presentationDetents([.height(320), .medium])
//                .presentationDragIndicator(.visible)
//                
//                // Error overlay—same pattern as the rest of the app
//                if let err = vm.lastError {
//                    ErrorOverlay(error: err) { vm.lastError = nil }
//                        .zIndex(1)
//                }
//            }
//            .background(p.background.ignoresSafeArea())
//        }
//    }



//struct RecalibrateV: View {
//    @EnvironmentObject var theme: ThemeManager
//    @ObservedObject var viewModel: RecalibrationVM
//    @State private var recalibrationChoice: RecalibrationMode = .breathing
//        
//    @StateObject private var recalibrationVM = RecalibrationVM()
//        
//    var body: some View {
//        
//        let palette = theme.palette(for: .recalibrate)
//        
//        VStack(spacing: 24) {
//            // Header
////            Text.styled("Recalibrate", as: .header, using: fontTheme, in: palette)
//            Label("Recalibrate", systemImage: recalibrationChoice.iconName) // image and text
//                .font(.largeTitle)
//                .foregroundStyle(palette.primary)
//            
//            // Picker
//            Picker("Method", selection: $recalibrationChoice) {
//                ForEach(RecalibrationMode.allCases, id: \.self) { type in
//                    Text("\(type.label)")
//                        .font(.caption)
//                        .tag(type)
//                }
//            }
//            .pickerStyle(SegmentedPickerStyle())
//            
//            // Begin/Start Button
//            Button(action: {
//                viewModel.start(mode: recalibrationChoice)
//            }) {
//                Label("Begin", systemImage: "play.circle.fill")
//                    .font(.title)
//            }
//            .primaryActionStyle(screen: .recalibrate)
//            .environmentObject(theme)
//            
//            // Coundown Displayed
//            Text("⏱ \(viewModel.formattedTime)")
//                .font(.title2)
//                .bold()
//                .foregroundStyle(palette.text)
//            
//            // Instruction List
//            ForEach(recalibrationChoice.instructions, id: \.self) { line in
//                Text("• \(line)")
//            }
//            
//
//            // Conditional UI when finished
//            if viewModel.phase == .finished {
//                Text("✅ Done! Tap to go back")
//                    .foregroundColor(palette.text)
//                    .padding(.top, 8)
//                Text("Tap to post to social")
//                    .foregroundStyle(palette.text)
//                    .padding(.top, 8)
//            }
//            
//            // Exit Button
//            Button("Exit")  {
//                viewModel.stop()
//            }
//            .secondaryActionStyle(screen: .recalibrate)
//            .environmentObject(theme)
//        }
//        .padding()
//        .onAppear {
//            viewModel.start(mode: recalibrationChoice)
//        }
//        .background(
//            RoundedRectangle(cornerRadius: 24)
//                .fill(palette.background)
//                .shadow(color: palette.primary.opacity(0.2), radius: 10, x: 0, y: 4)
//        )
//        .padding()
//    }
//}
#if DEBUG
#Preview("Recalibrate") {
    PreviewWrapper {
        RecalibrationV(vm: RecalibrationVM(haptics:NoopHapticsClient()))
            .previewTheme()
    }
}
#endif
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationType.swift ===
//
//  RecalibrationMode.swift
//  intention
//
//  Created by Benjamin Tryon on 7/22/25.
//

import SwiftUI

// Authoritiative model - Operation + duration, View can request preset cleanly
/// Role-only; Durations live in the VM's config

enum RecalibrationMode: String, Hashable, Codable, CaseIterable {
    case balancing
    case breathing
    
    var label: String {
        switch self {
        case .balancing: return "Balancing Reset"
        case .breathing: return "Breathing Reset"
        }
    }
    
    var iconName: String {
        switch self {
        case .balancing: return "figure.stand"
        case .breathing: return "lungs.fill"
        }
    }
    
        var instructions: [String] {
            switch self {
            case .balancing:
                /// 4 minutes, switch every minute
                return [
                    "Stand on one foot.",
                    "Switch feet, every minute",
                    "Level up: close eyes and repeat.",
                ]
            case .breathing:
                /// 6-3, 6-3
                return [
                    "Inhale 6 sec, hold 3 sec.",
                    "Exhale 6 sec, hold 3 sec.",
                    "Repeat until timer ends."
                ]
            }
        }
}


//enum RecalibrationMode: String, CaseIterable, Hashable, Codable {

-e \n\n
=== ./intention/Features/Recalibration/RecalibrationVM.swift ===
//
//  RecalibrationVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//

import Foundation

enum RecalibrationError: LocalizedError {
    case invalidBreathingMinutes, cannotChangeWhileRunning
    var errorDescription: String? {
        switch self {
        case .invalidBreathingMinutes:   return "Breathing must be 2–4 minutes."
        case .cannotChangeWhileRunning:  return "You can’t change duration while a session is running."
        }
    }
}

/// One entry point: start(mode:)

/// VM decides duration + cadence (no durations in the View).

/// Haptics are triggered from VM only (View stays quiet).

/// Swift-6 friendly captures; cancel on deinit.
@MainActor
final class RecalibrationVM: ObservableObject {
    enum Phase { case idle, running, finished, pause }
    
    @Published private(set) var phase: Phase = .idle
    @Published private(set) var mode: RecalibrationMode? = nil
    @Published var timeRemaining: Int = 0
    @Published var lastError: Error? = nil
    @Published var breathingPhaseIndex: Int = 0     // 0:Inhale, 1:Hold, 2:Exhale, 3:Hold
    @Published var promptText: String = ""          // “Switch feet” pulses EMOM
    @Published var eyesClosedMode: Bool = false     // UI toggles this before start()
    @Published var balancingPhaseIndex: Int = 0
    
    var formattedTime: String {
        let m = timeRemaining / 60, s = timeRemaining % 60
        return String(format: "%02d:%02d", m, s)
    }
    
    // Counts
    var onCompleted: ((RecalibrationMode) -> Void)?
    
    // VMs current default on present
    var currentBreathingMinutes: Int { breathingMinutes }
    var currentBalancingMinutes: Int { balancingMinutes }
    
    // Prompts
    let breathingPhases = ["Inhale", "Hold", "Exhale", "Hold"]
    var breathingPhaseLine: String { breathingPhases.joined(separator: " . ") }

    // Policy knobs (VM decides "when")
    private var breathingMinutes: Int
    private var balancingMinutes: Int
    private let inhale = 6, hold1 = 3, exhale = 6, hold2 = 3

    private let haptics: HapticsClient
    private var task: Task<Void, Never>?

    init(haptics: HapticsClient, breathingMinutes: Int = 2, balancingMinutes: Int = 4)
    {
        self.haptics = haptics
        self.breathingMinutes = min(4, max(2, breathingMinutes))
        self.balancingMinutes = min(4, max(4, balancingMinutes))
    }

    deinit { task?.cancel() }

    
    // MARK: Core API (async throws; View calls these)
    func setBreathingMinutes(_ minutes: Int) throws {
        guard (2...4).contains(minutes) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        breathingMinutes = minutes
    }
    
    func setBalancingMinutes(_ mins: Int) throws {
        guard (1...4).contains(mins) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        balancingMinutes = mins
    }
    
    func start(mode: RecalibrationMode) async throws {
        cancel()
        self.mode = mode
        self.phase = .running
        switch mode {
        case .balancing:
            timeRemaining = balancingMinutes * 60
            runBalancing()
        case .breathing:
            timeRemaining = breathingMinutes * 60
            runBreathing()
        }
    }
    func stop() async throws {
        cancel()
        phase = .idle
        mode = nil
        promptText = ""
    }

    private func cancel() {
        task?.cancel()
        task = nil
    }
    
    // MARK: Private helpers
    private func runBalancing() {
        // Minute beeps: short–short; Done: long–long–short; only show “Switch feet” briefly each minute
        /// cue at start + each minute, set balancingPhaseIndex, optionally show promptText for 1s
        let total = timeRemaining
        task = Task { [weak self] in
            guard let self else { return }
            var lastCueAt = -1   // ensure we cue at the start and then each minute boundary
            
            while self.timeRemaining > 0 && !Task.isCancelled {
                // Cue at start and each minute boundary
                if self.timeRemaining == total || (self.timeRemaining % 60 == 0 && self.timeRemaining != lastCueAt) {
                    let elapsed = total - self.timeRemaining
                    let minuteIndex = (elapsed / 60) % 2          // 0,1,0,1...
                    await self.haptics.notifySwitch()             // short–short
                    await MainActor.run {
                        self.balancingPhaseIndex = minuteIndex
                        if !self.eyesClosedMode { self.promptText = "Switch feet" }
                    }
                    try? await Task.sleep(nanoseconds: 1_000_000_000)
                    await MainActor.run { self.promptText = "" }
                    lastCueAt = self.timeRemaining
                }

                // Tick every second no matter what
                try? await Task.sleep(nanoseconds: 1_000_000_000)
                await MainActor.run { self.timeRemaining -= 1 }
            }

            guard !Task.isCancelled else { return }
            await self.haptics.notifyDone() // long–long–short
            await MainActor.run {
                self.phase = .finished
                self.mode = nil
                self.promptText = ""
            }
            await MainActor.run { self.onCompleted?(.balancing) }
        }
    }

    private func runBreathing() {
        // Show one line “Inhale · Hold · Exhale · Hold” and move a subtle dot via breathingPhaseIndex
        task = Task { [weak self] in
            guard let self else { return }
            let phases = [(0, inhale), (1, hold1), (2, exhale), (3, hold2)]
            while self.timeRemaining > 0 && !Task.isCancelled {
                for (idx, secs) in phases {
                    await MainActor.run {
                        self.breathingPhaseIndex = idx
                        // NOTE: No big label per phase; UI uses breathingPhaseLine + index to draw the dot
                    }
                    for _ in 0..<secs {
                        guard !Task.isCancelled else { return }
                        try? await Task.sleep(nanoseconds: 1_000_000_000)
                        await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }
                        if self.timeRemaining == 0 { break }
                    }
                    if self.timeRemaining == 0 { break }
                    await self.haptics.added() // tiny cue at phase boundaries
                }
            }
            guard !Task.isCancelled else { return }
            await self.haptics.notifyDone() // long–long–short
            await MainActor.run {
                self.phase = .finished
                let finished = self.mode
                self.mode = nil
                self.promptText = ""
                if let m = finished { self.onCompleted?(m) }
            }
        }
    }


       private func phaseBlock(label: String, seconds: Int) async {
           await haptics.added()   // single short cue at each phase start
           for _ in 0..<seconds {
               guard !Task.isCancelled else { return }
               try? await Task.sleep(nanoseconds: 1_000_000_000)
               await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }
           }
       }
    
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do {
                try await action()
            } catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
}
-e \n\n
=== ./intention/Features/Stats/StatsVM.swift ===
//
//  StatsVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/30/25.
//

import Foundation
import SwiftUI

enum StatsError: Error, LocalizedError {
    case calculationFailed
    var errorDescription: String? { "Statistics could not be calculated." }
}

@MainActor
final class StatsVM: ObservableObject {
    @Published private(set) var averageCompletionRate: Double = 1.0
    @Published private(set) var totalCompletedIntentions: Int = 0
    @Published private(set) var recalibrationCounts: [RecalibrationMode: Int] = [:] // what?
    @Published private(set) var lastRecalibrationChoice: RecalibrationMode? = nil
    @Published private(set) var streak: Int = 0
    @Published private(set) var longestStreak: Int = 0
    @Published var shouldPromptForMembership: Bool = false  // is good flag
    @Published var lastError: Error?
    
    private let persistence: any Persistence
    private let storageKey = "completedSessions"
    private let membershipThreshold = 2
    private var completedSessions: [CompletedSession] = []
    
    weak var memVM: MembershipVM?
    
    init(persistence: any Persistence){
        self.persistence = persistence
        Task {  await loadSessions()    }
    }
    
    func logSession(_ session: CompletedSession) {
        completedSessions.append(session)
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        memVM?.triggerPromptifNeeded(afterSessions: completedSessions.count)
        
        /// if user did recalibrate (picked breathing or balancing), type will be non-nil, and count incremented
        if let type = session.recalibration {
            recalibrationCounts[type, default: 0] += 1
            lastRecalibrationChoice = type
        }
        
        recalculateStats()
        
        /// Updates to trigger memberhship prompt ($0.99 then $5.99 for 3 months?)
        /// Keeps onboarding friction at zero: the user never types anything.
        if completedSessions.count == membershipThreshold {
            shouldPromptForMembership = true    // Observe in the RootView and present as alert/sheet
        }
        
        Task {
            do {
                try await persistence.write(completedSessions, to: storageKey)
            } catch {
                debugPrint("[StatsVM.logSession persistence.saveHistory] error:", error)
                await MainActor.run { self.lastError = error }
            }
        }
    }
    
    private func loadSessions() async {
        do {
            if let loaded: [CompletedSession] = try await persistence.readIfExists([CompletedSession].self, from: storageKey) {
                completedSessions = loaded
                recalculateStats()
            }
        } catch {
            debugPrint("[StatsVM.loadSessions] from PersistenceActor: ", error)
            await MainActor.run { self.lastError = error }
        }
    }
    private func recalculateStats() {
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        let intendedTiles = completedSessions.count * 2
        /// Update average completion rate
        averageCompletionRate = intendedTiles == 0 ? 1.0 : Double(totalCompletedIntentions) / Double(intendedTiles)
        
        /// Update recalibration counts - counts and “last choice” are always correct after app relaunch
        var newCounts: [RecalibrationMode: Int] = [:]
        var last: RecalibrationMode? = nil
        for sesh in completedSessions {
            if let t = sesh.recalibration {
                newCounts[t, default: 0] += 1
                last = t
            }
        }
        recalibrationCounts = newCounts
        lastRecalibrationChoice = last
        
        updateRunStreak()
    }
    
    private func updateRunStreak() {
        let calendar = Calendar.current
        let daysWithSessions = Set(completedSessions.map {
            calendar.startOfDay(for: $0.date)
        })
        let sortedDays = daysWithSessions.sorted(by: >) // descending: [today, yesterday, ...]
        
        // If empty, no streak, otherwise start/continue Current Streak
        guard !sortedDays.isEmpty else {
            streak = 0
            longestStreak = 0
//            tilesCompletedThisWeek = 0
            return
            }
        
        // Run streak (most recent backward)
        var maxStreak = 1
        var currentStreak = 1
        var isTrackingCurrent = true
        for i in 1..<sortedDays.count {
            let diff = calendar.dateComponents([.day], from: sortedDays[i], to: sortedDays[i - 1]).day ?? 0
            if diff == 1 {
                currentStreak += 1
                if isTrackingCurrent { streak = currentStreak }
                maxStreak = max(maxStreak, currentStreak)
            } else {
                isTrackingCurrent = false
                currentStreak = 1
            }
        }
        // If all dates are consecutive, streak isn't updated in the loop
        if isTrackingCurrent { streak = currentStreak }
        longestStreak = maxStreak
    }
    
    
    // MARK: Helpers + Throwing Core
    
    ///Throwing core (async throws): use when the caller wants to decide how to handle the error
    
    func logSessionThrowing( _ s: CompletedSession) async throws {
        completedSessions.append(s)
        recalculateStats()
        try await persistence.write(completedSessions, to: storageKey)
    }
    
    // Background
    func autosaveStats() {
        //            Task {
        //                do { try await persistence.saveHistory(self, to: "statsData") }
        //                catch {
        //                    debugPrint("[StatsVM.autosaveStats] error:", error)
        //                    self.lastError = error
        //                }
    }
}

// MARK: Supporting Types -
// Keeps CompletedSession simple and fully Codable for PersistenceActor
struct CompletedSession: Codable {
    let date: Date
    let tileTexts: [String]
    let recalibration: RecalibrationMode?
}

-e \n\n
=== ./intention/Features/Stats/StatBlock.swift ===
//
//  StatPill.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct StatPill: View {
    @EnvironmentObject var theme: ThemeManager
    let icon: String
    let value: String
    let caption: String
    let screen: ScreenName

    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }

    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon).font(.title2).foregroundStyle(p.accent)
            T(value, .section).bold().foregroundStyle(p.text)
            T(caption, .caption).foregroundStyle(p.textSecondary)
        }
    }
}
-e \n\n
=== ./intention/Features/Stats/StatsSummaryBar.swift ===
//
//  StatsSummaryBar.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import SwiftUI

struct StatsSummaryBar: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var vm: StatsVM
   

    var body: some View {
        HStack(spacing: 12) {
            StatPill(icon: "flame",
                      value: "\(vm.streak)",
                      caption: "Streak",
                      screen: .settings)

            StatPill(icon: "checkmark",
                      value: String(format: "%.0f%%", vm.averageCompletionRate * 100), //FIXME: value: vm.avgCompletionString, label: "Avg.")
                      caption: "Avg. completion",
                      screen: .settings)

            if let last = vm.lastRecalibrationChoice {
                StatPill(icon: last.iconName,
                          value: last.label,
                          caption: "", // no caption for this one
                          screen: .settings)
            }
        }
    }
}
-e \n\n
=== ./intention/Features/Membership/MembershipSheetV.swift ===
//
//  Sheet.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//
//
//import Foundation
import SwiftUI

struct MembershipSheetV: View {
    @EnvironmentObject var viewModel: MembershipVM
    @EnvironmentObject var theme: ThemeManager
    
    @State private var isFavorite = false
    @State var codeInput: String = ""
    
    private let screen: ScreenName = .membership
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // replaces fragile chunk with a validated block
    private var codeValidation: ValidationState {
        codeInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        ? .invalid(messages: ["Enter a code"])
        : .valid
    }
    
    var body: some View {
        ZStack {
            ScrollView {
                Page {
                    T("Unlock Unlimited Focus", .section)
                    //                        .multilineTextAlignment(.center)
                        .friendlyHelper()
                    
                    T("You’ve completed your free sessions. For just 20–30¢ a day, unlock unlimited focus sessions, detailed stats, more categories, and full customization. Build momentum, track progress, and work with intention — while helping us keep the lights on, the mortgage paid, and the dog well-fed. Your focus fuels our future. Thank you.", .body)
                        .multilineTextAlignment(.center)
                        .foregroundStyle(theme.palette(for: .membership).textSecondary)
                    //
                    //                    theme.styledText("By continuing, you agree to our Terms and Privacy.", as: .caption, in: .membership))
                    //                        .font(theme.fontTheme.toFont(.footnote))
                    //                        .foregroundStyle(.secondary)
                    //                        .padding(.bottom, 8)
                    
                    if viewModel.isMember {
                        Label {
                            T("Member!", .label)
                        } icon: {
                            Image(systemName: "star")
                        }
                        .symbolBounceIfAvailable()
                    } else {
                        Button( action: {
                            Task {
                                do {
                                    try await viewModel.purchaseMembershipOrPrompt()
                                } catch {
                                    debugPrint("[viewModel.purchaseMembershipOrPrompt] error: ", error)
                                    viewModel.setError(error)                /// Shows ErrorOverlay
                                }
                            }
                        }) {
                            T("Upgrade Membership", .action)
                        }
                        .primaryActionStyle(screen: .membership)
                        
                        Button(action:
                                {
                            Task {
                                do {
                                    try await viewModel.restoreMembershipOrPrompt()
                                } catch {
                                    debugPrint("[viewModel.restoreMembershipOrPrompt] error:", error)
                                    viewModel.setError(error)                /// Shows ErrorOverlay
                                    // _ = await MainActor.run {  MembershipError.restoreFailed }
                                }
                            }
                        }) {
                            T("Restore Purchases", .label)
                        }
                        .secondaryActionStyle(screen: .membership)
                        
                        
                        if !AppEnvironment.isAppStoreReviewing {
                            Divider()
                            Button(action: {
                                Task {
                                    if let url = URL(string: "https://www.argonnesoftware.com/cart/") {
                                        await UIApplication.shared.open(url)
                                    } else {
                                        debugPrint("[MembershipSheetV.isAppStoreReviewing] bad URL" )
                                        viewModel.setError(MembershipError.appEnvironmentFail)   /// Shows ErrorOverlay
                                    }
                                }
                            }){
                                T("Visit Website", .section)
                            }
                            .primaryActionStyle(screen: .membership)
                            .underline()
                            
                            VStack(spacing: 12) {
                                
                                Button( action: {
                                    viewModel.showCodeEntry = true
                                    Task {
                                        if let url = URL(string: "https://www.argonnesoftware.com/cart/") {
                                            await UIApplication.shared.open(url)
                                        } else {
                                            debugPrint("[MembershipSheetV.isAppStoreReviewing] bad URL" )
                                            viewModel.setError(MembershipError.appEnvironmentFail)   /// Shows ErrorOverlay
                                        }
                                    }
                                }) {
                                    T("Enter Membership Code", .label)
                                }
                                .primaryActionStyle(screen: .membership)
                                
                                if viewModel.showCodeEntry {
                                    VStack(spacing: 8) {
                                        ZStack(alignment: .leading) {
                                            if codeInput.isEmpty {
                                                T("Enter code", .placeholder)
                                                    .padding(.horizontal, 12)
                                            }
                                            TextField("", text: $codeInput)
                                                .textInputAutocapitalization(.characters)
                                                .disableAutocorrection(true)
                                                .validatingField(state: codeValidation, palette: p)
                                        }
                                        
                                        ValidationCaption(state: codeValidation, palette: p)
                                        
                                        Button {
                                            Task {
                                                do { try await viewModel.verifyCode(codeInput) }
                                                catch {
                                                    debugPrint("[MembershipSheetV.showCodeEntry] error: ", error )
                                                    viewModel.setError(error)                /// Shows ErrorOverlay
                                                }
                                            }
                                        } label: {
                                            T("Redeem", .label)
                                        }
                                        .primaryActionStyle(screen: .membership)
                                        .padding(.horizontal)
                                    }
                                }
                            }
                            .padding()
                        }
                    }
                }
                /// Signals if a product is loaded + VM bridge (sheet cannot create own PaymentService)
                if let prod = viewModel.primaryProduct {
                    Text("\(viewModel.perDayBlurb(for: prod)) * \(prod.displayPrice)")
                        .font(theme.fontTheme.toFont(.footnote))
                        .foregroundStyle(.secondary)
                }
                
                /// Overlay shown if there is a lastError
                if let error = viewModel.lastError {
                    ErrorOverlay(error: error) {
                        viewModel.setError(nil)  /// Dismiss
                    }
                    .transition(.opacity.combined(with: .scale))
                    .zIndex(1)
                }
            }
        }
    }
}
-e \n\n
=== ./intention/Features/Membership/MembershipSectionV.swift ===
//
//  MembershipSectionV.swift
//  intention
//
//  Created by Benjamin Tryon on 8/22/25.
//
//
/// DON'T NEED THIS - it is an extra purchase entry point
//import SwiftUI
//import StoreKit
//
//private extension Product.SubscriptionPeriod.Unit {
//    var displayText: String {
//        switch self {
//        case .day: "day"
//        case .week: "week"
//        case .month: "month"
//        case .year: "year"
//        @unknown default: "period"
//        }
//    }
//}
//
//struct MembershipSectionV: View {
//    @StateObject private var pay = PaymentService()
//
//    private var priceLine: String {
//        guard let p = pay.products.first else { return "Loading…" }
//        if let sub = p.subscription {
//            return "\(p.displayPrice) / \(sub.subscriptionPeriod.unit.displayText)"
//        }
//        return p.displayPrice
//    }
//
//    var body: some View {
//        Section("Membership") {
//            HStack {
//                Text(pay.isMember ? "Status: Active" : "Status: Not Active")
//                    .foregroundStyle(pay.isMember ? .green : .secondary)
//                Spacer()
//            }
//
//            if let product = pay.products.first {
//                Button("Start Membership — \(priceLine)") {
//                    Task { try await pay.purchaseMembership() }
//                }
//                .primaryActionStyle(screen: .settings
//
//                Button("Restore Purchases") {
//                    Task { try await pay.restorePurchases() }
//                }
//
//                Link("Manage Subscription",
//                     destination: URL(string: "https://apps.apple.com/account/subscriptions")!)
//                    .foregroundStyle(.secondary)
//            } else {
//                ProgressView("Loading products…")
//            }
//        }
//    }
//}
-e \n\n
=== ./intention/Features/Membership/MembershipVM.swift ===
//
//  MembershipVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import SwiftUI
import StoreKit

enum MembershipError: Error, Equatable, LocalizedError {
    case purchaseFailed, restoreFailed, invalidCode, networkError, appEnvironmentFail

    var errorDescription: String? {
        switch self {
        case .purchaseFailed:     return "Purchase could not be completed."
        case .restoreFailed:      return "No purchases to restore."
        case .invalidCode:        return "That code isn’t valid."
        case .networkError:       return "Network error. Please try again."
        case .appEnvironmentFail: return "App environment error."
        }
    }
}

/// pure async/await for purchase/restore paths, one paywall, stable entitlement refresh
@MainActor
final class MembershipVM: ObservableObject {
    @Published var isMember: Bool = false
    @Published var shouldPrompt: Bool = false
    @Published var showCodeEntry: Bool = false
    @Published var primaryProduct: Product?         /// Shows "¢/day • $X.XX"
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    
    private let paymentService = PaymentService()
    private let codeService = MembershipCodeService()
    
    init() {
        // Ensures MembershipVM initializes PaymentService and calls loadMembershipState() on init
        /// Mirror enitlement + first product for UI
        //        paymentService.loadMembershipState()
        //        isMember = paymentService.isMember

        paymentService.$isMember
            .receive(on: RunLoop.main)
            .assign(to: &$isMember)
        
        paymentService.$products
            .map { $0.first }   //FIXME: not $0, what is 0 made of?
            .receive(on: RunLoop.main)
            .assign(to: &$primaryProduct)
    }
    
    func triggerPromptifNeeded(afterSessions sessionCount: Int, threshold: Int = 2){
        if !isMember && sessionCount >= threshold { shouldPrompt = true }
    }
    
    /// Trigger helper to reopen form anywhere (starts in RootView, can be in a banner, Settings, locked feature)
    @MainActor func presentPaywall() { shouldPrompt = true }
    
    /// Core remains async throws. UI calls inside Task { do/try/catch }
    func purchaseMembershipOrPrompt() async throws {
        try await paymentService.purchaseMembership()
        isMember = paymentService.isMember
        shouldPrompt = !isMember
        guard isMember else {
            let err = MembershipError.purchaseFailed
            setError(err)
            throw err
        }
    }
    
    func restoreMembershipOrPrompt() async throws {
        try await paymentService.restorePurchases()
        isMember = paymentService.isMember
        guard isMember else {
            let err = MembershipError.restoreFailed
            setError(err)
            throw err
        }
    }
    
    @MainActor
    func verifyCode(_ code: String) async throws {
        let deviceID = UIDevice.current.identifierForVendor?.uuidString ?? "unknown"
        let result = await codeService.verify(code: code, deviceID: deviceID)
        switch result {
        case .success:
            isMember = true
            shouldPrompt = false
            showCodeEntry = false
        case .invalid:
            let err = MembershipError.invalidCode
            setError(err)
            throw err
        case .networkError:
            let err = MembershipError.networkError
            setError(err)
            throw err
        }
    }
    
    func setError(_ error: Error?) { lastError = error }
    
    func perDayBlurb(for product: Product) -> String {
        guard let sub = product.subscription else { return "" }
        // Very rough: 30-day month, 365-day year. It’s just a blurb.
        let days: Decimal
        switch sub.subscriptionPeriod.unit {
        case .month: days = 30
        case .year:  days = 365
        case .week:  days = 7
        case .day:   days = 1
        @unknown default: days = 30
        }
        // Product.price is Decimal in StoreKit 2.
        let daily = (product.price / days) as NSDecimalNumber
        let cents = (daily.multiplying(by: 100)).doubleValue.rounded()
        return "about \(Int(cents))¢/day"
    }
    
    var showSheetBinding: Binding<Bool> {
        Binding(
            get: { self.shouldPrompt },
            set: { newVal in self.shouldPrompt = newVal  }
            // or self.shouldPrompt = $0
        )
    }
}
-e \n\n
=== ./intention/Shared/Mocks/PreviewWrapper.swift ===
//
//  PreviewWrapper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

#if DEBUG
import SwiftUI

@MainActor
struct PreviewWrapper<Content: View>: View {
    let content: () -> Content

    var body: some View {
        content()
            .environmentObject(PreviewMocks.theme)
            .environmentObject(PreviewMocks.prefs)
            .environmentObject(PreviewMocks.membershipVM)
            .environmentObject(PreviewMocks.history)        /// some subviews use HistoryVM via EnvironmentObject
            .environmentObject(PreviewMocks.stats)
    }
}
#endif
-e \n\n
=== ./intention/Shared/Mocks/PreviewMocks.swift ===
//
//  PreviewMocks.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

#if DEBUG
import SwiftUI


enum PreviewMocks {
    // One persistence for everything in previews
    @MainActor static let persistence = PersistenceActor()

    @MainActor static let history: HistoryVM = {
        let h = HistoryVM(persistence: persistence)
        h.generalCategoryID = UUID(uuidString: "11111111-1111-1111-1111-111111111111")!
        h.archiveCategoryID = UUID(uuidString: "22222222-2222-2222-2222-222222222222")!
        h.ensureGeneralCategory()
        h.ensureArchiveCategory()
        return h
    }()

    @MainActor static let stats: StatsVM = {
        StatsVM(persistence: persistence)
    }()

    @MainActor static let membershipVM: MembershipVM = {
        MembershipVM()
    }()

    @MainActor static let prefs: AppPreferencesVM = {
        AppPreferencesVM()
    }()
    
    @MainActor static let theme: ThemeManager = {
        ThemeManager()
    }()

    @MainActor static let focusSession: FocusSessionVM = {
        let vm = FocusSessionVM(previewMode: true,
                                haptics: NoopHapticsClient(),    // ← ignore haptics in previews
                                config: .current)                 // your TimerConfig already returns .shortDebug in previews
        vm.historyVM = history
        return vm
    }()
    
    @MainActor static let recal: RecalibrationVM = {
            RecalibrationVM(haptics: NoopHapticsClient())             // ← ignore in previews

        }()
}
#endif

//@StateObject private var focusVM: FocusSessionVM
//@StateObject private var recalibrationVM: RecalibrationVM
//@StateObject private var prefs: AppPreferencesVM
//@StateObject private var haptics: HapticsService
-e \n\n
=== ./intention/Shared/Haptics/AppPreferencesVM.swift ===
//
//  AppPreferencesVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//


import SwiftUI

/// The delivery mechanism: inject a HapticsService from RootView (no singletons), @MainActor, warmed generators, safe everywhere
@MainActor
final class AppPreferencesVM: ObservableObject {
    @AppStorage("hapticsOnly") var hapticsOnly: Bool = true  /// default ON
    
    /// optional: add more later (soundsEnabled, reduceAnimations, etc.)
}
-e \n\n
=== ./intention/Shared/Haptics/LiveHapticsClient.swift ===
//
//  LiveHapticsClient.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import Foundation

/// avoid pushing both a preference object and a service into every VM: wrap them behind a protocol that gates haptics based on the preference
/// VMs then depend on one thing: HapticsClient
@MainActor
protocol HapticsClient {
    func added()
    func countdownTick()
    func notifySwitch()
    func notifyDone()
}

/// No-op (for tests or to disable globally)
struct NoopHapticsClient: HapticsClient {
    func added() {}
    func countdownTick() {}
    func notifySwitch() {}
    func notifyDone() {}
}

/// Live client that checks prefs.hapticsOnly and calls the engine
//@MainActor
struct LiveHapticsClient: HapticsClient {
    let prefs: AppPreferencesVM
    let engine: HapticsService
    private var enabled: Bool { prefs.hapticsOnly }

    func added()         { guard enabled else { return }; engine.added() }
    func countdownTick() { guard enabled else { return }; engine.countdownTick() }
    func notifySwitch()  { guard enabled else { return }; engine.notifySwitch() }
    func notifyDone()    { guard enabled else { return }; engine.notifyDone() }
}

/// for background tasks, just hop to main when calling: await MainActor.run { haptics.notifyDone() }
/// if the compiler complains/nags:
/// // Live client (wrap engine safely on main)
/// struct LiveHapticsClient: HapticsClient {
///    let prefs: AppPreferencesVM
///    let engine: HapticsService
///    private var enabled: Bool { prefs.hapticsOnly }
///
///    func added() async       { guard enabled else { return }
///        await MainActor.run { engine.tapLight() } }
///
///    func notifySwitch() async{ guard enabled else { return }
///        await MainActor.run { engine.doubleLight() } }
///
///    func notifyDone() async  { guard enabled else { return }
///        await MainActor.run { engine.longLongShort() } }
///}
-e \n\n
=== ./intention/Shared/Haptics/HapticsService.swift ===
//
//  HapticService.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//

import Foundation
import UIKit

//Option A for the delivery mechanism: inject a HapticsService from RootView (no singletons), @MainActor, warmed generators, safe everywhere
@MainActor
final class HapticsService: ObservableObject {
    private let light = UIImpactFeedbackGenerator(style: .light)
    private let medium = UIImpactFeedbackGenerator(style: .medium)
    private let heavy = UIImpactFeedbackGenerator(style: .heavy)
    
    init() {
        light.prepare(); medium.prepare(); heavy.prepare()
    }
    
    func added() {
        medium.impactOccurred()
    }
    
    func countdownTick() {
        medium.impactOccurred(); medium.impactOccurred();medium.impactOccurred();
        light.prepare()
    }

     func notifyDone() {
        /// long, long, short
         heavy.impactOccurred()
         Task {
             try? await Task.sleep(nanoseconds: 500_000_000); heavy.impactOccurred()
             try? await Task.sleep(nanoseconds: 250_000_000); heavy.impactOccurred()
         }
    }
    
    func notifySwitch() {
        /// short, short
        light.impactOccurred()
        Task {
            try? await Task.sleep(nanoseconds: 300_000_000); light.impactOccurred()
        }
    }
}
-e \n\n
=== ./intention/Shared/Resources/Bundle+AppIcon.swift ===
//
//  AppIcon.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI
import UIKit

extension Bundle {
    var appIconFileName: String? {
        guard let icons = infoDictionary?["CFBundleIcons"] as? [String: Any],
              let primaryIcon = icons["CFBundlePrimaryIcon"] as? [String: Any],
              let iconFiles = primaryIcon["CFBundleIconFiles"] as? [String],
              let iconFileName = iconFiles.last
        else { return nil }
        return iconFileName
    }
    
    // Convenience key/computed property to load the app icon (as a UIImage)
    var appIcon: UIImage? {
        guard let appIconFileName = appIconFileName else { return nil }
        return UIImage(named: appIconFileName)      // already GETS and returns the image... do NOT need map
    }
//    don't need the flatMap and map chain in the View's body because the intermediate optional states are already handled by your appIcon computed property
}
-e \n\n
=== ./intention/Shared/Resources/ThemeManager.swift ===
//
//  AppThemeManager.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//

import SwiftUI
/*
Make color vary by theme+screen, while typography/spacing/components stay identical

The goal: one component system (Page, Card, fonts, paddings) + per-screen palette that swaps only colors when you change variant (“Default/Fire/Sea”)
  */

// Shim: keep code compiling that expects ThemePalette, if any still refer to it!
typealias ThemePalette = ScreenStylePalette
// MARK: - Screens
enum ScreenName { case homeActiveIntentions, history, settings, recalibrate, membership } //FIXME: rename homeActiveIntentions to focus
// MARK: - Text roles
enum TextRole {
    case largeTitle, header, section, title3, label, body, tile, secondary, caption, action, placeholder
}
// MARK: - Per-screen color tokens
struct ScreenStylePalette {
    let primary: Color          // secondary button bg / highlights
    let background: Color       // page background
    let surface: Color          // cards, bars
    let accent: Color           // primary CTA color
    let text: Color
    let textSecondary: Color
    let success: Color
    let warning: Color
    let danger: Color
    let border: Color
    
    struct LinearGradientSpecial {
        let colors: [Color]
        let start: UnitPoint
        let end: UnitPoint
    }
    let gradientBackground: LinearGradientSpecial?      // nil == use `background` color
}
// MARK: - App Font Theme
enum AppFontTheme: String, CaseIterable {
    case serif, rounded, mono
    var displayName: String { self == .serif ? "Serif" : self == .rounded ? "Rounded" : "Mono" }
    func toFont(_ style: Font.TextStyle) -> Font {
        let design: Font.Design = switch self {
            case .serif: .serif
            case .rounded: .rounded
            case .mono: .monospaced
        }
        return .system(style, design: design)
    }
}

// MARK: - App Color Theme → per-screen palettes
enum AppColorTheme: String, CaseIterable {
    case `default`, sea, fire

    var displayName: String {
        switch self { case .default: "Default"; case .sea: "Sea"; case .fire: "Fire" }
    }
    /// One accent per theme for consistency
    private var accent: Color {
        switch self {
        case .default: .intSeaGreen
        case .sea:     Color(red: 0.35, green: 0.75, blue: 1.0)
        case .fire:    Color(red: 1.0,  green: 0.5,  blue: 0.0)
        }
    }

    func colors(for screen: ScreenName) -> ScreenStylePalette {
        switch self {

            // ---------- DEFAULT ----------
            case .default:
                let baseBackground: Color = .intTan
                let textPrimary: Color   = .intCharcoal
                let textSecondary: Color = .intCharcoal.opacity(0.72)

                switch screen {
                case .homeActiveIntentions, .history, .settings:
                    return .init(
                        primary:   .intGreen,
                        background: baseBackground,
                        surface:   .intTan.opacity(0.2),
                        accent:    accent,
                        text:      textPrimary,
                        textSecondary: textSecondary,
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .black.opacity(0.12),
                        gradientBackground: nil
                    )

                case .recalibrate:
                    // unchanged – this one was fine
                    return .init(
                        primary:   .intSeaGreen,
                        background: Color.blue.opacity(0.20),
                        surface:   .intTan.opacity(0.2),
                        accent:    accent,
                        text:      .black,
                        textSecondary: .black.opacity(0.70),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .black.opacity(0.10),
                        gradientBackground: .init(
                            colors: [Color.blue.opacity(0.20), Color.blue.opacity(0.85)],
                            start: .topLeading,
                            end: .bottomTrailing
                    )
                        )

                case .membership:
                    return .init(
                        primary:   .intMint,
                        background: Color(.systemGroupedBackground),
                        surface:   .white.opacity(0.96),
                        accent:    accent,
                        text:      .intCharcoal,
                        textSecondary: .intCharcoal.opacity(0.72),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .black.opacity(0.10),
                        gradientBackground: nil
                    )
                }

            // ---------- SEA ----------
            case .sea:
                let bg = Color(red: 0.02, green: 0.12, blue: 0.28)
                let tx = Color(red: 0.85, green: 0.92, blue: 1.0)
                switch screen {
                case .homeActiveIntentions:
                    return .init(
                        primary:   Color(red: 0.00, green: 0.30, blue: 0.70),
                        background: bg,
                        surface:   .white.opacity(0.08),
                        accent:    accent,
                        text:      tx,
                        textSecondary: tx.opacity(0.78),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .white.opacity(0.15),
                        gradientBackground: nil
                    )
                case .history:
                    return .init(
                        primary:   Color(red: 0.12, green: 0.45, blue: 0.75),
                        background: bg.opacity(0.96),
                        surface:   .white.opacity(0.06),
                        accent:    accent,
                        text:      tx,
                        textSecondary: tx.opacity(0.78),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .white.opacity(0.15),
                        gradientBackground: nil
                    )
                case .settings:
                    return .init(
                        primary:   Color(red: 0.00, green: 0.28, blue: 0.62),
                        background: bg,
                        surface:   .white.opacity(0.08),
                        accent:    accent,
                        text:      tx,
                        textSecondary: tx.opacity(0.78),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .white.opacity(0.15),
                        gradientBackground: nil
                    )
                case .recalibrate:
                    return .init(
                        primary:   Color(red: 0.00, green: 0.12, blue: 0.22),
                        background: Color(red: 0.00, green: 0.30, blue: 0.60).opacity(0.80),
                        surface:   .white.opacity(0.10),
                        accent:    accent,
                        text:      .white,
                        textSecondary: .white.opacity(0.85),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .white.opacity(0.18),
                        gradientBackground: nil
                    )
                case .membership:
                    return .init(
                        primary:   Color(red: 0.00, green: 0.28, blue: 0.62), // match settings
                        background: bg,                                      // dark theme background
                        surface:   .white.opacity(0.12),                     // slightly higher for readability
                        accent:    accent,
                        text:      tx,
                        textSecondary: tx.opacity(0.85),
                        success:   .green,
                        warning:   .yellow,
                        danger:    .red,
                        border:    .white.opacity(0.18),
                        gradientBackground: nil
                    )
                }
            // ---------- FIRE ----------
        case .fire:
            let bg = Color(red: 0.16, green: 0.02, blue: 0.00)
            let tx = Color(red: 1.00, green: 0.90, blue: 0.78)
            switch screen {
            case .homeActiveIntentions:
                return .init(
                    primary:   Color(red: 0.80, green: 0.22, blue: 0.02),
                                    background: bg,
                                    surface:   .white.opacity(0.07),
                                    accent:    accent,
                                    text:      tx,
                                    textSecondary: tx.opacity(0.78),
                                    success:   .green,
                                    warning:   .yellow,
                                    danger:    .red,
                                    border:    .white.opacity(0.14),
                    gradientBackground: nil
                                )
            case .history:
                return .init(
                    primary:   Color(red: 0.72, green: 0.32, blue: 0.06),
                    background: bg.opacity(0.96),
                    surface:   .white.opacity(0.06),
                    accent:    accent,
                    text:      tx,
                    textSecondary: tx.opacity(0.78),
                    success:   .green,
                    warning:   .yellow,
                    danger:    .red,
                    border:    .white.opacity(0.14),
                    gradientBackground: nil
                )
            case .settings:
                return .init(
                    primary:   Color(red: 0.88, green: 0.12, blue: 0.02),
                                    background: bg,
                                    surface:   .white.opacity(0.07),
                                    accent:    accent,
                                    text:      tx,
                                    textSecondary: tx.opacity(0.78),
                                    success:   .green,
                                    warning:   .yellow,
                                    danger:    .red,
                                    border:    .white.opacity(0.14),
                    gradientBackground: nil
                                )
            case .recalibrate:
                return .init(
                    primary:   .black,
                    background: Color(red: 0.55, green: 0.02, blue: 0.02),
                    surface:   .white.opacity(0.08),
                    accent:    accent,
                    text:      .white,
                    textSecondary: .white.opacity(0.85),
                    success:   .green,
                    warning:   .yellow,
                    danger:    .red,
                    border:    .white.opacity(0.16),
                    gradientBackground: nil
                )
            case .membership:
                return .init(
                    primary:   Color(red: 0.88, green: 0.12, blue: 0.02), // match settings
                    background: bg,
                    surface:   .white.opacity(0.12),                      // slightly higher for readability
                    accent:    accent,
                    text:      tx,
                    textSecondary: tx.opacity(0.85),
                    success:   .green,
                    warning:   .yellow,
                    danger:    .red,
                    border:    .white.opacity(0.16),
                    gradientBackground: nil
                )
            }
        }
    }
}

// MARK: - Theme Manager
@MainActor
final class ThemeManager: ObservableObject {
    @AppStorage("selectedColorTheme") private var colorRaw: String = AppColorTheme.default.rawValue
    @AppStorage("selectedFontTheme")  private var fontRaw:   String = AppFontTheme.serif.rawValue

    @Published var colorTheme: AppColorTheme { didSet { colorRaw = colorTheme.rawValue } }
    @Published var fontTheme:  AppFontTheme  { didSet { fontRaw  = fontTheme.rawValue  } }

    init() {
        let storedColor = UserDefaults.standard.string(forKey: "selectedColorTheme") ?? AppColorTheme.default.rawValue
        let storedFont  = UserDefaults.standard.string(forKey: "selectedFontTheme")  ?? AppFontTheme.serif.rawValue
        self.colorTheme = AppColorTheme(rawValue: storedColor) ?? .default
        self.fontTheme  = AppFontTheme(rawValue: storedFont)  ?? .serif
    }

    func palette(for screen: ScreenName) -> ScreenStylePalette {
        colorTheme.colors(for: screen)
    }

    /// Use for static copy (headers, labels, captions, body)
    func styledText(_ content: String, as role: TextRole, in screen: ScreenName) -> Text {
        let font  = fontTheme.toFont(Self.fontStyle(for: role))
        let color = Self.color(for: role, palette: palette(for: screen))
        return Text(content).font(font).foregroundColor(color)
    }

    // MARK: Mapping
    static func fontStyle(for role: TextRole) -> Font.TextStyle {
        switch role {
        case .largeTitle: .largeTitle
        case .header:     .title
        case .section:    .title2
        case .title3:     .title3
        case .label, .action: .headline
        case .body, .tile: .body
        case .secondary, .placeholder: .subheadline
        case .caption:    .caption
        }
    }

    static func color(for role: TextRole, palette: ScreenStylePalette) -> Color {
        switch role {
        case .header, .section, .title3, .body, .tile, .largeTitle:
            return palette.text
        case .secondary, .caption, .placeholder:
            return palette.textSecondary
        case .label:
            return palette.primary
        case .action:
            // ButtonStyles typically color the label; this keeps Action readable elsewhere.
            return palette.accent
        }
    }
}

// MARK: - Preview Convenience
extension View {
    func previewTheme() -> some View {
        self.environmentObject(ThemeManager())
    }
}
-e \n\n
=== ./intention/Shared/Utilities/friendlyAnimatedHelper.swift ===
//
//  friendlyAnimatedHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import SwiftUI

extension View {
    /// Mark as a rotor-friendly heading
    func friendlyHelper() -> some View { self.accessibilityAddTraits(.isHeader) }

    /// Gate animations for motion sensitivity
    func friendlyAnimatedHelper(_ value: AnyHashable, animation: Animation = .easeInOut) -> some View {
        modifier(AnimatedIfAllowed(value: value, animation: animation))
    }
}

private struct AnimatedIfAllowed<V: Hashable>: ViewModifier {
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    let value: V
    let animation: Animation
    func body(content: Content) -> some View {
        content.animation(reduceMotion ? nil : animation, value: value)
    }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig.swift ===
//
//  TimerConfig.swift
//  intention
//
//  Created by Benjamin Tryon on 8/7/25.
//

import SwiftUI
import Foundation

/// Single source of truth for all durations
/// In UI tests, pass a launch argument to flip to short timers
struct TimerConfig: Sendable {
    
    // MARK: Focus/session
    let chunkDuration: Int          /// 20-min chunks (1200)
    
    // MARK: Haptics policy
    struct Haptics: Sendable {
        /// If > 0, fire a light haptic every second when `remaining <= endCountdownStart && remaining > 0`.
        let endCountdownStart: Int       // 3s
        /// If true, haptic once at the halfway point for either mode.
        let halfwayTick: Bool
        /// If > 0 and mode == .balancing, haptic at this interval (seconds) to hint a foot swap.
        let balanceSwapInterval: Int     // 60s
    }
    let haptics: Haptics
    
    static let prod = TimerConfig(
        chunkDuration: 1200,
        haptics: .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 60)
    )
    
    static let shortDebug = TimerConfig(
        chunkDuration: 10,
        haptics: .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 5)
    )
    
    // Picks prod unless DEBUG+flag set
    static var current: TimerConfig {
        if ProcessInfo.processInfo.arguments.contains("-UITEST_FAST_TIMERS") { return .fastUITest }
        if ProcessInfo.processInfo.isSwiftUIPreview { return .shortDebug }
        #if DEBUG
        if ProcessInfo.processInfo.arguments.contains("--SHORT_TIMERS") { return .shortDebug }
        #endif
        return .prod
    }
}

extension ProcessInfo {
    var isSwiftUIPreview: Bool { environment["XCODE_RUNNING_FOR_PREVIEWS"] == "1" }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig+UITest.swift ===
//
//  TimerConfig+UITest.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

import Foundation

extension TimerConfig {
    static let fastUITest = TimerConfig(
    chunkDuration: 3,
        haptics: .init(endCountdownStart: 1, halfwayTick: false, balanceSwapInterval: 1)
    )
}
-e \n\n
=== ./intention/Shared/Components/UnwindingPie.swift ===
//
//  UnwindingPie.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI

struct UnwindingPieShape: Shape {
    var progress: Double        // from 0.0 to 1.0
    
    var animatableData: Double {
        get { progress }
        set { progress = newValue }
    }
    
    func path(in rect: CGRect) -> Path {
        var path = Path()
        
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2
        let startAngle = -90.0
        let endAngle = startAngle - (progress * 360)

        path.move(to: center)
        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(startAngle),
            endAngle: .degrees(endAngle),
            clockwise: true
        )
        path.closeSubpath()

        return path
    }
}

struct Pie: View {
    @EnvironmentObject var theme: ThemeManager
    @State private var remainingTime = 60.0
    let totalTime: TimeInterval = 60.0
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    
    var body: some View {
        let palette = theme.palette(for:.homeActiveIntentions)
        ZStack {
            Circle()
                .fill(palette.background.opacity(0.2))
            
            UnwindingPieShape(progress: remainingTime / totalTime)
                .fill(palette.primary)
            
        }
        .frame(width: 200, height: 200)
        .onReceive(timer) { _ in
            if remainingTime > 0 {
                remainingTime -= 1
            }}
    }
}

#if DEBUG
#Preview {
    Pie()
}
#endif
-e \n\n
=== ./intention/Shared/Legal/LegalAgreementSheetV.swift ===
//
//  LegalAgreementSheetV.swift
//  intention
//
//  Created by Benjamin Tryon on 9/4/25.
//

import SwiftUI

struct LegalAgreementSheetV: View {
    let onAccept: () -> Void
    let onShowTerms: () -> Void
    let onShowPrivacy: () -> Void
    var onShowMedical: (() -> Void)? = nil   // optional extra link

    var body: some View {
        NavigationStack {
            Page(top: 20, alignment: .center) {

                    Text("""
                    Please review the policies below. 
                    By tapping **Agree & Continue**, 
                    you accept them.
                    """
                    )
//                    .multilineTextAlignment(.center)
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .lineSpacing(2)
                    // Links row
                HStack(alignment: .center){
                        Button("Terms") { onShowTerms() }
                            .buttonStyle(.plain).underline()
                    Text("•").foregroundStyle(.tertiary)
                        Button("Privacy Policy") { onShowPrivacy() }
                            .buttonStyle(.plain).underline()
                    }
                    .font(.subheadline)
                
                if let onShowMedical {
                    Button("Wellness Disclaimer") { onShowMedical() }
                        .buttonStyle(.plain)
                        .underline()
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
                
                // spacer before CTA (larger gap)
                Spacer().frame(height: 12)
                Button("Agree & Continue") { onAccept() }
                .frame(maxWidth: .infinity)
                .buttonStyle(.borderedProminent)     // makes it filled
                .buttonBorderShape(.roundedRectangle(radius: 14))
                .tint(.blue)                          // fill color
                .controlSize(.large)
                
                // Footnote hint
                Text("You can review these anytime in **Settings › Legal**.")
                    .font(.footnote)
                    .foregroundStyle(.tertiary)

                Spacer(minLength: 0)
            }
            .frame(maxWidth: 520)                    // keeps measure pleasant on large screens
            .navigationTitle("Legal")
            .navigationBarTitleDisplayMode(.inline)
        }
        .interactiveDismissDisabled(true)
        .presentationDetents([.medium, .large])
    }
}


#if DEBUG
#Preview {
    LegalAgreementSheetV(
        onAccept: {},
        onShowTerms: {},
        onShowPrivacy: {}
    )
}
#endif
-e \n\n
=== ./intention/Shared/Legal/LegalSupportV.swift ===
//
//  LegalSupportV.swift
//  intention
//
//  Created by Benjamin Tryon on 8/21/25.
//

import SwiftUI

// MARK: - Persisted acceptance state
struct LegalKeys {
    static let acceptedVersion = "legal.acceptedVersion"
    static let acceptedAtEpoch = "legal.acceptedAtEpoch"
}

enum LegalConsent {
    static func needsConsent(currentVersion: Int = LegalConfig.currentVersion) -> Bool {
        UserDefaults.standard.integer(forKey: LegalKeys.acceptedVersion) < currentVersion
    }
    static func recordAcceptance(currentVersion: Int = LegalConfig.currentVersion) {
        UserDefaults.standard.set(currentVersion, forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.set(Date().timeIntervalSince1970, forKey: LegalKeys.acceptedAtEpoch)
    }
    /// DEBUG: clear all acceptance so the sheet will show again
    static func clearForDebug() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
    }
}

// MARK: - File config (do NOT include .md)
/// Gate logic checks acceptedVersion < currentVersion. After you ship an update with currentVersion = 2, any user who previously accepted version 1 will see the legal sheet again on next launch.
enum LegalConfig {
    static let currentVersion = 1               // "bumping" this (1 to 2 to 3)
    static let termsFile   = "termsMarkdown"
    static let privacyFile = "privacyMarkdown"
    static let medicalFile = "medicalMarkdown"
}

// MARK: - Markdown loader (accepts base name; always reads .md from bundle)
enum MarkdownLoader {
    static func load(named name: String) -> String {
        let base: String = name.lowercased().hasSuffix(".md") ? String(name.dropLast(3)) : name
        guard let url = Bundle.main.url(forResource: base, withExtension: "md") else {
            print("⚠️ Could not find \(base).md in the main bundle.")
            return ""
        }
        do {
            return try String(contentsOf: url, encoding: .utf8)
        } catch {
            print("⚠️ \(base).md: failed to read: \(error)")
            return ""
        }
    }
}

// MARK: - Reusable Markdown screen
struct LegalDocV: View {
    let title: String
    let markdown: String

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                if let attr = try? AttributedString(markdown: markdown) {
                    Text(attr).textSelection(.enabled)
                } else {
                    Text(markdown).textSelection(.enabled)
                }
            }
            .padding()
        }
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CategoryTileList.swift ===
//
//  CategoryTileList.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI
import UniformTypeIdentifiers

struct CategoryTileList: View {
    @Binding var categoryItem: CategoriesModel
    let palette: ScreenStylePalette
    let fontTheme: AppFontTheme
    let saveHistory: () -> Void
    let isArchive: Bool
    
    var body: some View {
        if categoryItem.tiles.isEmpty {
            VStack {
                Text("Intentions Completed")
                    .font(fontTheme.toFont(.caption))
                    .foregroundStyle(palette.textSecondary)
            }
            .background(isArchive ? Color.secondary.opacity(0.08) : .clear)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isArchive ? Color.secondary.opacity(0.12) : .clear, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
        } else {
            LazyVStack(spacing: 8) {
                ForEach(categoryItem.tiles, id: \.id) { tile in
                    HStack {
                        Text(tile.text)
                            .font(fontTheme.toFont(.body))
                            .foregroundStyle(palette.text)
                            .padding()
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .background(palette.surface.opacity(0.6))
                            .clipShape(RoundedRectangle(cornerRadius: 8, style: .continuous))
                    }
                    .swipeActions(edge: .trailing, allowsFullSwipe: !isArchive) {
                        if !isArchive {
                            Button(role: .destructive) {
                                if let index = categoryItem.tiles.firstIndex(where: { $0.id == tile.id }) {
                                    withAnimation {
                                        categoryItem.tiles.remove(at: index)
                                        saveHistory()
                                    }
                                }
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    }
                }
            }
            .padding(.horizontal)
            .allowsHitTesting(!isArchive)   // Archive is read-only
            .opacity(isArchive ? 0.9 : 1.0)
        }
    }
}

-e \n\n
=== ./intention/Shared/Helpers/KeychainHelper.swift ===
//
//  KeychainHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 7/10/25.
//

import Foundation
import Security

actor KeychainHelper {
    //    any issues with KeychainHelper as an actor,
    //    change to final class KeychainHelper: @unchecked Sendable { static let standard = KeychainHelper
    //      // _ same methods, but add 'async' AND call await KeychainHelper.shared.getUserIdentifier()
    
    static let shared = KeychainHelper()
    private init() {}
    
    /// Grabs system-provided bundle ID string - `private let` restrict `service` to that file
    private let service = Bundle.main.bundleIdentifier!
    private let account = "anonymousUserID"
    
    /// Returns the existing UUID, or generates+stores a new one
    func getUserIdentifier() -> String {
        if let existing = readUUID() {
            return existing
        } else {
            let newID = UUID().uuidString
            saveUUID(newID)
            #if DEBUG
            debugPrint("KeychainHelper: newID - \(newID)")
            #endif
            return newID
        }
    }
    
    /// Keep saveUUID() and readUUID() synchronous internally - no "async"
    private func saveUUID(_ uuid: String) {
            let data = Data(uuid.utf8)
            let query: [String: Any] = [
                kSecClass as String       : kSecClassGenericPassword,
                kSecAttrService as String : service,
                kSecAttrAccount as String : account,
                kSecValueData as String   : data
            ]
            // Remove any old and add new
            SecItemDelete(query as CFDictionary)
            SecItemAdd(query as CFDictionary, nil)
        }
    
    private func readUUID() -> String? {
            let query: [String: Any] = [
                kSecClass as String       : kSecClassGenericPassword,
                kSecAttrService as String : service,
                kSecAttrAccount as String : account,
                kSecReturnData as String  : true,
                kSecMatchLimit as String  : kSecMatchLimitOne
            ]
            var result: AnyObject?
            let status = SecItemCopyMatching(query as CFDictionary, &result)
            guard status == errSecSuccess,
                  let data = result as? Data,
                  let str = String(data: data, encoding: .utf8)
            else { return nil }
            return str
        }
}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerWrapper.swift ===
//
//  TileOrganizerWrapper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/5/25.
//

import SwiftUI

// SwiftUI -> UIKit Bridge
struct TileOrganizerWrapper: UIViewControllerRepresentable {
    @Binding var categories: [CategoriesModel]
    let onMoveTile: (TileM, UUID, UUID) -> Void
    let onReorder: ([TileM], UUID) -> Void
    
    func makeUIViewController(context: Context) -> TileOrganizerVC {
        let vc = TileOrganizerVC()
        vc.onMoveTile = onMoveTile
        vc.onReorder = onReorder    // Hookup for persistencem, called in/by HistoryVM
        return vc
    }
    
    func updateUIViewController(_ uiViewController: TileOrganizerVC, context: Context) {
        uiViewController.update(categories: categories)
    }
}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerVC.swift ===
//
//  TileOrganizerVC.swift
//  intention
//
//  Created by Benjamin Tryon on 8/5/25.
//

import UIKit
// Authority on delegates and section headers - with reorder support and onReorder callback

final class TileOrganizerVC: UICollectionViewController {
    var onMoveTile: (TileM, UUID, UUID) -> Void = { _, _, _ in }
    var onReorder: (([TileM], UUID) -> Void)? = nil

    private var categories: [CategoriesModel] = []
    private var dragSourceIndexPath: IndexPath?

    init() {
        let layout = UICollectionViewFlowLayout()
        layout.sectionInset = UIEdgeInsets(top: 12, left: 16, bottom: 12, right: 16)
        layout.itemSize = CGSize(width: UIScreen.main.bounds.width - 48, height: 44)
        layout.headerReferenceSize = CGSize(width: UIScreen.main.bounds.width, height: 30)
        super.init(collectionViewLayout: layout)
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) not implemented") }

    override func viewDidLoad() {
        super.viewDidLoad()
        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "Cell")
        collectionView.register(HeaderView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: "Header")
        collectionView.dragDelegate = self
        collectionView.dropDelegate = self
        collectionView.dragInteractionEnabled = true
        collectionView.reorderingCadence = .immediate
        collectionView.backgroundColor = .clear
    }

    func update(categories: [CategoriesModel]) {
        self.categories = categories
        collectionView.reloadData()
    }

    override func numberOfSections(in collectionView: UICollectionView) -> Int {
        categories.count
    }

    override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        categories[section].tiles.count
    }

    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let tile = categories[indexPath.section].tiles[indexPath.row]
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)

        var config = UIListContentConfiguration.cell()
        config.text = tile.text
        cell.contentConfiguration = config
        cell.backgroundColor = UIColor.systemGray6
        cell.layer.cornerRadius = 8
        cell.clipsToBounds = true

        return cell
    }
    // reordering within a single category, but prevents dragging into a different category via reorder
    override func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
        guard kind == UICollectionView.elementKindSectionHeader else { return UICollectionReusableView() }
        let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: "Header", for: indexPath) as! HeaderView
        header.label.text = categories[indexPath.section].persistedInput
        return header
    }
    // reorders within a same section/ category persist with `moveItemAt()
    override func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
        guard sourceIndexPath.section == destinationIndexPath.section else {
            collectionView.reloadData()
            return
        }

        let categoryID = categories[sourceIndexPath.section].id
        var tiles = categories[sourceIndexPath.section].tiles
        let movedTile = tiles.remove(at: sourceIndexPath.row)
        tiles.insert(movedTile, at: destinationIndexPath.row)
        categories[sourceIndexPath.section].tiles = tiles

        // Persist the reorder
        onReorder?(tiles, categoryID)
    }
}

extension TileOrganizerVC: UICollectionViewDragDelegate, UICollectionViewDropDelegate {
    func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -> [UIDragItem] {
        dragSourceIndexPath = indexPath
        let tile = categories[indexPath.section].tiles[indexPath.row]
        let itemProvider = NSItemProvider(object: tile.text as NSString)
        let dragItem = UIDragItem(itemProvider: itemProvider)
        dragItem.localObject = tile
        return [dragItem]
    }

    func collectionView(_ collectionView: UICollectionView, canHandle session: UIDropSession) -> Bool {
        session.localDragSession != nil
    }

    func collectionView(_ collectionView: UICollectionView, dropSessionDidUpdate session: UIDropSession, withDestinationIndexPath indexPath: IndexPath?) -> UICollectionViewDropProposal {
        if let from = dragSourceIndexPath, let to = indexPath, from.section == to.section {
            return UICollectionViewDropProposal(operation: .move, intent: .insertAtDestinationIndexPath)
        } else {
            return UICollectionViewDropProposal(operation: .move, intent: .insertIntoDestinationIndexPath)
        }
    }

    func collectionView(_ collectionView: UICollectionView, performDropWith coordinator: UICollectionViewDropCoordinator) {
        guard
            let destinationIndexPath = coordinator.destinationIndexPath,
            let sourceIndexPath = dragSourceIndexPath,
            let item = coordinator.items.first,
            let tile = item.dragItem.localObject as? TileM
        else {
            return
        }
        // Reordering within section
        let fromCategoryID = categories[sourceIndexPath.section].id
        let toCategoryID = categories[destinationIndexPath.section].id

        onMoveTile(tile, fromCategoryID, toCategoryID)
        dragSourceIndexPath = nil
    }
}
-e \n\n
=== ./intention/Shared/Helpers/ReusableEdgePadding.swift ===
//
//  ReusableEdgePadding.swift
//  intention
//
//  Created by Benjamin Tryon on 8/26/25.
//

//import SwiftUI
//
//extension View {
//    /// Deprecated: Page owns horizontal margins. This is a no-op to avoid double padding.
//    func screenPadding() -> some View { padding(.horizontal, 16) }
//    func screenPadding() -> some View { self }
//}
-e \n\n
=== ./intention/Shared/Helpers/CategoryHeaderRow.swift ===
//
//  CategoryHeaderRow.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI

struct CategoryHeaderRow: View {
    @EnvironmentObject var viewModel: HistoryVM
    @Binding var categoryItem: CategoriesModel
    let palette: ScreenStylePalette
    let fontTheme: AppFontTheme
    @Binding var newTextTiles: [UUID: String]
    let saveHistory: () -> Void         // so onCommit can Save
    let isArchive: Bool
    var autoFocus: Bool = false
    @FocusState private var nameFocused: Bool
    
    // MARK: Validation from PM
    private var vState: ValidationState {
        let msgs = viewModel.categoryValidationMessages[categoryItem.id] ?? []
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: isArchive ? "lock.fill" : "folder.fill")
                .foregroundStyle(isArchive ? .secondary : palette.accent)
            
            if isArchive {
                Text("Archive")
                    .font(fontTheme.toFont(.title3))
                    .foregroundStyle(palette.textSecondary)
                Spacer()
                CountBadge_Archive(fontTheme: fontTheme, count: categoryItem.tiles.count)
            } else {
                VStack(alignment: .leading, spacing: 4) {
                    ZStack(alignment: .leading) {
                        if categoryItem.persistedInput.isEmpty {
                            Text("Name this category")
                                .font(fontTheme.toFont(.caption))
                                .foregroundStyle(palette.textSecondary)
                                .padding(.horizontal, 12)
                        }
                        TextField("", text: $categoryItem.persistedInput, onCommit: saveHistory)
                            .textInputAutocapitalization(.words)
                            .disableAutocorrection(true)
                            .focused($nameFocused)
                            .validatingField(state: vState, palette: palette)
                            .accessibilityLabel("Category name")
                    }
                    
                    ValidationCaption(state: vState, palette: palette)
                }
                Spacer()
                CountBadge_Archive(fontTheme: fontTheme, count: categoryItem.tiles.count)

                Button {
                    newTextTiles[categoryItem.id] = newTextTiles[categoryItem.id] ?? ""
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundStyle(palette.accent)
                }
                .accessibilityLabel("Add tile")
            }
        }
        .padding(.horizontal)
        .padding(.vertical, 8)
        .onAppear { if autoFocus && !isArchive { nameFocused = true } }
    }
}

#if DEBUG
#Preview("CategoryHeaderRow (direct)") {
    MainActor.assumeIsolated {
        let theme = ThemeManager()
        let palette = theme.palette(for: .settings)

        return CategoryHeaderRow(
            categoryItem: .constant(CategoriesModel(persistedInput: "Work")),
            palette: palette,
            fontTheme: theme.fontTheme,
            newTextTiles: .constant([:]),
            saveHistory: {},
            isArchive: false
        )
        .environmentObject(HistoryVM(persistence: PreviewMocks.persistence))
        .environmentObject(theme)
        .previewTheme()
    }
}
#endif
-e \n\n
=== ./intention/Shared/Helpers/AvailabilityTarget+.swift ===
//
//  AvailabilityTarget+.swift
//  intention
//
//  Created by Benjamin Tryon on 8/8/25.
//
import SwiftUI

// iOS 18-only helper so .bounce never appears in a broader-availability symbol
@available(iOS 18.0, *)
private extension View {
    @ViewBuilder
    func bounceSymbolEffect(isActive: Bool) -> some View {
        self.symbolEffect(.bounce, isActive: isActive)
    }
}

extension View {
    @ViewBuilder
    func symbolBounceIfAvailable(active: Bool = true) -> some View {
        if #available(iOS 18.0, *) {
            self.bounceSymbolEffect(isActive: active)               /// uses .bounce only in an iOS18 context
        } else if #available(iOS 17.0, *) {
            /// fallback for iOS 17
            self.symbolEffect(.pulse, isActive: active)
        } else {
            self
        }
    }
    
    
    @ViewBuilder
    func safeAreaTopPadding() -> some View {
        if #available(iOS 17.0, *) {
            self.safeAreaPadding(.top)      /// adjusts with device & bars
        } else {
            self.padding(.top)              /// simple fallback
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CountdownProgress.swift ===
//
//  CountdownProgress.swift
//  intention
//
//  Created by Benjamin Tryon on 7/10/25.
//

//import SwiftUI
//
//// Extracted for less noise; fontTheme and palette used directly
//struct CountdownProgress: View {
//    let progressFraction: CGFloat
//    let palette: ScreenStylePalette
//    
//    var body: some View {
//        ZStack {
//            // Background circle
//            Circle()
//                .stroke(palette.accent.opacity(0.15), lineWidth: 12)
//                .frame(width: 80, height: 80)
//            
//            // Progress pie foreground
//            Circle()
//                .trim(from: 0.0, to: progressFraction)
//                .stroke(palette.accent, style: StrokeStyle(lineWidth: 12, lineCap: .round))
//                .rotationEffect(.degrees(-90))
//                .frame(width: 80, height: 80)
//                .animation(.linear(duration: 0.5), value: progressFraction)
//        }
//    }
//}
///// See the computed property `progressFraction` in `FocusSessionActiveV`
-e \n\n
=== ./intention/Shared/Helpers/CountBadge+Archive.swift ===
//
//  CountBadge+Archive.swift
//  intention
//
//  Created by Benjamin Tryon on 8/14/25.
//

import SwiftUI

struct CountBadge_Archive: View {
    let fontTheme: AppFontTheme
    let count: Int
    
    var body: some View {
        Text("\(count)")
            .font(fontTheme.toFont(.caption2))
            .padding(.horizontal, 6).padding(.vertical, 3)
            .background(.thinMaterial)
            .clipShape(Capsule())
    }
}
-e \n\n
=== ./intention/Shared/Helpers/HeaderView.swift ===
//
//  HeaderView.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

import UIKit

final class HeaderView: UICollectionReusableView {
    let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        label.translatesAutoresizingMaskIntoConstraints = false
        addSubview(label)
        NSLayoutConstraint.activate([
            label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            label.topAnchor.constraint(equalTo: topAnchor),
            label.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
-e \n\n
=== ./intention/Shared/Helpers/ActionButtonStyle.swift ===
//
//  ActionButtonStyle.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.

import SwiftUI

struct PrimaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline)
            .padding(.vertical, 12)
            .frame(maxWidth: .infinity)
            .foregroundStyle(.white.opacity(isEnabled ? 1 : 0.7))
            .background(palette.accent.opacity(isEnabled ? (configuration.isPressed ? 0.85 : 1.0) : 0.45))
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

struct SecondaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline)
            .padding(.vertical, 12)
            .frame(maxWidth: .infinity)
            .foregroundStyle(palette.text.opacity(isEnabled ? 1 : 0.6))
            .background(palette.surface.opacity(configuration.isPressed ? 0.9 : 1.0))
            .overlay(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .stroke(palette.border, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}
struct RecalibrationActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    let palette: ScreenStylePalette
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.headline)
            .padding(.vertical, 12)
            .frame(maxWidth: .infinity)
            .foregroundStyle(.yellow.opacity(isEnabled ? 1 : 0.7))
            .background(palette.accent.opacity(isEnabled ? (configuration.isPressed ? 0.85 : 1.0) : 0.45))
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct PrimaryActionStyleEnv: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        content.buttonStyle(PrimaryActionStyle(palette: theme.palette(for: screen)))
    }
}
// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct SecondaryActionStyleEnv: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        content.buttonStyle(SecondaryActionStyle(palette: theme.palette(for: screen)))
    }
}

private struct RecalibrationActionStyleEnv: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    func body(content: Content) -> some View {
        content.buttonStyle(RecalibrationActionStyle(palette: theme.palette(for: .recalibrate)))
    }
}

extension View {
    func primaryActionStyle(screen: ScreenName) -> some View { modifier(PrimaryActionStyleEnv(screen: screen)) }
    func secondaryActionStyle(screen: ScreenName) -> some View { modifier(SecondaryActionStyleEnv(screen: screen)) }
    func recalibrationActionStyle() -> some View { modifier(RecalibrationActionStyleEnv()) }
}

/// Helper to apply ButtonStyle inside a View modifier chain
private struct _ButtonStyleWrapper<S: ButtonStyle>: ViewModifier {
    let style: S
    func body(content: Content) -> some View { content.buttonStyle(style) }
}
-e \n\n
=== ./intention/Shared/Helpers/DynamicCountdown.swift ===
//
//  DynamicCountdown.swift
//  intention
//
//  Created by Benjamin Tryon on 8/13/25.
//

import SwiftUI

struct DynamicCountdown: View {
    @ObservedObject var fVM: FocusSessionVM
    let palette: ScreenStylePalette
    
    /// Current progress size (0.0 to 1.0), passed from FocusSessionActiveV
    let progress: CGFloat
    private let activeSize: CGFloat = 200
    private let compactSize: CGFloat = 60
    
    var body: some View {
        if isActive {
            ZStack {
                Circle()
                    .fill(palette.background.opacity( 0.2))
                
                // Slightly dims pie when paused
                UnwindingPieShape(progress: progress)
                    .fill(palette.primary.opacity(fVM.phase == .paused ? 0.4 : 1.0))
                
                VStack(spacing: 4) {
                    Text("\(fVM.formattedTime)")
                        .font(.system(size: 48, weight: .bold, design: .monospaced))
                        .foregroundStyle(palette.text)
                    
                    if fVM.phase == .paused {
                        Text("Paused").font(.subheadline).foregroundStyle(.secondary)
                    }
                }
            }
            .frame(width: activeSize, height: activeSize)
            .contentShape(Circle())         // tap target matches the circle
            .onTapGesture { handleTap() }
            .accessibilityAddTraits(.isButton)
            .accessibilityLabel(fVM.phase == .paused ? "Resume" : "Pause")
            .accessibilityHint("Tap to \(fVM.phase == .paused ? "resume" : "pause") the countdown")
            .animation(.easeInOut(duration: 0.2), value: progress)
            
        } else if isBetweenChunks {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(palette.background.opacity(0.1))
                Text("✓").font(.title).foregroundStyle(palette.primary)

            }
            .frame(width: compactSize, height: compactSize)
            .transition(.opacity)
            .animation(.easeInOut(duration: 0.2), value: isBetweenChunks)
        } else {
            EmptyView()             /// Releases vertical space
        }
    }
    private var isActive: Bool {
        fVM.phase == .running ||
        fVM.phase == .paused  ||
        (fVM.phase == .finished && fVM.currentSessionChunk == 2)
    }
    
    private var isBetweenChunks: Bool {
        fVM.phase == .finished && fVM.currentSessionChunk == 1
    }

    private func handleTap() {
        if fVM.phase == .running {
            fVM.performAsyncAction { await fVM.pauseCurrent20MinCountdown() }
        } else if fVM.phase == .paused {
            fVM.performAsyncAction { try await fVM.resumeCurrent20MinCountdown() }
        }
    }
}
//
//    var body: some View {
//        
//        
//        Group {
//            if shouldShowFullTimer {
//                ZStack {
//                    Circle()
//                        .fill(palette.background.opacity(0.2))
//                        .frame(width: 200, height: 200)
//                    
//                    UnwindingPieShape(progress: progress)
//                        .fill(palette.primary)
//                    
//                    Text("\(viewModel.formattedTime)")
//                        .font(.system(size: 48, weight: .bold, design: .monospaced))
//                        .id("countdownTimer")
//                        .transition(.opacity)
//                        .foregroundStyle(palette.text)
//                }
//                .animation(.easeInOut(duration: 0.2), value: progress)
//            } else if shouldShowCompactCheckmark {
//                ZStack {
//                    Circle()
//                        .fill(palette.background.opacity(0.1))
//                        .frame(width: 60, height: 60)
//                    
//                    Text("✓")
//                        .font(.title)
//                        .foregroundStyle(palette.primary)
//                }
//                .transition(.opacity)
//                .animation(.easeInOut(duration: 0.2), value: progress)
//            }
//        }
//    }
//    private var shouldShowFullTimer: Bool {
//        viewModel.phase == .running ||
//        (viewModel.phase == .finished && viewModel.currentSessionChunk == 2)
//    }
//    
//    private var shouldShowCompactCheckmark: Bool {
//        viewModel.phase == .finished && viewModel.currentSessionChunk == 1
//    }
//}

-e \n\n
=== ./intention/Shared/Helpers/UUID_helper.swift ===
//
//  UUID_helper.swift
//  intention
//
//  Created by Benjamin Tryon on 9/12/25.
//

//import Foundation
//
//extension Array {
//    var only: Element? { count == 1 ? first : nil }
//}
-e \n\n
=== ./intention/Shared/Helpers/CategorySection.swift ===
//
//  CategorySection.swift
//  intention
//
//  Created by Benjamin Tryon on 7/21/25.
//

import SwiftUI

struct CategorySection: View {
    @Binding var categoryItem: CategoriesModel
    let palette: ScreenStylePalette
    let fontTheme: AppFontTheme
    @Binding var newTextTiles: [UUID: String]
    let saveHistory: () -> Void
    let isArchive: Bool
    var autoFocus: Bool = false
    @State private var collapsed: Set<UUID> = []

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            CategoryHeaderRow(
                categoryItem: $categoryItem,
                palette: palette,
                fontTheme: fontTheme,
                newTextTiles: $newTextTiles,
                saveHistory: saveHistory,
                isArchive: isArchive,
                autoFocus: autoFocus
            )
            
            if !collapsed.contains(categoryItem.id) {
                CategoryTileList(
                    categoryItem: $categoryItem,
                    palette: palette,
                    fontTheme: fontTheme,
                    saveHistory: saveHistory,
                    isArchive: isArchive
                )
            }
        }
        .padding(.horizontal)
        .padding(.bottom, 12)
    }
}


-e \n\n
=== ./intention/Shared/Helpers/GlowingTextModifier.swift ===
//
//  GlowingTextModifier.swift
//  intention
//
//  Created by Benjamin Tryon on 8/26/25.
//
import SwiftUI

struct PulsingBorderModifier: ViewModifier {
    @State private var pulse: Bool = false
    let isSelected: Bool                    // Uses a binding to determine if the button is active
    
    func body(content: Content) -> some View {
        content
            .padding()
            .background(Capsule().fill(Color.purple)) // The main fill remains purple
            .overlay(
                Capsule()
                    .stroke(
                        isSelected ? Color.clear : (pulse ? Color.purple.opacity(0.8) : Color.purple.opacity(0.4)), /// Pulsing effect for INACTIVE
                        lineWidth: isSelected ? 0 : (pulse ? 4 : 2)     /// Pulse
                    )
                    .shadow(
                        color: isSelected ? Color.clear : (pulse ? Color.purple.opacity(0.7) : Color.purple.opacity(0.2)),
                        radius: isSelected ? 0 : (pulse ? 10 : 5),
                        x: 0, y: 0
                    )
            )
            .animation(
                isSelected ? .none : .easeInOut(duration: 1.5).repeatForever(autoreverses: true),
                value: pulse
            )
            .onAppear {
                if !isSelected {
                    pulse = true
                }
            }
            .onChange(of: isSelected) { newValue in
                if !newValue {
                    pulse = true
                } else {
                    pulse = false
                }
            }
    }
}

extension View {
    func inactivePulsingEffect(isSelected: Bool) -> some View {
        self.modifier(PulsingBorderModifier(isSelected: isSelected))
    }
}

-e \n\n
=== ./intention/Shared/Helpers/DynamicMessageAndActionArea.swift ===
//
//  DynamicMessageAndActionArea.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

struct DynamicMessageAndActionArea: View {
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var focusVM: FocusSessionVM
//    let fontTheme: AppFontTheme       // Pass directly, is an AppStorage value
//    let palette: ScreenStylePalette   // Pass directly, is an AppStorage value
    let onRecalibrateNow: () -> Void    // Define sheet closure property, from parent (FocusSessionActiveV) to trigger logic

    
    private let screen: ScreenName = .homeActiveIntentions
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
//    init(focusVM: FocusSessionVM,
//         onRecalibrateNow: @escaping () -> Void) {
//        self._focusVM = ObservedObject(initialValue: focusVM)
//        self.onRecalibrateNow = onRecalibrateNow
//    }
            var body: some View {
                VStack(spacing: 16) {
                    if focusVM.showRecalibrate {
                        T("Session complete! Ready for recalibration?", .title3)
                            .foregroundStyle(p.text)
                            .multilineTextAlignment(.center)

                        VStack(spacing: 10) {
                            /// Allow wrapping, or text overflowing doesn't function correctly as a VStack ,not HStack
                            Button { onRecalibrateNow() } label: { T("Recalibrate Now", .action) }
                                .primaryActionStyle(screen: screen)

                            Button { focusVM.performAsyncAction { try focusVM.startCurrent20MinCountdown() } }
                            label: { T("Start Next Intention", .action) }
                                .primaryActionStyle(screen: screen)

                            Button(role: .destructive) {
                                focusVM.performAsyncAction { await focusVM.resetSessionStateForNewStart() }
                            } label: { T("End Session Early", .label) }
                        }
                    }
                    else if focusVM.currentSessionChunk == 1 && focusVM.phase == .finished {
                        T("First 20 minutes done.\nStart your next intention?", .title3)
                            .foregroundStyle(p.text)
                            .multilineTextAlignment(.center)

                        Button { focusVM.performAsyncAction { try focusVM.startCurrent20MinCountdown() } }
                        label: { T("Start Next Intention", .action) }
                            .primaryActionStyle(screen: screen)

                        Button(role: .destructive) {
                            focusVM.performAsyncAction { await focusVM.resetSessionStateForNewStart() }
                        } label: { T("End Session Early", .label) }
                    }
                    else if focusVM.phase == .running {
//                        T("Session in progress…", .body)
//                            .foregroundStyle(p.textSecondary)
//                            .multilineTextAlignment(.center)
                    }
                    else if focusVM.tiles.count < 2 {
                        T("Add your first (or second) intention above", .body)
                            .foregroundStyle(p.textSecondary)
                            .multilineTextAlignment(.center)
                    }
                    else if focusVM.phase == .notStarted {
                        T("Press Begin below to start your 20-minute focus.", .caption)
                            .foregroundStyle(p.textSecondary)
                            .multilineTextAlignment(.center)
                    }
                    else if focusVM.phase == .paused {
                        T("Paused", .caption).foregroundStyle(.secondary)
                    }
                }
                .padding(.vertical, 8)
            }
        }

-e \n\n
=== ./intention/Shared/Helpers/Helper_AppIconV.swift ===
//
//  Helper_AppIconV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

// MARK: - AppIconView
struct Helper_AppIconV: View {
    var body: some View {
        //safely unwraps uiimage from bundle extension
        if let uiImage = AppIconProvider.icon {
            // Good: have a non-optional UIImage to create a SwiftUI Image
            Image(uiImage: uiImage)
                .resizable()
                .aspectRatio(contentMode: .fit) // maintain aspect ratio
        } else {
            Image(systemName: "app.fill")   // Generic app icon SF Symbol
                .resizable()
                .aspectRatio(contentMode: .fit)
                .foregroundStyle(.intGreen)
        }
    }
}

#if DEBUG
#Preview {
    Helper_AppIconV()
        .frame(width: 50, height: 50)
        .padding()
}
#endif
-e \n\n
=== ./intention/Shared/Helpers/AppEnvironment.swift ===
//
//  AppEnvironment.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

struct AppEnvironment {
    static let isAppStoreReviewing: Bool = {
        #if DEBUG
        return false
        #else
        return true
        #endif
    }()
}
-e \n\n
=== ./intention/Shared/Services/MembershipCodeService.swift ===
//
//  MembershipCodeService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

// Apple Pay: users expect no codes. Just the StoreKit sheet → done.
// Stripe/web: a simple redeem code screen is the most anonymous and familiar approach without accounts.
/* Redeem Code Screen:

They pay, see a short code (6–10 chars).

In the app, they go to “Enter Code”, type/paste it.

App unlocks.

--Familiar from gift cards and beta programs.

-- No email or account but still feels anonymous but valid.
 */

actor MembershipCodeService {
    
    enum VerificationResult {
        case success
        case invalid
        case networkError
    }
    
    // Replace with backend URL
    private let verifyEndpoint = URL(string: "https://yourdomain.com/api/verify")!
    
    func verify(code: String, deviceID: String) async -> VerificationResult {
        // FIXME: Placeholder - similate network verification
        try? await Task.sleep(nanoseconds: 500_000_000)       // 0.5s delay

        // FIXME: In production: POST code to backend and check response
        if code.uppercased() == "INTENTION-BETA" {
            UserDefaults.standard.set(true, forKey: "isMember")
            return .success
        } else {
            return .invalid
        }
    }
}
-e \n\n
=== ./intention/Shared/Services/PersistenceActor.swift ===
//
//  PersistenceActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import Foundation

// All I/O (encoding/decoding) logic here

/// Testing seam
public protocol Persistence: Sendable {
    func write<T: Codable>(_ object: T, to key: String) async throws
    func readIfExists<T: Codable>(_ type: T.Type, from key: String) async throws -> T?
    func clear(_ key: String) async
}

/// All business logic (when to save, what to save) belongs in the VM
/// VM decides when to persist; PersistenceActor decides how (encode/decode, storage)
///     PersistenceActor continues to store the **categories list**
public actor PersistenceActor {
    public enum PersistenceActorError: Error {
        case encodingFailed(Error)
        case decodingFailed(Error)
    }
    
    // Isolated - no need for .detach elsewhere
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    
    public init() {}
}


/// Actor conforms
extension PersistenceActor: Persistence {
    
    // MARK: Generic write; crossing int othis actor requires `await` from outside
    /// Encode and Save any Codable object and write it (to UserDefaults)
    public func write<T: Codable>(_ object: T, to key: String) async throws {
        do {
            let data = try encoder.encode(object)   // object is `categories` here
            UserDefaults.standard.set(data, forKey: key)
        } catch {
            debugPrint("[PersistenceActor.saveHistory] failed to encode and save:", error)
            throw PersistenceActorError.encodingFailed(error)
        }
    }
    
    // MARK: Load a Codable object from UserDefaults
    public func readIfExists<T: Codable>(_ type: T.Type, from key: String) async throws -> T? {
        guard let data = UserDefaults.standard.data(forKey: key) else { return nil }
        do {
            return try decoder.decode(T.self, from: data)
        } catch {
            debugPrint("[PersistenceActor.loadHistory] deocding failed: ", error)
            throw PersistenceActorError.decodingFailed(error)
        }
    }
    
    // MARK: Clear stored value at a key (from UserDefaults)
    public func clear(_ key: String) async {
        UserDefaults.standard.removeObject(forKey: key) // keeps in-memory state (like categories), is seralized and background-safe
    }
}
-e \n\n
=== ./intention/Shared/Services/PaymentService.swift ===
//
//  PaymentService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/3/25.
//

import Foundation
import StoreKit

// Owns StoreKit logic of products, entitlement refresh, refunds/cancellations
/// Apple processes payment; app never sees card info; Only reads entitlements (transactions) and set isMember; keeping app "anonymous" (device-scoped)
final class PaymentService: ObservableObject {
    @Published private(set) var products: [Product] = []
    @Published private(set) var isMember: Bool = false
    
    private let membershipProductID = "com.intention.membership"
    private var updateTask: Task<Void, Never>?
    
    init() {
        /// Start updates (refunds/cancellation)  listener and hydrate state
        updateTask = listenForTransactions()
        Task { await loadProducts(); await refreshEntitlementStatus() }
    }
    
    deinit { updateTask?.cancel() }
    
    func loadProducts() async {
        do {
            products = try await Product.products(for: [membershipProductID])
        } catch {
            debugPrint("[PaymentService] Load failed: ", error)
        }
    }
    
    /// Verifies and finishes via call sites
    func purchaseMembership() async throws {
        guard let product = products.first else { return }
            let result = try await product.purchase()
            switch result {
            case .success(let verification):
                let t = try checkVerified(verification)
                await t.finish()                                        /// No `try` - it's async, not throws
                await refreshEntitlementStatus()
//                if case .verified = verification {
//                    isMember = true
//                    UserDefaults.standard.set(true, forKey: "isMember")
//                }
            case .userCancelled, .pending:
                //FIXME: overlay
                debugPrint("[PaymentService] user cancelled")
                break
            @unknown default:
                //FIXME: overlay
                debugPrint("[PaymentService] Purchase failed")
                break
        }
    }
    
    func restorePurchases() async throws {
        do {
            try await AppStore.sync()
            await refreshEntitlementStatus()
        } catch {
            debugPrint("[PaymentService] Restore failed: ", error)
        }
    }
    
    // MARK: Entitlement hydration
    func refreshEntitlementStatus() async {
        var active = false
        for await status in Transaction.currentEntitlements {
            guard case .verified(let t) = status else { continue }
            if t.productID == membershipProductID, t.revocationDate == nil {
                active = true
            }
        }
        isMember = active                                               /// Explain
    }
    
    private func listenForTransactions() -> Task<Void, Never> {
        Task {
            for await update in Transaction.updates {
                do {
                    let t = try checkVerified(update)
                    if t.productID == membershipProductID {
                        await refreshEntitlementStatus()
                    }
                    await t.finish()
                } catch {
                    debugPrint("[PaymentService] update error: ", error)
                }
            }
        }
    }
    
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe): return safe
        case .unverified(_, let err): throw err
        }
    }
    func loadMembershipState() {
        isMember = UserDefaults.standard.bool(forKey: "isMember")
    }
}
//#if DEBUG
//#Preview {
//    PaymentService()
//}
//#endIf
-e \n\n
=== ./intention/Shared/Services/AppIconProvider.swift ===
//
//  AppIconProvider.swift
//  intention
//
//  Created by Benjamin Tryon on 6/10/25.
//

import UIKit

struct AppIconProvider {
    // Returns runtime display of icon
    static var icon: UIImage? {
        return UIImage(named: "RuntimeAppIcon") // From AppDisplayIcon.imageset
    }
}

-e \n\n
=== ./intention/Shared/HelperLayout/Layout+Helpers.swift ===
//
//  Layout+Helpers.swift
//  intention
//
//  Created by Benjamin Tryon on 8/27/25.
//

import SwiftUI
/// Only the Page applies horizontal padding. Children don’t.
/// Add to any top-level screen container (ScrollView or VStack)
struct Page<Content: View>: View {
    let top: CGFloat
    let alignment: HorizontalAlignment
    let content: () -> Content
    init(top: CGFloat = 8,
         alignment: HorizontalAlignment = .leading,
         @ViewBuilder _ content: @escaping () -> Content) {
        self.top = top; self.alignment = alignment; self.content = content
    }
    var body: some View {
        /// One horizontal margin to rule them all
        VStack(alignment: alignment, spacing: 16, content: content)
            .padding(.horizontal, 16)
            .padding(.top, 8)                       /// Small top; adjust per screen
            .frame(maxWidth: .infinity, alignment: .leading)
    }
}

/// Card section with consistent look for Settings, History blocks
struct Card<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        VStack(alignment: .leading, spacing: 16, content: content)
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

/// Bottom toast that clears tab bar safely on all devices
struct BottomToast<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        content()
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
            .shadow(radius: 2, y: 1)
    }
}

-e \n\n
=== ./intention/Shared/Validation/ValidationCaption.swift ===
//
//  ValidationCaption.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct ValidationCaption: View {
    let state: ValidationState
    let palette: ScreenStylePalette

    var body: some View {
        if case .invalid(let msgs) = state {
            HStack(spacing: 6) {
                Image(systemName: "exclamationmark.triangle.fill")
                Text(msgs.joined(separator: " "))
            }
            .font(.footnote)
            .foregroundStyle(palette.danger)
            .accessibilityLabel("Validation error")
            .accessibilityHint(msgs.joined(separator: " "))
            .transition(.opacity.combined(with: .move(edge: .top)))
        }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationResults+Fuzzy.swift ===
//
//  ValidationResults+Fuzzy.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.
//

import Foundation
//
// MARK: - non-fragile assertions and Generic Result Validations
extension String {
    var categoryTitleMessages: [String] {
        var messages: [String] = []
        let trimmedTitle = trimmingCharacters(in: .whitespacesAndNewlines)

        if trimmedTitle.count > 70 { messages.append("70 character limit.") }
        if trimmedTitle.isEmpty { messages.append("A category title cannot be empty.") }

        let consecutiveCharacterPattern = "([.,?!'#@&-]){3,}"
        if trimmedTitle.range(of: consecutiveCharacterPattern, options: .regularExpression) != nil {
            messages.append("Avoid 3 or more consecutive symbols.")
        }

        let invalidCharacterPattern = "(?i)[^a-z0-9 .,?!#'@()&]"
        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
            messages.append("Title contains unsupported characters.")
        }

        return messages
    }

    var taskValidationMessages: [String] {
        var messages: [String] = []
        let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)

        if trimmed.count > 250 { messages.append("250 character limit.") }
        if trimmed.isEmpty { messages.append("Cannot be empty or just spaces.") }

        let consecutiveCharacterPattern = "(&{3,}|={3,}|<{3,}|>{3,}|\\+{3,}|,{3,}|\\.{4,})"
        let consecutiveCharacterRegex = try! NSRegularExpression(pattern: consecutiveCharacterPattern)
        if consecutiveCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
            messages.append("Avoid long runs of special symbols.")
        }

        let invalidCharacterPattern = "[^A-Za-z0-9 .,!?'-@#$%^&*()_+=/\\`~{}\\[\\]|:;\"\\\\]"
        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
            messages.append("Contains unsupported characters.")
        }
        return messages
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationState.swift ===
//
//  ValidationState.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import Foundation

enum ValidationState: Equatable {
    case none
    case valid
    case invalid(messages: [String])

    var isInvalid: Bool {
        if case .invalid = self { return true } else { return false }
    }
    var message: String? {
        if case .invalid(let msgs) = self { return msgs.joined(separator: " ") } else { return nil }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidatingField.swift ===
//
//  ValidatingField.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//


import SwiftUI

/// Visual treatment for validated fields using your ScreenStylePalette tokens
struct ValidatingField: ViewModifier {
    let state: ValidationState
    let palette: ScreenStylePalette

    func body(content: Content) -> some View {
        content
            .padding(12)
            .background(palette.surface.opacity(0.6))
            .overlay(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .stroke(state.isInvalid ? palette.danger : palette.border, lineWidth: 1)
            )
            .foregroundStyle(state.isInvalid ? palette.danger : palette.text)
            .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
    }
}

extension View {
    func validatingField(state: ValidationState, palette: ScreenStylePalette) -> some View {
        modifier(ValidatingField(state: state, palette: palette))
    }
}
-e \n\n
=== ./intention/Models/ActivityAndDataIdentifier.swift ===
//
//  ActivityAndDataIdentifier.swift
//  intention
//
//  Created by Benjamin Tryon on 7/8/25.
//

import Foundation

//  Generate UUID on first launch
//      - user identified anonymously but trackable
//  Store (locally) UUID for persistence
//  Use to track history and sessions, no User input needed
func getUserIdentifier() -> String {
    if let storedUUID = UserDefaults.standard.string(forKey: "userUUID") {
        return storedUUID
    } else {
        let newUUID = UUID().uuidString
        UserDefaults.standard.set(newUUID, forKey: "userUUID")
        return newUUID
    }
}
-e \n\n
=== ./intention/Models/TileM.swift ===
//
//  TileM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//


import Foundation

// Representative of a single user-created "intention" tile
//  supports JSON encoding
struct TileM: Identifiable, Sendable, Codable, Hashable {
    let id: UUID
    var text: String
    var timeStamp: Date
    
    init(text: String) {
        self.id = UUID()
        self.text = text
        self.timeStamp = Date()
    }
}
-e \n\n
=== ./intention/Models/CategoriesModel.swift ===
//
//  Categories.swift
//  intention
//
//  Created by Benjamin Tryon on 7/12/25.
//

import Foundation
import SwiftUI

// MARK: - Inject a known, stable ID
// Updates the initializer with an external ID assignment
struct CategoriesModel: Identifiable, Codable {
    let id: UUID
    var persistedInput: String
    var tiles: [TileM]
    
    init(id: UUID = UUID(), persistedInput: String, tiles: [TileM] = []) {
        self.id = id
        self.persistedInput = persistedInput
        self.tiles = tiles
    }
}
-e \n\n
