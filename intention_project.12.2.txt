=== ./IntentionUITests/IntentionUITestsLaunchTests.swift ===
//
//  IntentionUITestsLaunchTests.swift
//  IntentionUITests
//
//  Created by Benjamin Tryon on 9/16/25.
//

//import XCTest
//
//final class IntentionUITestsLaunchTests: XCTestCase {
//
//    override class var runsForEachTargetApplicationUIConfiguration: Bool {
//        true
//    }
//
//    override func setUpWithError() throws {
//        continueAfterFailure = false
//    }
//
//    @MainActor
//    func testLaunch() throws {
//        let app = XCUIApplication()
//        app.launch()
//
//        // Insert steps here to perform after app launch but before taking a screenshot,
//        // such as logging into a test account or navigating somewhere in the app
//
//        let attachment = XCTAttachment(screenshot: app.screenshot())
//        attachment.name = "Launch Screen"
//        attachment.lifetime = .keepAlways
//        add(attachment)
//    }
//}
-e \n\n
=== ./IntentionUITests/IntentionUITests.swift ===
//
//  IntentionUITests.swift
//  IntentionUITests
//
//  Created by Benjamin Tryon on 9/16/25.
//

@testable import intention
import XCTest

final class IntentionUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
-e \n\n
=== ./intention/App/intentionApp.swift ===
//
//  intentionApp.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

@main
struct intentionApp: App {
    /// Theme is the source of truth for colors at launch.
    
    init(){
        // Match launch color immediately
        UIWindow.appearance().backgroundColor = UIColor(named: "AppBackground")
    }
    var body: some Scene {
        WindowGroup {
            RootView()
                .background(Color("AppBackground").ignoresSafeArea())
        }
    }
}

-e \n\n
=== ./intention/App/RootView.swift ===
//
//  RootView.swift
//  intention
//
//  Created by Benjamin Tryon on 6/19/25.
//
//What’s happening (why it “finishes”)


import SwiftUI

// MARK: - FocusShell

/// Centralizes per-screen chrome (backgrounds, overlays, sheets)
/// Keep it under 15 lines: Swift won't yell and this avoids deep view chains
struct FocusShell<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    
    @ViewBuilder var content: Content
    
    var body: some View {
        let pal = theme.palette(for: screen)
        // content sits directly on the ZStack background
        let contentWithNoBackground = content
        
        ZStack {
            // Applies full-screen background
            if let g = pal.gradientBackground {
                LinearGradient(
                    colors: g.colors, startPoint: g.start, endPoint: g.end
                )
                    .ignoresSafeArea()
            } else {
                pal.background.ignoresSafeArea()
            }
            // actual content view
            contentWithNoBackground
        }
    }
}

// MARK: - RootSheet

/// sheets presented from the root - Swift won't yell and this avoids deep view chains
enum RootSheet: Identifiable, Equatable {
    case legal, terms, privacy, medical
    
    var id: String {
        switch self {
        case .legal: return "legal"
        case .terms: return "terms"
        case .privacy: return "privacy"
        case .medical: return "medical"
        }
    }
}

#if DEBUG
extension RootView {
    func _resetLegalGate() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
        activeSheet = .legal
    }
}
#endif


// MARK: Global AppErrorOverlayManager
// Use MainActor to ensure all state changes happen on the main thread safely.
@MainActor
final class AppOverlayManager: ObservableObject {
    @Published var debugErrorTitle: String = ""
    @Published var debugErrorMessage: String = ""
    @Published var isShowingDebugError = false
    
    init() {
        // This sets up the observer when the manager is initialized.
        NotificationCenter.default.addObserver(
            forName: .debugShowSampleError, object: nil, queue: nil // Ensures UI updates happen safely
        ) { [weak self] note in
            Task { @MainActor in
            guard let self = self else { return }
            // Extract the data payload + self.Update the state to trigger the overlay
            let userInfo = note.userInfo
                self.debugErrorTitle = userInfo?[DebugNotificationKey.errorTitle] as? String ?? "Debug Error"
                self.debugErrorMessage = userInfo?[DebugNotificationKey.errorMessage] as? String ?? "No debug message provided."
            self.isShowingDebugError = true
            }
        }
    }
}

/// App entry. Owns and wires shared VMs/actors. Presents paywall and legal.
/// Keeps single sources of truth at the root and centralizes scene handling.
struct RootView: View {
    
    // MARK: AppStorage (legal gate)
    // Last accepted legal version.
    @AppStorage(LegalKeys.acceptedVersion) private var acceptedVersion: Int = 0
    // Acceptance timestamp (epoch seconds).
    @AppStorage(LegalKeys.acceptedAtEpoch) private var acceptedAtEpoch: Double = 0
    
    // MARK: presentation
    // Which root-level sheet is visible (legal, membership, etc).
    @State private var activeSheet: RootSheet?
    @State private var isShowingMembershipDebug = false
    // Global "busy, Loading" overlay.
    @State private var isBusy = false
    
    // MARK: Injecting Global ErrorOverlay Manager
    @StateObject private var overlayManager = AppOverlayManager()
    
    // MARK: Scene
    /// Scene phase guardrail: pause timers, flush history, warms haptics.
    @Environment(\.scenePhase) private var scenePhase
    
    // MARK: Single sources of truth (owned here, injected downward)
    @StateObject private var theme: ThemeManager
    @StateObject private var memVM: MembershipVM
    @StateObject private var historyVM: HistoryVM
    @StateObject private var focusVM: FocusSessionVM
    @StateObject private var recalVM: RecalibrationVM
    @StateObject private var statsVM: StatsVM
    @StateObject private var prefs: AppPreferencesVM
    @StateObject private var hapticsEngine: HapticsService // warmed generators (UI object)
    @StateObject private var debug = DebugRouter()
    
    /// Builds once: create infrastructure: actors/services, wire VM for "when", actors for "how", and assign to `@StateObject` wrappers.
    init() {
        // Infra actors/services
        let persistence     = PersistenceActor()
        let config          = TimerConfig.current
        
        // Plain instances (no self) of Services / VMs
        let theme           = ThemeManager()
        let payments        = PaymentService(productIDs: ["com.argonnesoftware.intention"])
        let membership      = MembershipVM(payment: payments)
        let prefs           = AppPreferencesVM()
        let engine          = HapticsService()
        let liveHaptics     = LiveHapticsClient(prefs: prefs, engine: engine)
        let history         = HistoryVM(persistence: persistence)
        let focus           = FocusSessionVM(previewMode: false, haptics: liveHaptics, config: config)
        let recal           = RecalibrationVM(haptics: liveHaptics)
        let stats           = StatsVM(persistence: persistence)
        
        // Wiring
        focus.historyVM     = history    // Focus writes completions into History
        stats.memVM         = membership // Stats can query membership state

        recal.onCompleted = { [weak stats, weak focus] (mode: RecalibrationMode) in
            guard let stats = stats else { return }
            
            let texts = focus?.tiles.map(\.text) ?? []
            stats.logSession(CompletedSession(
                date: .now,
                tileTexts: texts,
                recalibration: mode
            ))
            Task { @MainActor in
                await focus?.resetSessionStateForNewStart()
                // ensures session is back to idle & is fresh
                // & recal Completes, the fullScreenCover bound to $focusVM.showRecalibrate dismisses itself
                focus?.showRecalibrate = false
            }
        }
        
        // Assign "wrappers" `_StateObject` backing vars
        _theme          = StateObject(wrappedValue: theme)
        _memVM          = StateObject(wrappedValue: membership)
        _historyVM      = StateObject(wrappedValue: history)
        _focusVM        = StateObject(wrappedValue: focus)
        _recalVM        = StateObject(wrappedValue: recal)
        _statsVM        = StateObject(wrappedValue: stats)
        _prefs          = StateObject(wrappedValue: prefs)
        _hapticsEngine  = StateObject(wrappedValue: engine)
    }
    
    // MARK: Body
    var body: some View {
        // shared palette locals help calm the swift type-checker
        let palFocus        = theme.palette(for: .focus)
        let _               = theme.palette(for: .history)
        let _               = theme.palette(for: .settings)
        let _               = theme.palette(for: .recalibrate)
        let _               = theme.palette(for: .membership)
        let tabBG           = palFocus.background.opacity(0.88) // Makes tab bar match app theme (iOS 16+)
        
        
        // Focus Tab
        let focusContent    = FocusSessionActiveV(
            focusVM: focusVM,     // not viewModel:focusVM - focusVM: focusVM matches view's property name
            recalibrationVM: recalVM
        )
            .scrollDismissesKeyboard(.interactively)
        
        let focusScreen     = FocusShell(screen: .focus) {
            focusContent
        }
        
        let focusNav        = NavigationStack {
            focusScreen
                .navigationTitle("Focus")
                .navigationBarTitleDisplayMode(.inline)
            // Sets Icon tint
                .tint(palFocus.accent)
                // Force title to p.text otherwise
                .foregroundStyle(palFocus.text)
        }
            .tabItem { Image(systemName: "timer") }
        
        // History Tab
        let historyContent  = HistoryV(viewModel: historyVM)
        let historyScreen   = FocusShell(screen: .history) { historyContent }
        let historyNav      = NavigationStack {
            historyScreen
                .navigationTitle("History")
                .navigationBarTitleDisplayMode(.inline)
            // Uses focus's default accent (Leaf) - despite "History"
            .tint(palFocus.accent)
            // Force title to p.text otherwise
            .foregroundStyle(palFocus.text)
        }
            .tabItem { Image(systemName: "clock") }
        
        // Settings Tab (drives stats, membership, ...)
        let settingsContent = SettingsV(statsVM: statsVM)
        let settingsScreen  = FocusShell(screen: .settings) { settingsContent }
        let settingsNav     = NavigationStack {
            settingsScreen
                .navigationTitle("Settings")
                .navigationBarTitleDisplayMode(.inline)
            // Uses focus's default accent (Leaf) - despite "Settings"
            .tint(palFocus.accent)
            // Force title to p.text otherwise
            .foregroundStyle(palFocus.text)
        }
            .tabItem { Image(systemName: "gear") }
        
        // Tabs built as a *local* keeps long chains out of top-level expression
        let tabs    = TabView {
            focusNav
            historyNav
            settingsNav
        }
        
        // Wrapped to apply shares (apply tab icon coloring, shared toolbars, backgrounds)
        let content = tabs
            .tint(palFocus.accent)
            .toolbarBackground(tabBG, for: .tabBar)
            .toolbarBackground(.visible, for: .tabBar)
        
        content
        // the shared environment
            .environmentObject(theme)
            .environmentObject(statsVM)
            .environmentObject(memVM)
            .environmentObject(historyVM)
            .environmentObject(prefs)
            .environmentObject(hapticsEngine)
            .environmentObject(focusVM)
            .environmentObject(debug)
            .progressOverlay($isBusy, text: "Loading...")
        // Applies current screen theme to background
            .toolbarBackground(tabBG, for: .navigationBar)
            .environmentObject(overlayManager)
//            .sceneHandlers
//            .launchHandlers
//            .membershipHandlers
//            .rootSheets(activeSheet: $activeSheet, memVM: memVM)
        
        // MARK: App lifecycle (guardrail: scene handling lives at root)
            .onChange(of: scenePhase, perform: { phase in
                // Only set busy for background/inactive phases where a long-running Task might fire
                switch phase {
                case .inactive, .background:
                    isBusy = true
                    Task {
                        defer { isBusy = false }      // Ensure reset after Task completes
                        // 1) coalesce + persist any pending History saves now
                        historyVM.flushPendingSaves()
                        // 2) snapshot focus session state (not a pause)
                        await focusVM.suspendTickingForBackground()
                        isBusy = false
                    }
                
                // Active state only calls short synchronous functions
                case .active:
                    isBusy = true
                    // 3) recompute remaining (time) from snapshot & resume UI ticking if needed
                    recalVM.appDidBecomeActive()
                    Task {
                        await focusVM.resumeTickingAfterForeground(); isBusy = false
                    }
                default: break
                }
            })
        // MARK: App launch + restore any active session state + legal gate
            .onAppear {
                // Set isBusy for the main async launch process
                isBusy = true
                Task {
                    // Ensure reset after All appear tasks
                    defer { isBusy = false }
                    
                    if !IS_PREVIEW {
                        await focusVM.restoreActiveSessionIfAny();
                        // Synchronous, but wrapped in the main Task
                        hapticsEngine.warm()
                        if LegalConsent.needsConsent() {
                            // Keeping the legal sheet on the main thread
                            await MainActor.run { activeSheet = .legal }
                        }
                    } else {
                        // Previews: no ticking, no persistence, no sheets
                    }
                    // implemented as a no-op wrapper than just calls prepare()
                    hapticsEngine.warm()
                    
                    // Wrapped in #if debug to not affect release
#if DEBUG
                    if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
                        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
                        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
                        if !IS_PREVIEW { activeSheet = .legal }
                    }
#endif
                    
                }
            }

        // MARK: Sheets
            .sheet(item: $activeSheet) { sheet in
                switch sheet {
                case .legal:
                    LegalAgreementSheetV(
                        onAccept: {
                            LegalConsent.recordAcceptance()
                            acceptedVersion = LegalConfig.currentVersion
                            acceptedAtEpoch = Date().timeIntervalSince1970
                            activeSheet = nil
                        },
                        onShowTerms: { activeSheet = .terms },
                        onShowPrivacy: { activeSheet = .privacy },
                        onShowMedical: { activeSheet = .medical }
                    )
                    .environmentObject(theme)
                    
                case .terms:
                    NavigationStack {
                        LegalDocV(
                            title: "Terms of Use",
                            markdown: MarkdownLoader.load(named: LegalConfig.termsFile),
                            palette: theme.palette(for: .settings)
                        )
                    }
                    .environmentObject(theme)
                    
                case .privacy:
                    NavigationStack {
                        LegalDocV(
                            title: "Privacy Policy",
                            markdown: MarkdownLoader.load(named: LegalConfig.privacyFile),
                            palette: theme.palette(for: .settings)
                        )
                    }
                    .environmentObject(theme)
                    
                case .medical:
                    NavigationStack {
                        LegalDocV(
                            title: "Wellness Disclaimer",
                            markdown: MarkdownLoader.load(named: LegalConfig.medicalFile),
                            palette: theme.palette(for: .settings)
                        )
                    }
                    .environmentObject(theme)
                }
            }
        // ========== DEBUG PRESENTATION WIRING ==========
        // Recalibration "sheet" as a full-screen chrome for debug
            .fullScreenCover(isPresented: $debug.showRecalibration) {
                RecalibrationSheetChrome(onClose: { debug.showRecalibration = false }) {
                    // Use a minimal mock for debug rendering ONLY here.
                    // (Does not mutate live session state.)
                    RecalibrationV(vm: RecalibrationVM.mockForDebug())
                }
                .environmentObject(theme)
            }
        
            .fullScreenCover(isPresented: memVM.showSheetBinding) {
                MembershipSheetChrome(onClose: {
                    // close the chrome and tell the VM to stop prompting
                    memVM.shouldPrompt = false
                }) {
                    NavigationStack {
                        MembershipSheetV()
                            .navigationBarHidden(true)  // chrome owns close
                            .environmentObject(memVM)
                            .environmentObject(theme)
                    }
                    .interactiveDismissDisabled(false)
                }
                //        .onDisappear { memVM.shouldPrompt = false }
            }
            .onChange(of: debug.showError) { show in
                if show {
                    overlayManager.debugErrorTitle = debug.errorTitle
                    overlayManager.debugErrorMessage = debug.errorMessage
                    overlayManager.isShowingDebugError = true
                    debug.showError = false
                }
            }

    }
}
-e \n\n
=== ./intention/App/ThemeManager.swift ===
//
//  AppThemeManager.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//
import SwiftUI
import UIKit
// views will use local color constants for validation, border, and secondary text
// Shim: keep code compiling that expects ThemePalette, if any still refer to it!

typealias ThemePalette = ScreenStylePalette

// -- Use a material background (which applies a subtle blur/opacity)
//    .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 8))
// modern approach in Swift for non-shadow readability.
// It automatically ensures the text's background contrasts with the content behind it, boosting legibility without adding an explicit shadow
// MARK: Screens
enum ScreenName {
    case focus, history, settings, recalibrate, membership
    //    case focus, history, settings, organizer, recalibrate, membership
}
// MARK: Text roles
enum TextRole {
    case largeTitle, header, section, title3, label, body, tile, secondary, caption, action, placeholder
}

// MARK: - Loader with fallbacks (safe)
private extension Color {
    static func app(_ name: String, fallback: Color, bundle: Bundle = .main) -> Color {
        // Prefer the color asset if it exists
        if let ui = UIColor(named: name, in: bundle, compatibleWith: nil) {
            return Color(uiColor: ui)
        } else {
            #if DEBUG
            print("[Theme] Missing color asset '\(name)'. Using fallback.")
            #endif
            return fallback
        }
    }
}


// MARK: - ScreenStylePalette
//Per-screen color tokens
struct ScreenStylePalette {
    let primary: Color          // secondary button bg or highlighting
    let background: Color       // main pages
    let surfaces: Color          // card color, tab bars, // RENAME
    let accent: Color          // CTA color - use for fill
    let text: Color
    
    struct LinearGradientSpecial {
        let colors: [Color]
        let start: UnitPoint
        let end: UnitPoint
    }
    let gradientBackground: LinearGradientSpecial?      // nil == use `background` color
    
    // specifically for ErrorOverlay
    struct RadialGradientSpecial {
        let colors: [Color]
        let center: UnitPoint
        let startRadius: CGFloat
        let endRadius: CGFloat
    }
    // Uses Color.black for guaranteed darkness/contrast
    let radialBackground: RadialGradientSpecial = .init(
        colors: [
            Color.black.opacity(0.8), // Inner (visible, near black)
            Color.black.opacity(0.4), // Middle blend
            Color.clear             // Outer (faded)
        ],
        center: .center,
        startRadius: 0, // Starts at the center
        endRadius: 500 // Adjust this value to control the fade distance
    )
}

// MARK: - App Font Theme
enum AppFontTheme: String, CaseIterable {
    case serif, rounded, mono
    var displayName: String { self == .serif ? "Serif" : self == .rounded ? "Rounded" : "Mono" }
    func toFont(_ style: Font.TextStyle) -> Font {
        let design: Font.Design = switch self {
        case .serif: .serif
        case .rounded: .rounded
        case .mono: .monospaced
        }
        return .system(style, design: design)
    }
}

// MARK: Color Constants
// Theme Name,Background Feel,Primary Text,Vibrant Accent
// Pale Apricot,"Warm, Soft, Encouraging",Deep Umber (#4A3B1C),Electric Blue (#007AFF)
// Sea,"Cool, Crisp, Professional",Deep Teal (#1C3B4A),Vibrant Citron (#B5C808)
// Dusk,"Subtle, Clean, Elegant",Very Dark Plum (#1A161E),Deep Rose (#C83264)
// Primary Background: Pale Apricot (FBF6F3) - Soft & Encouraging

// MARK: - DefaultColors (Assets are the truth)
//private enum DefaultColors {
//    // Apricot FBF6F3
//    static let backgroundLight = Color(red: 0.984, green: 0.965, blue: 0.953)
//    
//    // Surfaces/Card: Slightly darker Apricot (F4EDE9) - Subtle Warm Depth
//    static let surfaces = Color(red: 0.957, green: 0.929, blue: 0.914)
//    
//    // Accent: Electric Blue (007AFF) - High-impact CTA
//    static let accent = Color(red: 0.000, green: 0.480, blue: 1.000)
//    
//    // Deep Umber (4A3B1C) - High contrast & Warm
//    static let text = Color(red: 0.290, green: 0.231, blue: 0.110)
//    
//    // Dark Text/Surface (Recalibrate): Same as text for consistency
//    static let topDark = text // #4A3B1C
//    // Recalibrate bottom light: Matches background for clean transition
//    static let bottomLight = backgroundLight // #FBF6F3
//}

//// New Primary Background: Pale Dusk Gray (F8F6FA) - Subtle & Clean
private enum DefaultColors {
    
    static let backgroundLight = Color.app("AppBackground",
                                           fallback: Color(red: 0.973, green: 0.965, blue: 0.980)) // F8F6FA
        .opacity(1) // no-op; forces load
   static let surfaces        = Color.app("AppSurfaces",
                                       fallback: Color(red: 0.937, green: 0.922, blue: 0.953)) // EFEBF3
    static let accent          = Color.app("AppAccent",
                                       fallback: Color(red: 0.784, green: 0.196, blue: 0.392)) // C83264)
    static let text            = Color.app("AppText",
                                       fallback: Color(red: 0.102, green: 0.086, blue: 0.118)) // 1A161E
    
    // Fallbacks for previews / missing assets
    // (used only if the asset is absent in a preview-only context)
//    static let _fallbackBackground = Color(red: 0.973, green: 0.965, blue: 0.980) // F8F6FA
//    static let _fallbackSurfaces    = Color(red: 0.937, green: 0.922, blue: 0.953) // EFEBF3
//    static let _fallbackAccent     = Color(red: 0.784, green: 0.196, blue: 0.392) // C83264
//    static let _fallbackText       = Color(red: 0.102, green: 0.086, blue: 0.118) // 1A161E
    static let _topDark = text // Dark Text/Surface (Recalibrate): Same as text for consistency
    static let bottomLight = backgroundLight // Recalibrate bottom light: Matches new background for clean transition
//    static let backgroundLight = Color(red: 0.973, green: 0.965, blue: 0.980)
//
//    // New Surface/Card: Slightly darker Dusk Gray (EFEBF3) - Elegant Depth
//    static let surface = Color(red: 0.937, green: 0.922, blue: 0.953)
//
//    // New Accent: Deep Rose (C83264) - Vibrant CTA
//    static let accent = Color(red: 0.784, green: 0.196, blue: 0.392)
//
//    // Text: Very Dark Plum (1A161E) - Highest contrast
//    static let text = Color(red: 0.102, green: 0.086, blue: 0.118)
//
//    // Dark Text/Surface (Recalibrate): Same as text for consistency
//    static let topDark = text // #1A161E
//    // Recalibrate bottom light: Matches new background for clean transition
//    static let bottomLight = backgroundLight // #F8F6FA
}

// Primary Background: Pale Blue-Gray (F3F6F9) - Crisp & Calm
private enum SeaDefaultColors {
    static let backgroundLight = Color(red: 0.953, green: 0.965, blue: 0.976)
    
    // Surface/Card: Slightly darker Blue-Gray (E7ECF1) - Subtle Cool Depth
    static let surfaces = Color(red: 0.906, green: 0.925, blue: 0.945)
    
    // Accent: Vibrant Citron (B5C808) - Engaging CTA
    static let accent = Color(red: 0.710, green: 0.784, blue: 0.031)
    
    // Text: Deep Teal/Navy (1C3B4A) - High contrast & Professional
    static let text = Color(red: 0.110, green: 0.231, blue: 0.290)
    
    // Dark Text/Surface (Recalibrate): Same as text for consistency
    static let topDark = text // #1C3B4A
    // Recalibrate bottom light: Matches new background for clean transition
    static let bottomLight = backgroundLight // #F3F6F9
    
    // Define a gradient for the theme
    static let gradient: ScreenStylePalette.LinearGradientSpecial = .init(
        colors: [
            // Darker blue for the top for depth
            Color(red: 0.15, green: 0.35, blue: 0.45), // Dark Teal
            Color(red: 0.3, green: 0.5, blue: 0.6),    // Middle Blue
            backgroundLight                          // Light base
        ],
        start: .top,
        end: .bottom
    )
}

//
//
//// MARK: OrganizerOverlay
//private enum OrgBG {
//    // TopLight and BottomDark are now assigned based on the new backgroundMedium color if needed
//    static let topLight = DefaultColors.backgroundLight
//    static let middleLight = DefaultColors.backgroundMiddle
//    static let bottomDark = DefaultColors.backgroundMedium
//}

// MARK: Recalibrate Sheet
private enum RecalibrateBG {
    static let gradient: ScreenStylePalette.LinearGradientSpecial = .init(
        colors: [
            DefaultColors.text.opacity(0.96),   // top: very dark
            DefaultColors.text.opacity(0.88),   // soften banding
            DefaultColors.backgroundLight       // bottom: page bg
        ],
        start: .top, end: .bottom
    )
    static let bottomLight = DefaultColors.backgroundLight
}
// MARK: Membership Sheet
private enum MembershipBG {
    static let gradient: ScreenStylePalette.LinearGradientSpecial = .init(
        colors: [
            DefaultColors.accent.opacity(0.92),
            DefaultColors.accent.opacity(0.75),
            DefaultColors.surfaces                 // calmer base for legibility
        ],
        start: .topLeading, end: .bottomTrailing
    )
}


// MARK: - App Color Theme → per-screen palettes
enum AppColorTheme: String, CaseIterable {
    case `default`, sea
    
    var displayName: String {
        switch self {
        case .default: "Default"
        case .sea: "Sea"
        }
    }
    
    // Show fewer choices in Settings without deleting anything.
    // Change this list whenever you want to expose more/less.
    static var publicCases : [AppColorTheme] { [.default, .sea] }
    
    func colors(for screen: ScreenName) -> ScreenStylePalette {
        switch self {
        case .default:
            switch screen {
            case .focus, .history, .settings:
                return .init(
                    primary: DefaultColors.surfaces,             // secondary/quiet CTAs
                    background: DefaultColors.backgroundLight,    // Page BG
                    surfaces: DefaultColors.surfaces.opacity(0.85), // card/surface (slightly lighter)
                    accent: DefaultColors.accent,                  // CTA color (citron)
                    text: DefaultColors.text,                   // primary text color (dark gray)
                    gradientBackground: nil
                )
                
            case .recalibrate:
                return .init(
                    primary: DefaultColors.text,
                            background: RecalibrateBG.bottomLight,
                            surfaces: DefaultColors.surfaces.opacity(0.12),
                            accent: DefaultColors.accent,
                            text: Color.white,                        // over dark gradient top
                            gradientBackground: RecalibrateBG.gradient
                    )
                
            case .membership:
                return .init(
                    primary: DefaultColors.accent,
                       background: DefaultColors.backgroundLight,
                       surfaces: DefaultColors.surfaces.opacity(0.96),
                       accent: DefaultColors.accent,
                       text: DefaultColors.text,                 // content mostly on light tones
                       gradientBackground: MembershipBG.gradient
                )
                //
                //            case .organizer:
                //                // superior contrast (6.1:1) against the light gradient
                //                /*#7b6428*/ let organizerText = Color(red: 0.4824, green: 0.3922, blue: 0.1569)
                //                return .init(
                //                    primary: DefaultColors.accent,               // CTA color (citron)
                //                    background: .clear,                         // clear, to see gradient
                //                    surface: .clear,                            // let gradient breath
                //                    accent: organizerText,                      // toolbar tint (X button, etc)
                //                    text: organizerText,          // primary text
                //                    gradientBackground: .init(
                //                        colors: [OrgBG.topLight, OrgBG.bottomDark],
                //                        start: .topLeading,
                //                        end: .bottomTrailing // ↖️ Diagonal flow
                //                    )
                //                )
            }
            
            // MARK: - Sea
        case .sea:
            switch screen {
            case .focus, .history, .settings:
                return .init(
                    primary: SeaDefaultColors.surfaces, // Using Surface as primary (e.g., secondary button)
                    background: SeaDefaultColors.backgroundLight, // Using the dark base color for solid BG
                    surfaces: SeaDefaultColors.surfaces.opacity(0.85), // Frosted surface card
                    accent: SeaDefaultColors.accent,
                    text: SeaDefaultColors.text,
                    gradientBackground: nil
                )
                
            case .recalibrate:
                // Unique Gradient Direction: Diagonal
                return .init(
                    primary: SeaDefaultColors.topDark, // Dark primary tint (deep teal)
                    background: SeaDefaultColors.bottomLight, // Light solid fallback
                    surfaces: SeaDefaultColors.surfaces.opacity(0.15), // Frosted cards
                    accent: SeaDefaultColors.accent,
                    text: SeaDefaultColors.text,            // light text color (light background) for contrast over the dark top of gradient
                    gradientBackground: SeaDefaultColors.gradient // Sea Theme Recalibrate Gradient (Defined in SeaDefaultColors)
                )
                
            case .membership:
                // Unique Gradient Direction: Horizontal
                // Uses the Sea theme's specific gradient and colors
                return .init(
                    primary: SeaDefaultColors.surfaces,
                    background: SeaDefaultColors.backgroundLight, // Dark solid fallback
                    surfaces: SeaDefaultColors.surfaces.opacity(0.85),
                    accent: SeaDefaultColors.accent,
                    text: SeaDefaultColors.text,
                    // Reusing Sea's defined gradient but changing direction for variety
                                        gradientBackground: .init(
                                            colors: SeaDefaultColors.gradient.colors,
                                            start: .leading,
                                            end: .trailing // ➡️ Horizontal flow
                                        )
                )
                //
                //            case .organizer:
                //                // Unique Gradient Direction: Vertical
                //                    return .init(
                //                        primary: SeaDefaultColors.surface,
                //                        background: .clear, // clear, to see gradient through FocusShell
                //                        surface: SeaDefaultColors.surfaces.opacity(0.12),
                //                        accent: SeaDefaultColors.accent,
                //                        text: SeaDefaultColors.text,
                //                        gradientBackground: .init(
                //                            colors: seaGradientColors,
                //                            start: .top,
                //                            end: .bottom // ⬇️ Vertical flow
                //                        )
                //                        )
            }
        }
    }
}

// MARK: - Theme Manager
@MainActor
final class ThemeManager: ObservableObject {
    @AppStorage("selectedColorTheme") private var colorRaw: String = AppColorTheme.default.rawValue
    @AppStorage("selectedFontTheme")  private var fontRaw: String = AppFontTheme.serif.rawValue
    
    @Published var colorTheme: AppColorTheme {
        didSet { colorRaw = colorTheme.rawValue }
    }
    @Published var fontTheme: AppFontTheme {
        didSet { fontRaw  = fontTheme.rawValue  }
    }
    
    init() {
        let storedColor = UserDefaults.standard.string(forKey: "selectedColorTheme") ?? AppColorTheme.default.rawValue
        let storedFont  = UserDefaults.standard.string(forKey: "selectedFontTheme")  ?? AppFontTheme.serif.rawValue
        self.colorTheme = AppColorTheme(rawValue: storedColor) ?? .default
        self.fontTheme  = AppFontTheme(rawValue: storedFont)  ?? .serif
    }
    
    func palette(for screen: ScreenName) -> ScreenStylePalette {
        colorTheme.colors(for: screen)
    }
    
    func styledText(_ content: String, as role: TextRole, in screen: ScreenName) -> Text {
        let font  = fontTheme.toFont(Self.fontStyle(for: role))
        let color = Self.color(for: role, palette: palette(for: screen))
        
        let weight: Font.Weight = switch role {
        case .largeTitle:   .bold
        case .header:       .semibold
        case .section:      .semibold
        case .title3:       .semibold
        case .label:        .semibold
        case .action:       .semibold
        case .tile:         .medium         // .medium improves tile text on light chips
        default: .regular
        }
        return Text(content).font(font).fontWeight(weight).foregroundColor(color)
    }

    static func fontStyle(for role: TextRole) -> Font.TextStyle {
        switch role {
        case .largeTitle: .largeTitle
        case .header: .largeTitle
        case .section: .title2
        case .title3:.title3
        case .label: .headline
        case .action:.headline
        case .body: .body
        case .tile: .body
        case .secondary: .subheadline
        case .placeholder: .subheadline
        case .caption: .caption
        }
    }
    
    static func color(for role: TextRole, palette: ScreenStylePalette) -> Color {
        switch role {
        case .header, .section, .title3, .body, .tile, .largeTitle, .label:
            return palette.text
        case .secondary, .caption:
            return palette.text.opacity(0.80)
            
        case .placeholder:
            return palette.text.opacity(0.70)
        case .action:
            // Actions (buttons) often use white/light text for contrast against a filled background.
            return .white
        }
    }
}

// MARK: - ThemeSwatches
struct ThemeSwatches: View {
    var body: some View {
        let bg = DefaultColors.backgroundLight
        let sf = DefaultColors.surfaces
        let ac = DefaultColors.accent
        let tx = DefaultColors.text
        HStack(spacing: 12) {
            ForEach([("BG", bg), ("SF", sf), ("AC", ac), ("TX", tx)], id:\.0) { label, c in
                VStack {
                    Circle().fill(c).frame(width: 44, height: 44)
                    Text(label).font(.caption)
                }
            }
        }
        .padding().background(bg).clipShape(RoundedRectangle(cornerRadius: 12))
    }
}

// MARK: Bridge
// Global app-wide background bridge for App entry / UIKit surfaces.
extension ThemeManager {
    static var appBackgroundColor: Color {
        // Use the default color theme and the Focus screen palette
        AppColorTheme.default.colors(for: .focus).background
    }
}

// MARK: - Legacy / Utility Colors (Cleaned up)
extension Color {
    // New utility color for actions where white might be too harsh
    static let intText = Color(red: 0.96, green: 0.96, blue: 0.96) // #F5F5F5
    
    static let intGreen = Color(red: 0.231, green: 0.733, blue: 0.639) // #3BBBA3
    
}
-e \n\n
=== ./intention/Features/Settings/SettingsLegalSection.swift ===
//
//  SettingsLegalSection.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

import SwiftUI

struct SettingsLegalSection: View {
    @EnvironmentObject private var theme: ThemeManager
    private let screen: ScreenName = .settings
        private var p: ScreenStylePalette { theme.palette(for: screen) }
        private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }

    var onShowTerms: () -> Void
    var onShowPrivacy: () -> Void
    var onShowMedical: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Legal").font(.headline)
            HStack(spacing: 10) {
                Button { onShowTerms() } label: { T("Terms of Use", .tile) }.underline().buttonStyle(.plain)
                Text("•")
                Button { onShowPrivacy() } label: { T("Privacy Policy", .tile) }.underline().buttonStyle(.plain)
                Text("•")
                Button { onShowMedical() }label: { T("Wellness Disclaimer", .tile) }.underline().buttonStyle(.plain)
            }
            .foregroundStyle(.secondary)
        }
    }
}

#if DEBUG
#Preview("Legal Section (dumb)") {
    SettingsLegalSection(onShowTerms: {}, onShowPrivacy: {}, onShowMedical: {})
        .environmentObject(ThemeManager())
        .padding()
}
#endif
-e \n\n
=== ./intention/Features/Settings/SettingsV.swift ===
//
//  SettingsV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import UserNotifications

struct SettingsV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    @EnvironmentObject var memVM: MembershipVM
    @EnvironmentObject var focusVM: FocusSessionVM
    @EnvironmentObject var debug: DebugRouter
    @ObservedObject var statsVM: StatsVM
    @AppStorage(DebugKeys.forceLegalNextLaunch) private var debugShowLegalNextLaunch = false
    
    @State private var userID: String = ""      /// aka deviceID
    @State private var showTerms = false
    @State private var showPrivacy = false
    @State private var showMedical = false
    @State private var isBusy = false
    @State private var showSwatches = false
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions Settings ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ScrollView {
            Page(top: 4, alignment: .center) {
                T("Settings", .header)
                    .padding(.bottom, 4)
//                
//#if DEBUG
//                // DisclosureGroup<Label, Content>(label: Label, @ViewBuilder content: () -> Content)
//                // where the label is the first (non-closure) argument, and the content is the trailing closure
//                // use the implicit first and second trailing closures:
//                // The Label argument (mandatory for this initializer with DisclosureGroup)
//                DisclosureGroup {
//                    VStack(alignment: .leading, spacing: 6) {
//                        Button("Debug: Clear All") {
//                            UserDefaults.standard.removeObject(forKey: "debug.chunkSeconds")
//                        }
//                        Button("Reset Session"){Task { await focusVM.resetSessionStateForNewStart() } }
//                        
//                        Toggle("Show Legal on Next Launch", isOn: $debugShowLegalNextLaunch)
//                        
//                        Button("Reset: Legal Gate") { LegalConsent.clearForDebug() }
//                            .controlSize(.large)
//                        
//                        Divider()
//                        T("BYPASS", .title3)
//                        
//                        Button("Recalibration View"){debug.presentRecalibration() }
//                        Button("Organizer View")     { debug.presentOrganizer() }
//                        Button("Membership View")    { debug.presentMembership() }
//                        Button("ErrorOverlay View")  {
//                            debug.presentError(
//                                title: "Debug View Activated",
//                                message: "This is a forced-view of the error overlay for visual confirmation."
//                            )
//                        }
////                        
////                        Button("Recalibration View"){NotificationCenter.default.post(
////                            // Fires signal to the receiver (e.g. FocusActiveSessionV)
////                            name: .devOpenRecalibration, object: nil) }
////                        Button("Organizer View"){ NotificationCenter.default.post(
////                            name: .devOpenOrganizerOverlay, object: nil) }
////                        Button("Membership View"){NotificationCenter.default.post(
////                            name: .devOpenMembership, object: nil) }
////                        Button("ErrorOverlay View") {
////                            // Pass sample data for the overlay's content
////                            let userInfo: [AnyHashable: Any] = [
////                                DebugNotificationKey.errorTitle: "Debug View Activated",
////                                DebugNotificationKey.errorMessage: "This is a forced-view of the error overlay for visual confirmation."
////                            ]
////                            NotificationCenter.default.post(
////                                name: .debugShowSampleError, object: nil) }
////                        
//                        Picker("Timer debug", selection: Binding(
//                            get: { UserDefaults.standard.integer(forKey: "debug.chunkSeconds") },
//                            set: { UserDefaults.standard.set($0, forKey: "debug.chunkSeconds") } )) {
//                                Text("10s").tag(10); Text("30s").tag(30)
//                                Text("OFF (20m)").tag(0) // 0 disables override
//                        }}.controlSize(.small) .font(.footnote) .buttonStyle(.bordered)
//                } label: {
//                    Label("Dev", systemImage: "wrench")         // Dumb words, but this is the CONTENT closure
//                }
//#endif
                
                // MARK: Support
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Support", .section)
                        NavigationLink {
                            FeedbackV()
                        } label: {
                            HStack(spacing: 12){
                                Image(systemName: "paperplane.fill")
                                    .padding(.horizontal, 2)
                                T("Send Feedback", .action)
        
                                Image(systemName: "chevron.right")
                                    .font(.footnote)
                                    .foregroundStyle(.secondary)
                            }
                        }
                        .primaryActionStyle(screen: .settings)
                        .frame(maxWidth: .infinity)
                        .tint(p.accent)
                        .padding(.vertical, 6)
                    }
                    .edgesIgnoringSafeArea(.bottom)
                }
                
                // MARK: Membership
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Membership", .section)
                        //                        .friendlyHelper()
                        HStack {
                            T(memVM.isMember ? "Status: Subscribed" : "Status: Not Subscribed", .label)
                        }
                            .foregroundStyle(memVM.isMember ? .green : .secondary)
                        HStack {
                            T("Your ID:", .caption)
                        T(userID, .caption)
                            .foregroundStyle(textSecondary)
                    }
                        HStack(spacing: 12) {
                            Button(action: {
                                /// Instead of Link()
                                if let url = URL(string: "https://apps.apple.com/account/subscriptions") {
                                    UIApplication.shared.open(url)
                                }
                            }) {
                                T("Purchase", .action)
                            }
                            .primaryActionStyle(screen: .settings)
                            .frame(maxWidth: .infinity)
                            .tint(p.accent)
                        }
                    }
                }
                
                // MARK: Stats
                Card {
                    Grid(horizontalSpacing: 12, verticalSpacing: 12){
                        GridRow {
                            StatPill(icon: "list.bullet",
                                     value: "\(statsVM.totalCompletedIntentions)",
                                     caption: "Accomplished",
                                     screen: .settings)
                            
                            StatPill(icon: "rosette",
                                     value: "\(statsVM.longestStreak)",
                                     caption: "Streak",
                                     screen: .settings)
                            //                        }
                            //                        GridRow {
                            StatPill(icon: "leaf.fill",
                                     value: "\(statsVM.recalibrationCounts[.breathing, default: 0])",
                                     caption: "Breathing",
                                     screen: .settings)
                            StatPill(icon: "figure.walk",
                                     value: "\(statsVM.recalibrationCounts[.balancing, default: 0])",
                                     caption: "Balancing",
                                     screen: .settings)
                            
                        }
                        .frame(maxWidth: .infinity)
                    }
                }
                
                Divider()
                
                // MARK: Preferences
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Preferences", .section)
                        // NOTE: these are primary control labels; caption is too small/low-contrast
                        Toggle(isOn: .constant(true)) { T("Enable Notification", .label) }
                        Toggle(isOn: $prefs.hapticsOnly) { T("Only Vibrations", .label)
                            .foregroundStyle(textSecondary) }
                        Toggle(isOn: .constant(false)) { T("Sound Enabled", .label) }
                            .controlSize(.small)        /// Toggle size
                            .toggleStyle(SwitchToggleStyle(tint: p.accent))
                    }
                    .friendlyAnimatedHelper("hapticsOnly-\(prefs.hapticsOnly ? "on" : "off")")
                    .friendlyAnimatedHelper("soundEnabled-\(prefs.soundEnabled ? "off" : "on")")
                }
                
                // MARK: Customization
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        T("Personalization", .section)
                        
                        // Color Theme Picker
                        Picker(selection: $theme.colorTheme) {
                            ForEach(AppColorTheme.publicCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Color", .label)          // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)                 // segment highlight color
                        
                        // Font Theme Picker
                        Picker(selection: $theme.fontTheme) {
                            ForEach(AppFontTheme.allCases, id: \.self) { option in Text(option.displayName).tag(option) }
                        } label: {
                            T("Font", .section)     // themed label
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .tint(p.accent)
                        .friendlyAnimatedHelper(theme.fontTheme.rawValue)
                    }
                }
                
                // MARK: Legal (reprise)
                Card {
                    VStack(alignment: .leading, spacing: 8) {
                        
                        SettingsLegalSection(
                            onShowTerms: { showTerms = true },
                            onShowPrivacy: { showPrivacy = true },
                            onShowMedical: { showMedical = true }
                        )
                        .sheet(isPresented: $showTerms) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Terms of Use",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.termsFile),
                                    palette: theme.palette(for: .settings)
                                )
                            }
                        }
                        .sheet(isPresented: $showPrivacy) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Privacy Policy",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.privacyFile),
                                    palette: theme.palette(for: .settings)
                                )
                            }
                        }
                        .sheet(isPresented: $showMedical) {
                            NavigationStack {
                                LegalDocV(
                                    title: "Wellness Disclaimer",
                                    markdown: MarkdownLoader
                                        .load(named: LegalConfig.medicalFile),
                                    palette: theme.palette(for: .settings)
                                )
                            }
                        }
                    }
                }
                if BuildInfo.isDebugOrTestFlight {
                    SwatchesFormSection()
                        .environmentObject(theme)
                        .environmentObject(prefs)
                        .padding(.top, 8)
                }
            
            Helper_AppIconV()
                .frame(width: 64, height: 64)
                .padding(.top, 8)
                
                
            }
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .task {
            // Keychain won't get involved in previews, only in real runs
            // reads directly from Keychain, no async needed, only await
            userID = IS_PREVIEW
            ? "PREVIEW-DEVICE-ID"
            : await KeychainHelper.shared.getUserIdentifier()
        }
        
    }
    
    func requestNotificationPermissions() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            if let error = error {
                print("Notification permission error: \(error.localizedDescription)")
            }
            print("Permission granted: \(granted)")
        }
    }
}

// MARK: Swatches
struct SwatchesFormSection: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        
        Card {
            //    VStack(alignment: .leading, spacing: 8) {
            Form {
                // NOTE: these are primary control labels; caption is too small/low-contrast
                //                Toggle(isOn: .constant(true) $showSwatches) { T("Show", .label) }
                //        Form {
                // Presented as a table
                Section("Swatches In Use") {
                    Toggle(isOn: $prefs.showSwatches) { T("Show", .label) }
                    if prefs.showSwatches {
                        ThemeSwatches()
                        
                    }
                }
                //        }
                //    }
            }
            .listStyle(.insetGrouped)
            .scrollContentBackground(.hidden)
            .background(p.background)
        }
    }
}

#if DEBUG
#Preview("Settings (dumb)") {
    // Minimal real objects; no debug factories or preview wrappers.
    let theme  = ThemeManager()
    let prefs  = AppPreferencesVM()
    let memVM  = MembershipVM(payment: PaymentService(productIDs: [])) // empty product list = inert
    let focus  = FocusSessionVM(previewMode: true,
                                haptics: NoopHapticsClient(),
                                config: .current)
    let stats  = StatsVM(persistence: PersistenceActor())
    let debug  = DebugRouter() // safe; sheet toggles won’t present in previews

    SettingsV(statsVM: stats)
        .environmentObject(theme)
        .environmentObject(prefs)
        .environmentObject(memVM)
        .environmentObject(focus)
        .environmentObject(debug)
        .frame(maxWidth: 430)
}
#endif
-e \n\n
=== ./intention/Features/Sheets Overlays/RecalibrationSheetChrome.swift ===
//
//  RecalibrationSheetChrome.swift
//  intention
//
//  Created by Benjamin Tryon on 10/13/25.
//

import SwiftUI

/// A full-screen wrapper that *looks* like a sheet: rounded top, grabber, swipe down to dismiss.
struct RecalibrationSheetChrome<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    var onClose: () -> Void
    @ViewBuilder var content: Content
    
    @State private var offsetY: CGFloat = 0
    private let dismissThreshold: CGFloat = 120
    
    private var p: ScreenStylePalette { theme.palette(for: .recalibrate) }
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    
    var body: some View {
        ZStack {
            // ^^ ZStack paints the big gradient
            // The themed gradient or fallback background
            BackplateGradient(p: p)
            // Sheet container/body, kept clear for gradient to shine throw
            VStack(spacing: 0) {
                HStack {
                    Capsule().frame(width: 40, height: 5).opacity(0.35)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .overlay(alignment: .trailing) {
                            Button(action: onClose) {
                                Image(systemName: "xmark")
                                    .font(.headline)
                                    .padding(12)
                            }
                            .tint(p.accent)
                        }
                }
                .contentShape(Rectangle())
                
                // Your sheet content
                content
                // keep inner content transparent
                    .background(.clear)
                //.background(p.surfaces.opacity(0.0))
            }
            // lets ZStack gradient through because container has no fill/ is clear
            .background(.clear)
            .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
            // softened lift, then contact shadow
            .shadow(color: Color.black.opacity(0.18), radius: 24, x: 0, y: 18)
            .shadow(color: Color.black.opacity(0.06), radius: 6, x: 0, y: 1)
            
            .offset(y: max(0, offsetY))
            .gesture(
                DragGesture()
                    .onChanged { offsetY = max(0, $0.translation.height) }
                    .onEnded { final in
                        if final.translation.height > dismissThreshold { onClose() }
                        else { withAnimation(.spring) { offsetY = 0 }}
                    }
            )
            .padding(.top, 8)
            .padding(.horizontal, 0)
            .ignoresSafeArea(edges: .bottom)
        }
    }
}

#if DEBUG
#Preview("Chrome") {
    RecalibrationSheetChrome(onClose: {}) {
        VStack(spacing: 12) {
            Text("recal Content")
            Button("Primary", action: {})
        }
        .padding()
    }
    .environmentObject(ThemeManager())
}
#endif
-e \n\n
=== ./intention/Features/Sheets Overlays/MembershipSheetV.swift ===
//
//  MembershipSheetV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//
//
// import Foundation
import SwiftUI

struct MembershipSheetV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var viewModel: MembershipVM
    @EnvironmentObject var theme: ThemeManager
    
    @State private var isBusy = false
    
    var useDogEmoji: Bool = true
    private let screen: ScreenName = .membership
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    // tailText to remain INSIDE the struct, but OUTSIDE `body`
    private var tailText: String { "All while helping us keep the lights on, the mortgage paid, and the \(useDogEmoji ? "🐕" : "dog") fed & happy!" }
    
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack {
                    // Hero
                    T("You’ve completed your free sessions.", .body)        // it's information body copy
                    T("Unlock Unlimited Focus", .header).padding(.top, 2)
                    T("For about 30¢ per day", .secondary).padding(.top, 2)
                        .lineLimit(2)
                }
                .multilineTextAlignment(.center)
                .friendlyHelper()
                Page(top: 10, alignment: .center){      // FIXME: top 10 MAY BE SCREWING THIS UP
                    
                    // Price hint (optional, tiny): Signals if a product is loaded + VM bridge (sheet cannot create own PaymentService)
                    if let prod = viewModel.primaryProduct {
                        Text("\(viewModel.perDayBlurb(for: prod)) • \(prod.displayPrice)")
                            .font(theme.fontTheme.toFont(.headline))
                            .padding(.horizontal, 12).padding(.vertical, 6)
                            .background(Capsule().fill(p.accent).shadow(radius: 8, y: 3)) // subtle lift
                        // or use Color.defaultUtilityGray?
                            .foregroundStyle(Color.intText)
                            .padding(.bottom, 6)
                    }
                    
                    // Primary CTA row (above the fold)
                    if viewModel.isMember {
                        Label { T("Member!", .label) } icon: { Image(systemName: "star.fill").foregroundStyle(p.primary)
                        }
                        .symbolBounceIfAvailable()
                    } else {
                        // Upgrade
                        Button {
                            Task {
                                isBusy = true; defer { isBusy = false }
                                do { try await viewModel.purchaseMembershipOrPrompt() }
                                catch { viewModel.setError(error) }      // Shows ErrorOverlay
                            }
                         } label: { T("Upgrade", .action) }
                            .primaryActionStyle(screen: .membership)
                            .frame(maxWidth: .infinity, minHeight: 48)
                        
                        // Restore
                        Button {
                            Task {
                                do { try await viewModel.restoreMembershipOrPrompt() }
                                catch { viewModel.setError(error) }     // Shows ErrorOverlay
                            }
                        } label: { T("Restore Purchases", .action) }
                            .secondaryActionStyle(screen: .membership)
                            .frame(maxWidth: .infinity, minHeight: 44)
                            .padding(.top, 6)
                        
                        // Apple offer-code redemption (subscription offers)
                        Button {
                            Task { await redeemOfferCode() }
                        } label: { T("Redeem Code (Apple)", .action) }      // it’s a button, not footnote text use .action
                            .buttonStyle(.plain)
                            .padding(.top, 4)
                    }
                    
                    Card {
                        VStack(alignment: .leading, spacing: 10) {
                            T("Why upgrade?", .title3)
                            T("Your focus fuels our future.", .title3).padding(.top, 2)
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Label("Unlimited focus sessions", systemImage: "infinity")
                                Label("Detailed stats & categories", systemImage: "chart.bar")
                                Label("Full customization", systemImage: "paintbrush")
                                Divider().padding(.vertical, 4)
                                Label("Build momentum", systemImage: "bolt")
                                Label("Track progress", systemImage: "chart.line.uptrend.xyaxis")
                                Label("\(tailText)", systemImage: "house")
                                Label("Thank you.", systemImage: "heart")
                            }
                            .font(theme.fontTheme.toFont(.footnote))
                            .foregroundStyle(.secondary)
                            .symbolRenderingMode(.hierarchical)
                            
                            T("Apple securely handles your purchase. Cancel anytime in **Settings › Manage Subscription.**", .caption)
                                .foregroundStyle(.secondary)
                                .padding(.top, 6)
                        }
                    }
                    .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 14))
                }
            }
            .background(p.background.ignoresSafeArea())
            .tint(p.primary)
            // Let people leave
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button{ dismiss() }
                    label: { Image(systemName: "xmark").imageScale(.small).font(.body).controlSize(.large) }.buttonStyle(.plain).accessibilityLabel("Close")}
            }
        }
        // Sheet behavior tuned for iPhone
        .presentationDetents([.fraction(0.55), .large])
        .presentationDragIndicator(.visible)
        .interactiveDismissDisabled(false)
        .overlay {
            if isBusy { ProgressView().controlSize(.large) }
        }
        .overlay {
            if let error = viewModel.lastError {
                ErrorOverlay(error: error) { viewModel.setError(nil) }
                    .transition(.opacity.combined(with: .scale))
                    .zIndex(1)
            }
        }
    }
}

#if DEBUG
#Preview {
    let theme  = ThemeManager()
    let prefs  = AppPreferencesVM()
    let hist   = HistoryVM(persistence: PersistenceActor())
    let stats  = StatsVM(persistence: PersistenceActor())
//    let memVM  = MembershipVM(payment: PaymentService(productIDs: [])) // inert
//    memVM._debugSetIsMember(false) // purely visual; does not start network
    // Local factory to keep side effects out of the ViewBuilder expression list
    let memVM: MembershipVM = {
        let vm = MembershipVM(payment: PaymentService(productIDs: [])) // inert
        vm._debugSetIsMember(false)    // purely visual; does not start network
        return vm
    }()

    MembershipSheetV()
        .environmentObject(memVM)
        .environmentObject(theme)
        .environmentObject(prefs)
        .environmentObject(hist)
        .environmentObject(stats)
}
#endif

-e \n\n
=== ./intention/Features/Sheets Overlays/RenamingSheetChrome.swift ===
//
//  RenamingSheetChrome.swift
//  intention
//
//  Created by Benjamin Tryon on 10/29/25.
//

import SwiftUI

struct RenamingSheetChrome<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    var onClose: () -> Void
    @ViewBuilder var content: Content

    @State private var offsetY: CGFloat = 0
    private let dismissThreshold: CGFloat = 120
    // You can route this to .organizer or .settings; choose the one that gives best contrast there
    private var p: ScreenStylePalette { theme.palette(for: .history) }

    var body: some View {
        ZStack {
            if let g = p.gradientBackground {
                LinearGradient(colors: g.colors, startPoint: g.start, endPoint: g.end).ignoresSafeArea()
            } else {
                p.background.ignoresSafeArea()
            }
            VStack(spacing: 0) {
                HStack {
                    Capsule().frame(width: 40, height: 5).opacity(0.35)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity)
                        .overlay(alignment: .trailing) {
                            Button(action: onClose) {
                                Image(systemName: "xmark").font(.headline).padding(12)
                            }
                            .tint(p.accent)
                        }
                }
                .contentShape(Rectangle())

                content
                    .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 16))
                    .padding(.horizontal, 12)
                    .padding(.bottom, 8)
            }
            .clipShape(.rect(cornerRadius: 22, style: .continuous))
            .offset(y: max(0, offsetY))
            .gesture(
                DragGesture()
                    .onChanged { offsetY = max(0, $0.translation.height) }
                    .onEnded { final in
                        if final.translation.height > dismissThreshold { onClose() }
                        else { withAnimation(.spring) { offsetY = 0 } }
                    }
            )
            .padding(.top, 8)
            .ignoresSafeArea(edges: .bottom)
        }
    }
}

#if DEBUG
#Preview("Chrome") {
    RenamingSheetChrome(onClose: {}) {
        VStack(spacing: 12) {
            Text("rename Content")
            Button("Primary", action: {})
        }
        .padding()
    }
    .environmentObject(ThemeManager())
}
#endif
-e \n\n
=== ./intention/Features/Sheets Overlays/ErrorOverlay.swift ===
//
//  ErrorOverlay.swift
//  intention
//
//  Created by Benjamin Tryon on 7/1/25.
//

import SwiftUI

// `self.lastError = error` to trigger the ErrorOverlay
struct ErrorOverlay: View {
    @EnvironmentObject var theme: ThemeManager
    let error: Error
    let dismissAction: () -> Void
    
    private let screen: ScreenName = .focus // or whichever main screen hosts this overlay
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    
    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ZStack {
            RadialGradient(
                        gradient: Gradient(colors: p.radialBackground.colors),
                        center: p.radialBackground.center,
                        startRadius: p.radialBackground.startRadius,
                        endRadius: p.radialBackground.endRadius
                    )
            .ignoresSafeArea()
        VStack(spacing: 12) {
            Text("⚠️ Something went wrong")
                .bold()
                .foregroundStyle(colorDanger)
            
            // Message: use the theme's text color for readability
            Text(displayMessage(for: error))
                .multilineTextAlignment(.center)
                .foregroundStyle(p.text)
            
            // Use theme's primary CTA/Accent color
            Button("Dismiss", action: dismissAction)
                .buttonStyle(.borderedProminent)
                .tint(p.accent) // Use the theme's accent color for the button
        }
        .padding(20)            // Lots, for visual spacing
        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
        .shadow(radius: 8, y: 4)    // softer
        .padding(30)        // Ensures overlay doesn't hug screen edges
    }
}
    
    private func displayMessage(for error: Error) -> String {
        let description = error.localizedDescription
        if description == "The operation could not be completed." {
            return "Please try again"
    }
            return description
    }
}

struct SampleErr: LocalizedError {
    var errorDescription: String? { "sample err" }
}

#if DEBUG
#Preview("Error Overlay (dumb)") {
    ErrorOverlay(
        error: SampleErr(), dismissAction: {}
    )
        .environmentObject(ThemeManager())
        .background(Color.black.opacity(0.1))
}
#endif


/*
 Currently, error displays FocusSessionError.unexpected or HistoryError.categoryNotFound, etc.
 Meaning enums fall back to String(describing:) so you see FocusSessionError.unexpected or HistoryError.categoryNotFound

 Later: As soon as you add `LocalizedError` with `custom errorDescription`, the nicer user message shows:
 enum HistoryError: LocalizedError {
     case categoryNotFound
     var errorDescription: String? { "The category could not be found. Tile not added." }
 }
 …the overlay will automatically show "The category could not be found. Tile not added." without any changes to the view
 */
-e \n\n
=== ./intention/Features/Sheets Overlays/DebugRouter.swift ===
// DebugRouter.swift
// intention
//
// A tiny @MainActor router that your Dev buttons call.
// RootView observes it and presents the right sheet/overlay.

import SwiftUI

@MainActor
final class DebugRouter: ObservableObject {
    // Presentation toggles
    @Published var showRecalibration = false
//    @Published var showOrganizer = false
    @Published var showMembership = false
    
    // Optional payload for a global error overlay
    @Published var errorTitle: String = ""
    @Published var errorMessage: String = ""
    @Published var showError = false
    
    // MARK: Entry points the Dev buttons will call
    func presentRecalibration() { showRecalibration = true }
//    func presentOrganizer()     { showOrganizer = true }
    func presentMembership()    { showMembership = true }
    
    func presentError(title: String, message: String) {
        errorTitle = title
        errorMessage = message
        showError = true
    }
}
-e \n\n
=== ./intention/Features/Sheets Overlays/MembershipSheetChrome.swift ===
//
//  MembershipSheetChrome.swift
//  intention
//
//  Created by Benjamin Tryon on 10/29/25.
//

import SwiftUI

/// Full-screen “sheet” wrapper: rounded top, grabber, swipe-to-dismiss.
/// Reuses your per-screen palette for .membership.
struct MembershipSheetChrome<Content: View>: View {
    @EnvironmentObject var theme: ThemeManager
    var onClose: () -> Void
    @ViewBuilder var content: Content

    @State private var offsetY: CGFloat = 0
    private let dismissThreshold: CGFloat = 120
    private var p: ScreenStylePalette { theme.palette(for: .membership) }

    var body: some View {
        ZStack {
            // ^^ ZStack paints the big gradient
            // The themed gradient or fallback background
            BackplateGradient(p: p)
            // Sheet container/body, kept clear for gradient to shine throw
            VStack(spacing: 0) {
                HStack {
                    Capsule().frame(width: 40, height: 5).opacity(0.35)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity)
                        .overlay(alignment: .trailing) {
                            Button(action: onClose) {
                                Image(systemName: "xmark").font(.headline).padding(12)
                            }
                            .tint(p.accent)
                        }
                }
                .contentShape(Rectangle())

                // Your sheet content
                content
                    // keep inner content transparent
                    .background(.clear)
            }
            // lets ZStack gradient through because container has no fill/ is clear
            .background(.clear)
            .clipShape(RoundedRectangle(cornerRadius: 22, style: .continuous))
            // softened lift, then contact shadow
            .shadow(color: Color.black.opacity(0.18), radius: 24, x: 0, y: 18)
            .shadow(color: Color.black.opacity(0.06), radius: 6, x: 0, y: 1)

            .offset(y: max(0, offsetY))
            .gesture(
                DragGesture()
                    .onChanged { offsetY = max(0, $0.translation.height) }
                    .onEnded { final in
                        if final.translation.height > dismissThreshold { onClose() }
                        else { withAnimation(.spring) { offsetY = 0 }}
                    }
            )
            .padding(.top, 8)
            .padding(.horizontal, 0)
            .ignoresSafeArea(edges: .bottom)
        }
    }
}

#if DEBUG
#Preview("Chrome") {
    MembershipSheetChrome(onClose: {}) {
        VStack(spacing: 12) {
            Text("mem Content")
            Button("Primary", action: {})
        }
        .padding()
    }
    .environmentObject(ThemeManager())
}
#endif
-e \n\n
=== ./intention/Features/Focus/FocusSessionVM.swift ===
//
//  FocusSessionVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI
import Foundation

/// FocusSessionVM talks to ContinuousClockActor and drives the UI
/// Errors: make UI-called methods async throws (no wrapper)
@MainActor
final class FocusSessionVM: ObservableObject {
    
    // MARK: - Chunk Phases
    /// UI state of the current 20-min chunk
    enum Phase: String, Codable, Sendable {
        case none, idle, running, finished, paused
    }
    
    // MARK: - Session Logic Enum (VM-internal)
    private enum SessionLogicalPhase {
        case empty
        case ready
        case chunk1Active
        case chunk1Done
        case chunk2Active
        case finished
    }
    
    private var logicalPhase: SessionLogicalPhase {
        switch (currentSessionChunk, phase, tiles.count) {
        case (_, .none, 0):             return .empty
        case (_, .idle, 2):             return .ready
        case (0, .running, _):          return .chunk1Active
        case (1, .finished, _):         return .chunk1Done
        case (1, .running, _):          return .chunk2Active
        case (2, .finished, _):         return .finished
        default:
            // Safe fallback when restoring unusual combinations
            if tiles.count < 2 { return .empty }
            if phase == .running && currentSessionChunk == 0 { return .chunk1Active }
            if phase == .running && currentSessionChunk == 1 { return .chunk2Active }
            if phase == .finished && currentSessionChunk == 1 { return .chunk1Done }
            if phase == .finished && currentSessionChunk >= 2 { return .finished }
            return .ready
        }
    }
    
    
    // MARK: - Published UI State
    @Published var tileText: String = ""
    {
        didSet { validationMessages = tileText.taskValidationMessages } /// Input field for tiles' text;   Validate whenever tileText changes
    }
    @Published var tiles: [TileM] = []              /// List of current session tiles (max 2)
    @Published var canAdd: Bool = true              /// Flag if user can add more tiles at that point
    @Published var sessionActive: Bool = false      /// Overall session state (two 20-min chunks)
    @Published var showRecalibrate: Bool = false    /// Whether to show recalibration
    @Published var countdownRemaining: Int          /// Secs remaining in 20 minutes for individual tile task - set via config
    @Published var phase: Phase = .none             /// State of the *current* 20-min countdown chunk
    @Published var currentSessionChunk: Int = 0     /// Index of current chunk (0 or 1): Tracks which 20-min chunk of the session is active
    @Published var sessionHistory: [[TileM]] = []   /// Array of tiles completed in this session of 2 chunks
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    @Published var validationMessages: [String] = []
    @Published private(set) var didHapticForChunk: Set<Int> = []    /// remembers which chunk indices have already buzzed
    /// ^ returning from background for re-entering a completion can't "double buzz"
    
    weak var historyVM: HistoryVM?                      /// Link to history view model for/to save completed sessions
    ///
    // MARK: Dependencies
    //    private static let activeSnapshotKey = "focus.activeSession"
    private let haptics: HapticsClient
    private let config: TimerConfig
    private let persistence: any Persistence            /// handles activeSessionSnapshot via Persistence
    private let timeActor: ContinuousClockActor
    private var chunkCountdown: Task<Void, Never>?        /// background live time keeper/ticker
    private var sessionCompletionTask: Task<Void, Never>? /// background timer for the entire session (2x 20-min chunks)
    private var runningDeadline: Date?                  /// property to mark a deadline when a chunk starts or resumes
    private var editingIndex: Int? = nil                /// when editing, remember location, reinsert there
    
    var chunkDuration: Int { config.chunkDuration }     /// Default 20 min chunk duration constant
    
    // MARK: - Cancel or teardown
    deinit {
        chunkCountdown?.cancel()
        sessionCompletionTask?.cancel()
    }
    
    // MARK: Snapshot (the VM snapshot is canonical)
    private struct VMSnapshot: Codable, Equatable {
        var tileTexts: [String]
        var phase: Phase
        var chunkIndex: Int
        var deadline: Date?
        var remainingSeconds: Int       // fallback when no deadline
        var showRecalibrate: Bool
        var didHapticForChunk: [Int]
    }
    private let vmSnapshotKey = "focus.vm.snapshot.v2"
    
    // MARK: - Init
    init(
        previewMode: Bool = false,
        haptics: HapticsClient,
        config: TimerConfig = .current,
        persistence: any Persistence = PersistenceActor()
    ){
        self.haptics = haptics
        self.config = config
        self.persistence = persistence
        self.countdownRemaining = config.chunkDuration
        self.timeActor = ContinuousClockActor(config: config)
        
        if previewMode {
            tiles = [TileM(text: "Tile 1"), TileM(text: "Tile 2")]
            tileText = "Start another..."
            canAdd = false
            sessionActive = true
            currentSessionChunk = 1
            phase = .running
            countdownRemaining = config.chunkDuration / 20
        }
    }
    
    // MARK: Derived
    // Computed, no storage involved
    
    private var hasTwoTiles: Bool {
        tiles.count == 2
    }
    
    /// Guard for phases -> canPrimary for flipping to the "Add" button
    private var inputIsValid: Bool {
        let t = tileText.trimmingCharacters(in: .whitespacesAndNewlines)
        return !t.isEmpty && t.taskValidationMessages.isEmpty
    }
    
    /// Tap handler here, the button widget lives in the Focus view -> Lets the View bind `.disabled(!viewModel.canPrimary)`
    //    var primaryCTATile: String {
    //        if !hasTwoTiles { return "Add" }
    //        if phase == .finished && currentSessionChunk == 1 { return "Next" }
    //        return "Begin"
    //    }
    
    var primaryCTATile: String {
        switch logicalPhase {
        case .empty, .ready:                return hasTwoTiles ? "Begin" : "Add"
        case .chunk1Active, .chunk2Active:    return "Pause" // View may override
        case .chunk1Done:                   return "Next"
        case .finished:                     return "Done"
        }
    }
    
    /// View binds `.disabled(!canPrimary)`
    var canPrimary: Bool {
        switch logicalPhase {
        case .empty:                        return inputIsValid && phase != .running
            // "ready" means two tiles, idle/none → allow Begin
        case .ready:                      return phase == .idle || phase == .none || (phase == .finished && currentSessionChunk == 1)
        case .chunk1Active, .chunk2Active:  return false
            // Between chunks → allow Next
        case .chunk1Done:                 return true
        case .finished:                   return false
        }
    }
    
    //See Quick Help: Option-click a symbol (⌥-click) to show docs/definition
    /// True when user can edit tiles (pre-Begin; not running or paused).
    var canEditTiles: Bool {                       // semantic, not visual
        phase != .running && phase != .paused
    }
    
    var showNextLabel: Bool {
        phase == .finished && currentSessionChunk == 1
    }

    var showRecalibrationSoonHint: Bool {
        currentSessionChunk == 2 && phase == .finished
    }

    var isFirstChunkRunning: Bool {
        currentSessionChunk == 0 && phase == .running
    }

    // Keep, but don't reuse for editing decisions
    var ui_isReadyForBegin: Bool {
        hasTwoTiles && (phase == .idle || phase == .none) && canPrimary
    }
    
    /// Enter idle early / consistently
    func enterIdleIfNeeded() {
        if phase == .none { phase = .idle }
    }
    
    // MARK: Control public funnel used by TextField and CTA
    enum PrimaryCTAResult {
        case added, began
    }
    
    /// The one funnel both TextField.onSubmit and the bottom CTA should use.
    /// Gated with logical phase
    @discardableResult
    func handlePrimaryTap(validatedInput: String?) async throws -> PrimaryCTAResult {
        if !hasTwoTiles {
            // the ADDED path
            let text = (validatedInput ?? tileText).trimmingCharacters(in: .whitespacesAndNewlines)
                    guard !text.isEmpty, text.taskValidationMessages.isEmpty else {
                        throw FocusSessionError.emptyInput
                    }
            try await addTileAndPrepareForSession(text)
            return .added
        } else {
            // the BEGIN / NEXT path
            guard canPrimary else {
                throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
            }
            try await beginOverallSession()
            return .began
        }
    }
    
    // MARK: - Tile Handling
    func addTileAndPrepareForSession(_ text: String) async throws {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {   throw FocusSessionError.emptyInput    }
        guard tiles.count < 2 else {    throw FocusSessionError.tooManyTiles()    }
        
        let newTile = TileM(text: trimmed)
        // VM enforces 2-tile limit, even editing - actor does no tiles, only timers
        //        tiles.append(newTile)
        
        if let index = editingIndex, index <= tiles.count {
            // put it back where it came from
            tiles.insert(newTile, at: index)
        } else {
            tiles.append(newTile)
        }
        // clear 'edit' state
        editingIndex = nil
        
        tileText = ""
        canAdd = tiles.count < 2
        haptics.added()
        saveVMSnapshot()
    }
    
    //VM owns rules (canEditTile) and mutations (beginEditingTile)
    // MARK: *When* slot is editable
    // pre-Begin only
    // Tiles are only editable before the timer has started
    func canEditTile(at index: Int) -> Bool {
        // Must exist
        guard tiles.indices.contains(index) else { return false }
        
        // Only allow edits before session starts
        guard canEditTiles else { return false }      // <- use semantic flag
        
        // cannot edit completed tiles
        let tile = tiles[index]
        return !thisTileIsCompleted(tile)
    }
    
    // MARK: Editing/Fixing tile by tapping it
    // Allows editing an existing tile *before* the session starts.
    // Moves the tile’s text back into `tileText` and removes it from the list.
    func beginEditingTile(at index: Int) {
        // Don’t allow edits while running or finished.
        guard phase != .running, phase != .finished, tiles.indices.contains(index) else { return }
        
        let tile = tiles.remove(at: index)
        tileText = tile.text
        canAdd = tiles.count < 2
        // remember the slot we took the tile from
        editingIndex = index
        if phase == .none { phase = .idle }
        
        saveVMSnapshot()
    }
    
    
    // MARK: Start a 20-min chunk
    private func startCurrent20MinCountdown(seconds: Int? = nil) async {
        phase = .running
        sessionActive = true
        // cancels any existing timers
        //        stopCurrent20MinCountdown()
        //        phase = .running
        
        let total = seconds ?? config.chunkDuration
        countdownRemaining = total
        saveVMSnapshot()
        
        // bail out in previews -- a hard stop for Canvas
        guard !IS_PREVIEW else { return }
        
        await timeActor.startTicking(
            totalSeconds: total,
            onTick: { [ weak self ] secs in
                Task { @MainActor in self?.countdownRemaining = secs }
            },
            onFinish: { [ weak self] in
                guard let self else { return }
                Task { @MainActor in
                    self.countdownRemaining = 0
                               self.fireDoneHapticOnce()
                               self.finishCurrentChunkIfNeeded(source: "tick")   // <-- single guarded path
                               self.clearVMSnapshot()
                           }
                       }
                   )
               }
    
    // MARK: Begin overall session (two chunks)
    func beginOverallSession() async throws {
        //        guard hasTwoTiles, (phase == .idle || phase == .none || (phase == .finished && currentSessionChunk == 1)) else {
        //            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        //        }
        guard hasTwoTiles else {
            throw FocusSessionError.invalidBegin(phase: phase, tilesCount: tiles.count)
        }
        guard !IS_PREVIEW else { return }
        await timeActor.startSessionTracking()
        await startCurrent20MinCountdown()
        /*
         after await timeActor.startSessionTracking(), you always hit startCurrent20MinCountdown() regardless of phase/currentSessionChunk
         need different behavior for “next chunk,” pass a parameter there instead of duplicating the call
         */
    }
    
    // MARK: User pause / resume
    func pauseCurrent20MinCountdown() async {
        guard phase == .running else { return }
        await timeActor.pauseTicking(currentRemaining: countdownRemaining)
        phase = .paused
        saveVMSnapshot()
    }
    
    func resumeCurrent20MinCountdown() async throws {
        guard phase == .paused else { throw FocusSessionError.unexpected }
        await timeActor.resumeTicking(
            onTick: { [weak self] secs in
                Task { @MainActor in self?.countdownRemaining = secs }
            },
            onFinish: { [weak self] in
                Task { @MainActor in
                    guard let self else { return }
                    self.countdownRemaining = 0
                    if self.phase == .running {
                        self.fireDoneHapticOnce()
                        self.finishCurrentChunk()
                    }
                }
            }
        )
        phase = .running
        saveVMSnapshot()
        
    }
    
    // MARK: App lifecycle (RootView calls these)
    func suspendTickingForBackground() async {
        // 1) Save *VM* snapshot (canonical UI/session)
        saveVMSnapshot()
        guard !IS_PREVIEW else { return }
        // 2) Let actor stop work but keep endInstant so wall-time continues
        await timeActor.suspendForBackground()
        // 3) (Optional) write actor safety snapshot to disk for kill-restore
        if let snap = await timeActor.makeSnapshot() {
            try? await persistence.write(snap, to: "focus.actor.safety")
        }
    }
    
    func resumeTickingAfterForeground() async {
        guard !IS_PREVIEW else { return }
        // First, try the actor’s monotonic recompute
        if let remaining = await timeActor.remainingAfterForeground() {
            if remaining <= 0 {
                // Finished while away
                await MainActor.run {
                    self.countdownRemaining = 0
                                    self.fireDoneHapticOnce()
                                    self.finishCurrentChunkIfNeeded(source: "foreground<=0")  // <-- no direct phase mutate
                                    self.clearVMSnapshot()
                }
//                phase = .finished
//                countdownRemaining = 0
//                finishCurrentChunk()
//                clearVMSnapshot()
                return
            }
            // Re-arm ticking
            await startCurrent20MinCountdown(seconds: remaining)
            return
        }
        
        // If actor had no state (process kill), try safety snapshot (aux) THEN VM snapshot (canonical)
        if let safety: ContinuousClockActor.Snapshot =
            try? await persistence.readIfExists(ContinuousClockActor.Snapshot.self, from: "focus.actor.safety") {
            
            // Restore into actor and VM scaffolding
            await timeActor.restoreFromSafetySnapshot(safety)
            await startCurrent20MinCountdown(seconds: safety.remainingSeconds)
            try await persistence.clear("focus.actor.safety")
            return
        }
        
        // Finally, VM snapshot as canonical (e.g., after kill/launch)
        if let vmSnap: VMSnapshot = try? await persistence.readIfExists(VMSnapshot.self, from: vmSnapshotKey) {
            applyVMSnapshot(vmSnap)
            clearVMSnapshot()
            if phase == .running {
                // Recreate ticking respecting paused/running
                if phase == .running {
                    await startCurrent20MinCountdown(seconds: vmSnap.remainingSeconds)
                }
            }
        }
    }
    
    func restoreActiveSessionIfAny() async {
        // On cold launch; reuse the same logic as foreground
        await resumeTickingAfterForeground()
    }
    
    // MARK: End-of-chunk/session
    /// ONLY advancement path; Marks the current chunk complete, advances chunk index once,
    ///     performs end-of-session work when both chunks are done.
    ///     NO NEED for a separate `mark()` or `check()` needed
    func finishCurrentChunk() {
        currentSessionChunk += 1
        if currentSessionChunk >= 2 {
            sessionActive = false
            phase = .finished
            showRecalibrate = true
            
            if let targetCategoryID = historyVM?.generalCategoryID {
                for tile in tiles.prefix(2) {
                    historyVM?.addToHistory(tile, to: targetCategoryID)
                }
            }
        } else {
            phase = .finished   // between chunks; UI will show Next
        }
        // Clear the running deadline; take a snapshot of the new state
        runningDeadline = nil
        saveVMSnapshot()
    }
    
    // MARK: - Machine state helpers
    private func finishCurrentChunkIfNeeded(source: String) {
        // only advance when actually running a countdown
        guard phase == .running else {
#if DEBUG
            print("[FocusVM] finishCurrentChunkIfNeeded(\(source)) ignored - phase=\(phase), chunk=\(currentSessionChunk)")
#endif
            return
        }
        
        finishCurrentChunk()
        
    }
    
    /// Resets the session state for a new start - non-throwing; async because we `await` the actor
    func resetSessionStateForNewStart() async {
        //        stopCurrent20MinCountdown()                     /// Ensures any running countdown is stopped
        tiles = []
        tileText = ""
        canAdd = true
        sessionActive = false
        showRecalibrate = false
        //        completedTileIDs.removeAll()
        currentSessionChunk = 0
        phase = .none
        countdownRemaining = config.chunkDuration
        didHapticForChunk.removeAll()
        await timeActor.resetSessionTracking()
        clearVMSnapshot()
        //        debugPrint("[FocusVM.resetSessionStateForNewStart] state NOT reset for a new session.")
    }
    
    /// checkmarks + Calls when each 20-min chunk completes:
    /// you persist currentSessionChunk. On restore, new TileM ids are created, so any stored completedTileIDs wouldn’t match; index-derived stays correct.
    func thisTileIsCompleted(_ tile: TileM) -> Bool {
        guard let idx = tiles.firstIndex(where: { $0.id == tile.id }) else { return false }
        //        completedTileIDs.contains(tile.id)
        return idx < currentSessionChunk
    }
    
    // MARK: Haptics (guard once per chunk)
    // Pattern to call haptic once per completion
    private func fireDoneHapticOnce() {
        guard !didHapticForChunk.contains(currentSessionChunk) else { return }
        didHapticForChunk.insert(currentSessionChunk)
        haptics.notifyDone()            // don't call itself with fireDoneHapticOnce()
    }
    
    // MARK: VM snapshot helpers (canonical)
    private func makeVMSnapshot() -> VMSnapshot {
        VMSnapshot(tileTexts: tiles.map(\.text),
                   phase: phase,
                   chunkIndex: currentSessionChunk,
                   deadline: nil,                       // deadline-based restore
                   remainingSeconds: countdownRemaining,   // always stores a fallback
                   showRecalibrate: showRecalibrate,
                   didHapticForChunk: Array(didHapticForChunk)
        )
    }
    
    private func saveVMSnapshot() {
        guard !IS_PREVIEW else { return }
        let snap = makeVMSnapshot()
        Task { try? await persistence.write(snap, to: vmSnapshotKey) }
    }
    
    private func clearVMSnapshot() {
        guard !IS_PREVIEW else { return }
        Task { await persistence.clear(vmSnapshotKey)}
    }
    
    private func applyVMSnapshot(_ s: VMSnapshot) {
        tiles = s.tileTexts.map { TileM(text: $0) }
        phase = s.phase
        currentSessionChunk = s.chunkIndex
        showRecalibrate = s.showRecalibrate
        didHapticForChunk = Set(s.didHapticForChunk)
        sessionActive = (phase == .running || phase == .paused || currentSessionChunk > 0)
    }
    
    // MARK: Utilities
    var formattedTime: String {
        TimeString.mmss(countdownRemaining)
    }
    
    /// Sets flag to trigger recalibration modal
    func checkRecalibrationNeeded() {
        if tiles.count == 2 {
            showRecalibrate = true
        }
    }
    
    //  NOTE: Do not set as a global function - needs to modify `lastError`
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do { try await action() }
            catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
}

extension FocusSessionVM {
    var inputValidationState: ValidationState {
        let msgs = tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    func debugPhaseSummary(_ tag: String = "") -> String {
        "[VM] \(tag) tiles=\(tiles.count) phase=\(phase) remaining=\(countdownRemaining) active=\(sessionActive)"
    }
    
}

/// Error cases for focus session flow
enum FocusSessionError: Error, Equatable, LocalizedError {
    case emptyInput
    case tooManyTiles(limit: Int = 2)
    case invalidBegin(phase: FocusSessionVM.Phase, tilesCount: Int)
    case persistenceFailed
    case unexpected
    
    var errorDescription: String? {
        switch self {
        case .emptyInput: return "Please enter a task, what you intend to do."
        case .tooManyTiles(let limit): return "You can only add \(limit) intentions."
        case .invalidBegin(_, let count): return "Can't begin with \(count) tiles."
        case .persistenceFailed: return "Saving failed. Try again."
        case .unexpected: return "Something went wrong. Please try again."
        }
    }
    
}
-e \n\n
=== ./intention/Features/Focus/FocusSessionActiveV.swift ===
//
//  FocusSessionActiveV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.

import SwiftUI

/// Error types specific to the active session/chunk
enum ActiveSessionError: Error, Equatable, LocalizedError {
    case submitFailed, sessionAlreadyRunning
    
    var errorDescription: String? {
        switch self {
        case .submitFailed: return "Submit failed"
        case .sessionAlreadyRunning: return "A session is already running."
        }
    }
}

/// MembershipSheetV modal sheet presentation handling enum
enum ActiveSheet: Equatable { case none, membership }

/// Primary screen. Accepts two intention tiles and runs a 20-min countdown.
/// Hosts validation UI, dynamic messages and the recalibration sheet
struct FocusSessionActiveV: View {
    
    // MARK: Environment
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var statsVM: StatsVM
    @EnvironmentObject var memVM: MembershipVM
    @Environment(\.dismiss) var dismiss
    @Environment(\.scenePhase) private var phase
    @Environment(\.accessibilityDifferentiateWithoutColor) private var diffNoColor
    
    // MARK: View Models
    @ObservedObject var focusVM: FocusSessionVM
    @ObservedObject var recalibrationVM: RecalibrationVM
    
    // MARK: Local UI State
    /// manages both focus to textfield AND return from background
    /// single flag `showValidation`controls when to show validation checks
    @FocusState private var intentionFocused: Bool
    @State private var showValidation: Bool = false
    @State private var isBusy = false
    @State private var isShowingRecalibrationToDebug = false
//    @State private var isShowingOrganizerOverlayToDebug = false
    
    /// Theme hooks
    private let screen: ScreenName = .focus
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions for Focus ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    // MARK: - Computed helpers -
    private var isInputActive: Bool {
        focusVM.phase != .running && focusVM.tiles.count < 2
    }
    
    private var vState: ValidationState {
        // Until first submit, stay neutral - charcoal border, no caption)
        guard showValidation else { return .none }
        let msgs = focusVM.tileText.taskValidationMessages
        return msgs.isEmpty ? .valid : .invalid(messages: msgs)
    }
    
    private var upperComposer: some View {
        VStack(alignment: .leading, spacing: 8) {
            StatsSummaryBar()
            
            if isInputActive {
                // onSubmit and primaryCTA both call the same VM method handlePrimaryTap() -> "same funnel"
                // lifted .placeholder / .caption contrast in ThemeManager and that boots this textfield
                
                IntentionField(
                    p: p,
                    text: $focusVM.tileText,
                    showValidation: $showValidation,
                    vState: vState,
                    isEnabled: isInputActive
                ) { trimmed in
                    Task {
                        do {

                            _ = try await focusVM.handlePrimaryTap(validatedInput: trimmed)
                        } catch {
                            debugPrint(
                                "[FocusSessionActiveV] handlePrimaryTap(from IntentionField) failed: \(error)"
                            )
                        }
                    }
                }
            }
            messageSection
            countdownSection
        }
    }
    
    // MARK: - Message Section
    private var messageSection: some View {
        // Guidance  Messages (no Add/Begin here)
        DynamicMessageAndActionArea(
            onRecalibrateNow: { focusVM.showRecalibrate = true }
        )
        .environmentObject(focusVM)
        .padding(.top, 8)
        .environmentObject(theme)
    }
    
    // MARK: - DynamicCountdown
    //  Centered countdown (its internal own logic self-selects paused/running visuals
    //      inside it, `isActive` includes .running  .paused
    //      In .paused, it draws the clipped overlay  "Paused"; in .running, it draws the unwinding pie  time
    //      The tap target persists across both states, thanks to .onTapGesture { handleTap() }.
    private var countdownSection: some View {
        DynamicCountdown(
            palette: p,
            progress: Double(focusVM.countdownRemaining) / Double( TimerConfig.current.chunkDuration )
        )
        .environmentObject(focusVM)
        .padding(.top, 28)  // separates from Stats and messages
        .frame(maxWidth: .infinity)  // centers fixed-size content
        .frame(minHeight: 320)          // reserves vertical space so it dominates the section
        .contentShape(Rectangle())      // keeps taps clean in the area
    }
    
    // MARK: Slot helpers
    /// Visual order = [first, second]
    private var slots: [String?] {
        let first = focusVM.tiles.indices.contains(0) ? focusVM.tiles[0].text : nil
        let second = focusVM.tiles.indices.contains(1) ? focusVM.tiles[1].text : nil
        return [first, second]
    }
    
    /// Completed check uses VM’s persisted logic so it survives navigation/app relaunch
    private func completionForSlot(_ slot: Int) -> Bool {
        guard focusVM.tiles.indices.contains(slot) else { return false }
        return focusVM.thisTileIsCompleted(focusVM.tiles[slot])
    }
    
    /// Active = white; inactive = brown/gray (segment look)
    private func isActiveSlot(_ slot: Int) -> Bool {
        // 1) Before any tiles exist, guide the user by highlighting Tile 1
        if slot == 0 && !focusVM.tiles.indices.contains(0) { return true }
        
        let firstCompleted  = completionForSlot(0)
        let secondCompleted = completionForSlot(1)
        
        switch slot {
        case 0:
            // 2) Keep tile 1 active until completed
            return focusVM.tiles.indices.contains(0) ? !firstCompleted : true
        case 1:
            // Active after first completes, until second completes
            guard focusVM.tiles.indices.contains(1) else { return false }
            return firstCompleted && !secondCompleted
        default:
            return false
        }
    }
    
    // MARK: - Primary CTA helpers
    /// Icon for the primary CTA button
    ///     - Before two tiles: "add"
    ///     - When ready to begin: "play"
    private var primaryCTAIconName: String {
        focusVM.ui_isReadyForBegin ? "play.fill" : "plus.circle"
    }
    
    private var primaryCTALabel: some View {
        HStack {
            Image(systemName: primaryCTAIconName)
            T(focusVM.primaryCTATile, .action)
                .monospacedDigit()
        }
    }
    
    // MARK: Centralized primary-CTA tap handler
    private func handlePrimaryCTATap() {
        showValidation = true
        // For Add flow, enforce validation first; for Begin flow canPrimary already handles phase/tiles.
        if focusVM.tiles.count < 2 && vState.isInvalid {
            return
        }
        
        let trimmed = focusVM.tileText.trimmingCharacters(in: .whitespacesAndNewlines)
        
        Task {
            do { _ = try await focusVM.handlePrimaryTap(validatedInput: trimmed) }
            catch {
                debugPrint("[FocusSessionActiveV] handlePrimaryTap(from primary CTA) failed: \(error)")
                // If you later add focusVM.setError(_:) or similar, plug it in here.
                /* show error overlay? */
            }
        }
        
        focusVM.tileText = ""
        intentionFocused = (focusVM.tiles.count < 2)
        showValidation = false
    }
    
    
    // MARK: - Body
    var body: some View {
        VStack(spacing: 0){
            ScrollView {
                Page(top: 6, alignment: .center) {
                    
                    upperComposer
                        .padding(.top, 8)
                        .onDisappear { intentionFocused = false }
                        .onAppear { guard !IS_PREVIEW else { return }
                            focusVM.enterIdleIfNeeded()
                            // Auto-focus on first load, if we still can add text
                            intentionFocused = (focusVM.phase != .running && focusVM.tiles.count < 2)
                        }
                    // Drops focus when we start running or when we leave the screen
                        .onChange(of: focusVM.phase) { phase in
                            if phase == .running {
                                intentionFocused = false
                            }
                        }
                }
            }
            
            // This spacer pushes the scrollable content to the top,
            // making space for the BottomComposer at the very bottom.
            Spacer(minLength: 0)
            
            BottomComposer
            // inside the main VStack, ensuring it sits at the bottom
            // and doesn't interfere with the ScrollView.
            // It will be snug against the bottom of the screen.
        }
        
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        // Single bottom chrome: do NOT add an overlay; this keeps it snug to the tab bar
        .fullScreenCover(isPresented: $focusVM.showRecalibrate) {
            RecalibrationSheetChrome(onClose: {
                recalibrationVM.performAsyncAction {
                    if recalibrationVM.phase == .running || recalibrationVM.phase == .pause {
                        try await recalibrationVM.stop()
                    }
                }
                focusVM.showRecalibrate = false
            }) {
                NavigationStack {
                    RecalibrationV(vm: recalibrationVM)
                        .navigationBarHidden(true)          // own chrome owns the close
                }
            }
        }
        .onDisappear {
            if focusVM.showRecalibrate == false {
                recalibrationVM.performAsyncAction {
                    if recalibrationVM.phase == .running || recalibrationVM.phase == .pause {
                        try await recalibrationVM.stop()
                    }
                }
            }
        }
        
    }
    
    // MARK: Bottom composer
    @ViewBuilder
    private var BottomComposer: some View {
        // Two slots; we present [first, second] visual order by using slots[]
        VStack(spacing: 10){
            ForEach(0..<slots.count, id: \.self) { slot in
                TileSlot(
                    text: slots[slot] ?? "",
                    isFilled: (slots[slot]?.isEmpty == false),
                    isCompleted: completionForSlot(slot),
                    isActive: isActiveSlot(slot),
                    /// VM owns
                    isEditable: focusVM.canEditTile(at: slot),
                    p: p,
                    diffNoColor: diffNoColor,
                    onTap: {
                        // only try to edit if there's a tile
                        guard slots[slot] != nil else { return }
                        // vm owns mutation and rules
                        focusVM.beginEditingTile(at: slot)
                        //View owns focus and validation UX
                        showValidation = true
                        intentionFocused = true
                    }
                )
                .environmentObject(theme)
            }
            
            
            Button(
                action: handlePrimaryCTATap
            ) {
                primaryCTALabel
            }
            .primaryActionStyle(screen: screen)
            .pulseAura(color: p.accent, active: focusVM.ui_isReadyForBegin)   // VM-driven
            .frame(maxWidth: .infinity)
            .disabled(!focusVM.canPrimary)
            .accessibilityIdentifier("primaryCTA")
        }
        
        .padding(.top, 12)
        /// tile and begin/add container controls
        .padding(.horizontal, 16)
        .padding(.bottom, 12)
        .background(.thinMaterial)
        .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
        .animation(.easeInOut(duration: 0.2), value: focusVM.tiles)
    }
}
    
    // MARK: - IntentionField struct
    // keeps "show validation, submit, text" in one location
    private struct IntentionField: View {
        @EnvironmentObject var theme: ThemeManager
        
        let p: ScreenStylePalette
        @Binding var text: String
        @Binding var showValidation: Bool
        let vState: ValidationState
        let isEnabled: Bool
        let onValidatedSubmit: (String) -> Void
        
        @FocusState private var isFocused: Bool
        
        // MARK: - Body
        var body: some View {
            VStack(alignment: .leading, spacing: 8) {
                TextField(
                    "",
                    text: $text,
                    prompt: theme.styledText("Add Your Intended Task", as: .caption, in: .focus)
                )
                // set the text color to a dark, contrasting color
                .foregroundStyle(p.text)
                .focused($isFocused)
                .submitLabel(.done)
                .validatingField(state: vState, palette: p)
                .disabled(!isEnabled)
                .autocorrectionDisabled()
                .textInputAutocapitalization(.sentences)
                .onSubmit { handleSubmit() }
                
                if showValidation, case .invalid = vState {
                    ValidationCaption(state: vState)
                }
            }
            .onAppear {
                isFocused = isEnabled
            }
            .onChange(of: isEnabled) { enabled in
                if !enabled { isFocused = false }
            }
        }
        
        private func handleSubmit() {
            // commented out was before revalidating off current text
            showValidation = true
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
            guard trimmed.taskValidationMessages.isEmpty else { return }
            onValidatedSubmit(trimmed)
//            guard !vState.isInvalid else { return }
            
//            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
//            onValidatedSubmit(trimmed)
            
            text = ""
            isFocused = isEnabled // re-focus until two tiles
            showValidation = false
        }
    }
    
    //  MARK: - TileSlot struct
    // TileSlot view (compact min height; segment-like look, multi-line text wraps fully,)
    private struct TileSlot: View {
        @EnvironmentObject var theme: ThemeManager
        
        let text: String
        let isFilled: Bool
        let isCompleted: Bool
        let isActive: Bool
        let isEditable: Bool
        let p: ScreenStylePalette
        let diffNoColor: Bool
        let onTap: (() -> Void)?
        
        // Layout constants
        private let hPad: CGFloat = 10
        private let vPad: CGFloat = 8
        private let minDesiredHeight: CGFloat = 1
        
        // --- Local Color Definitions for Focus ---
        private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
        private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
        private let colorDanger = Color.red
        private let colorSuccess = Color.green
        
        // MARK: Computed Helpers
        
        /// Icon logic:
        /// - Completed      → checkmark.circle.fill
        /// - Editable       → pencil.circle
        /// - Default filled → checkmark.circle
        private var trailingIconName: String {
            if isCompleted { return "checkmark.circle.fill" }
            if isEditable { return "pencil.circle" }
            return "checkmark.circle"
        }
        
        // MARK: - Body
        var body: some View {
            let bg = isActive ? p.surfaces : p.surfaces.opacity(0.35)
            let stroke = colorBorder
            
            // MARK: Tiles container
            VStack {
                if isFilled {
                    HStack(alignment: .top, spacing: 8) {
                        theme.styledText(text, as: .tile, in: .focus)
                            .foregroundStyle(p.text)
                        // Tiny leading for multi-line readability
                            .lineSpacing(2)
                        // Allow text to wrap to as many lines as needed
                            .lineLimit(nil)
                        // This allows the Text view to expand vertically while being constrained horizontally
                            .fixedSize(horizontal: false, vertical: true)
                        
                        // Fills the button width, actually
                        Spacer(minLength: 8)
                        
                        // Always show a checkmark for filled tiles
                        Image(systemName: trailingIconName)
                            .font(.body)                        // slightly increases size
                            .foregroundStyle(isCompleted ? colorSuccess : p.accent)   // more vivid than "accent"
                            .accessibilityHidden(true)
                    }
                    .baselineOffset(1)
                    .padding(.horizontal, hPad)
                    .padding(.vertical, vPad)
                } else {
                    // Empty state - no checkmarks yet
                    HStack(alignment: .firstTextBaseline, spacing: 20) {
                        Image(systemName: "text.alignleft")
                            .font(.body)
                            .accessibilityHidden(true)
                        Text("").foregroundStyle(textSecondary)
                    }
                    .padding(.horizontal, hPad)
                    .padding(.vertical, vPad)
                }
            }
            .background(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .fill(bg)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .stroke(stroke, lineWidth: 1)
            )
            // subtle lift to separate from page
            .shadow(radius: 0.5,y: 0.5)
            .contentShape(Rectangle())
            .onTapGesture { onTap?() }
            .accessibilityElement(children: .combine)
            .accessibilityLabel(
                isFilled
                ? (isCompleted ? "Intention completed" : "Intention")
                : "Empty slot"
            )
            .accessibilityHint(
                isEditable
                ? "Double tap to edit"
                : (isFilled ? "" : "Add an intention above, then press Add.")
                )
        }
    }
    
#if DEBUG
    @MainActor private extension FocusSessionVM {
        static var preview: FocusSessionVM {
            let vm = FocusSessionVM(previewMode: true, haptics: NoopHapticsClient())
            // In preview, show two tiles and a plausible remaining time
            vm.tiles = [TileM(text: "Write intro"), TileM(text: "Outline section 1")]
            vm.phase = .running                   // UI shows active state
            vm.currentSessionChunk = 0
            vm.countdownRemaining = 17 * 60 + 42  // static value prevents constant updates
            return vm
        }
    }
#endif
    
    
#if DEBUG
    #Preview("Focus (dumb)") {
        let theme = ThemeManager()
        let focus = FocusSessionVM(previewMode: true,
                                   haptics: NoopHapticsClient(),
                                   config: .current)
        let recal  = RecalibrationVM(haptics: NoopHapticsClient())
        
        FocusSessionActiveV(
            focusVM: focus,
            recalibrationVM: recal
        )
        .environmentObject(theme)
        /* readd ONLY if/when everything else is stable */
        /// .canvasCheap()
        .frame(maxWidth: 430)
    }
#endif
    
-e \n\n
=== ./intention/Features/Feedback/FeedbackV.swift ===
//
//  FeedbackV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/21/25.
//

import MessageUI
import SwiftUI


private extension View {
    @ViewBuilder func cardBackground() -> some View {
        background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12, style: .continuous))
        //TODO: Or use .shadow(radius: 3, y: 1)
    }
    @ViewBuilder func fieldClip() -> some View {
        clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
    }
}

struct FeedbackV: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var prefs: AppPreferencesVM
    
    @Environment(\.openURL) private var openURL

    // Inputs
    @State private var name: String = ""
    @State private var email: String = ""
    @State private var message: String = ""
    @State private var userID: String = "" // auto-filled

    // Validation states
    @State private var nameState: ValidationState = .none      // optional
    @State private var emailState: ValidationState = .none     // required
    @State private var messageState: ValidationState = .none   // required

    @State private var showComposer = false
    @State private var composerPayload: (subject: String, body: String)? = nil
    @State private var showingAlert = false
    @State private var alertMsg = ""

    private let maxMessageChars = 2000
    
    private let screen: ScreenName = .settings
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions for FeedbackV ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    // MARK: Precomputes
    private var trimmedMessage: String {
        message.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    private var messageCountText: String { "\(message.count)/\(maxMessageChars)" }
    private var deviceRowText: String { "Device ID: \(userID)" }
    // --- MAYBE THESE TOO? ---
    private var fieldStrokeShape: RoundedRectangle { .init(cornerRadius: 10, style: .continuous) }
    private var cardShape: RoundedRectangle { .init(cornerRadius: 12, style: .continuous) }

    
    // MARK: Section: Header
    @ViewBuilder private var headerRow: some View {
        T("Send Feedback", .header).cardBackground()
        //TODO: Or use .shadow(radius: 3, y: 1)
    }
    
        // MARK: Section: Name
        @ViewBuilder private var nameSection: some View {
            Group {
                T("Name (optional)", .label)
                Spacer()
                TextField("Jane Doe", text: $name)
                    .textInputAutocapitalization(.words)
                    .autocorrectionDisabled(false)
                    .validatingField(state: nameState, palette: p)
            }
        }

        // MARK: Section: Email
        @ViewBuilder private var emailSection: some View {
            Group {
                T("Email (required)", .label)
                    .cardBackground()

                Spacer()
                TextField("name@example.com", text: $email)
                    .keyboardType(.emailAddress)
                    .textContentType(.emailAddress)
                    .textInputAutocapitalization(.never)
                    .autocorrectionDisabled(true)
                    .validatingField(state: emailState, palette: p)
                ValidationCaption(state: emailState)
            }
        }
        
        // MARK: Section: Message
        @ViewBuilder private var messageSection: some View {
            Group {
                HStack {
                    T("Message", .label)
                        .cardBackground()
                    Spacer()
                    Text(messageCountText)
                        .font(.caption)
                        .foregroundStyle(textSecondary)
                        .monospacedDigit()
                }
                
                TextEditor(text: $message)
                    .frame(minHeight: 160)
                    .textInputAutocapitalization(.sentences)
                    .autocorrectionDisabled(false)
                    .padding(12)
                    .overlay(
                        fieldStrokeShape
                            .stroke(messageState.isInvalid ? colorDanger : colorBorder, lineWidth: 1)
                    )
                    .background(fieldStrokeShape.fill(Color.clear))
                    .fieldClip()
                ValidationCaption(state: messageState)
            }
        }
        
        // MARK: Section: Device Row
        @ViewBuilder private var deviceRow: some View {
            // Auto insert userID/deviceID from your Keychain helper
            T(deviceRowText, .caption)
                .foregroundStyle(textSecondary)
                .textSelection(.enabled)
        }
        
        // MARK: Section: Send button
        @ViewBuilder private var sendButtonSection: some View {
        Button(action: sendTapped) {
            T("Send", .action)
                .cardBackground()
                .monospacedDigit()
        }
        .primaryActionStyle(screen: screen)
        .disabled(!canSend)
    }
        
    // Keep the heavy sheet content out of the main body closure
        // MARK: Mail sheet content
        @ViewBuilder private var composerSheet: some View {
            if MFMailComposeViewController.canSendMail(), let payload = composerPayload {
                MailComposer(
                    to: ["feedback@argonnesoftware.com"],
                    subject: payload.subject,
                    body: payload.body
                ) { result in
                    switch result {
                    case .success:
                        alertMsg = "Thanks! Feedback sent!"
                    case .failure(let err):
                        alertMsg = "Could not send: \(err.localizedDescription)"
                    }
                    showingAlert = true
                }
            } else {
                // Fallback shouldn’t appear as a sheet; we’ll use openURL instead.
                EmptyView()
            }
        }
    
    // MARK: CanSend: Bool
    private var canSend: Bool {
        emailIsValid(email) && !trimmedMessage.isEmpty
    }

    var body: some View {
        // Email body with useful info for bug reports
        //        let body = "\n\nApp Version: \(version)\nDevice: \(deviceType)\niOS: \(osVersion)"
        
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                headerRow
                nameSection
                emailSection
                messageSection
                deviceRow
                sendButtonSection
            }
            .padding(20)
            .frame(maxWidth: 700, alignment: .leading)
        }
        .background(p.background.ignoresSafeArea())
        .tint(p.accent)
        .navigationTitle("Feedback")
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
        //TODO: Or use .shadow(radius: 3, y: 1)
        .navigationBarTitleDisplayMode(.inline)
        .scrollDismissesKeyboard(.interactively) // swipe down to dismiss
        .safeAreaInset(edge: .bottom) { Color.clear.frame(height: 8) } // keeps content visible above the keyboard on small screens
        .onAppear {
            // Keychain won't get involved in previews, only in real runs
            if IS_PREVIEW {
                userID = "PREVIEW-DEVICE-ID"
            } else {
                Task { @MainActor in
                    userID = await KeychainHelper.shared.getUserIdentifier()
                }
            }
        }
        .sheet(isPresented: $showComposer) { composerSheet }
        .alert("Feedback", isPresented: $showingAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(alertMsg)
        }
        .onChange(of: message) { new in
            if new.count > maxMessageChars {
                message = String(new.prefix(maxMessageChars))
            }
        }
    }
    
    /// Returns true if we successfully opened a mail client.
    /// UIApplication callers @MainActor (they already run on main, but this clarifies actor isolation)
    // MARK: - MainActor OpenMainTo()
    @MainActor
    @discardableResult
    private func openMailTo(subject: String, body: String) -> Bool {
        let to = "feedback@argonnesoftware.com"

        var comps = URLComponents()
        comps.scheme = "mailto"
        comps.path = to
        comps.queryItems = [
            URLQueryItem(name: "subject", value: subject),
            URLQueryItem(name: "body", value: body)
        ]

        guard let url = comps.url else { return false }

        // Prefer the environment's openURL (respects scene), but also probe UIApplication as a fallback.
        var opened = false
        openURL(url) { success in opened = success }
        if opened { return true }

        // Fallback probe (some contexts call this synchronously)
        if UIApplication.shared.canOpenURL(url) {
            UIApplication.shared.open(url)
            return true
        }

        return false
    }

    // MARK: - SendTapped()
    @MainActor
    private func sendTapped() {
        // validate now (gate surfacing)
        emailState = emailIsValid(email) ? .valid : .invalid(messages: ["Enter a valid email address."])
        messageState = message.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
            ? .invalid(messages: ["Message can’t be empty."])
            : .valid
        guard canSend else { return }

        let subject = "Intendly Feedback"
        let body = composedBody()
        composerPayload = (subject, body)

        // 1) Try user's default mail client via mailto:
        if openMailTo(subject: subject, body: body) {
            alertMsg = "Your mail app was opened with a pre-filled message."
            showingAlert = true
            return
        }

        // 2) Fallback to in-app composer (Apple Mail backend)
        if MFMailComposeViewController.canSendMail() {
            showComposer = true
            return
        }

        // 3) No handler + no Mail account: show a helpful message
        alertMsg = "No mail app available. Please configure a mail app or copy your message."
        showingAlert = true
    }

    // MARK: ComposedBody()
    private func composedBody() -> String {
        let appVersion = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "?"
        let build = Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "?"
        let sys = UIDevice.current.systemVersion
        let model = UIDevice.current.model

        return """
        Name: \(name.isEmpty ? "(not provided)" : name)
        Email: \(email)
        Device ID: \(userID)
        App: \(appVersion) (\(build)) • iOS \(sys) • \(model)

        ---- Message ----
        \(message)
        """
    }

    private func fallbackMailToIfNeeded() {
        guard let payload = composerPayload else { return }
        // URL-encode (simple)
        let to = "feedback@argonnesoftware.com"
        let subject = payload.subject.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "Feedback"
        let body = payload.body.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        if let url = URL(string: "mailto:\(to)?subject=\(subject)&body=\(body)") {
            UIApplication.shared.open(url)
        } else {
            alertMsg = "No Mail account is configured and I couldn’t open a mailto: link."
            showingAlert = true
        }
    }

    private func emailIsValid(_ s: String) -> Bool {
        let trimmed = s.trimmingCharacters(in: .whitespacesAndNewlines)
        guard trimmed.count <= 254 else { return false }
        // Lightweight validation: one @ and at least one dot after
        let parts = trimmed.split(separator: "@")
        guard parts.count == 2, parts[0].count >= 1 else { return false }
        return parts[1].contains(".")
    }
}
-e \n\n
=== ./intention/Features/Feedback/MailComposer.swift ===
//
//  MailComposer.swift
//  intention
//
//  Created by Benjamin Tryon on 10/21/25.
//


import MessageUI
import SwiftUI

struct MailComposer: UIViewControllerRepresentable {
    let to: [String]
    let subject: String
    let body: String
    let onComplete: (Result<Void, Error>) -> Void

    final class Coordinator: NSObject, MFMailComposeViewControllerDelegate {
        let parent: MailComposer
        init(_ parent: MailComposer) { self.parent = parent }
        func mailComposeController(_ controller: MFMailComposeViewController,
                                   didFinishWith result: MFMailComposeResult,
                                   error: Error?) {
            controller.dismiss(animated: true) {
                if let error { self.parent.onComplete(.failure(error)) }
                else { self.parent.onComplete(.success(())) }
            }
        }
    }

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIViewController(context: Context) -> MFMailComposeViewController {
        let vc = MFMailComposeViewController()
        vc.setToRecipients(to)
        vc.setSubject(subject)
        vc.setMessageBody(body, isHTML: false)
        vc.mailComposeDelegate = context.coordinator
        return vc
    }

    func updateUIViewController(_ uiViewController: MFMailComposeViewController, context: Context) {}
}
-e \n\n
=== ./intention/Features/Social/ShareService.swift ===
//
//  ShareService.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct ShareService: View {
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/"Hello, World!"/*@END_MENU_TOKEN@*/)
    }
}

#if DEBUG
#Preview {
    ShareService()
        
}
#endif
-e \n\n
=== ./intention/Features/History/HistoryV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

/// content-management screen
/// swipes live in CategoryTileList
struct HistoryV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var viewModel: HistoryVM
    
    // UI State
    @State private var createdCategoryID: UUID?
    @State private var targetCategoryID: UUID?
    @State private var showRenamePicker = false
    @State private var showDeletePicker = false
    @State private var showRenameSheet = false
    @State private var renameText = ""
    @State private var showDeleteConfirm = false
    @State private var isBusy = false
    
    /// Theme hooks
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let dividerRects = Color(red: 0.878, green: 0.847, blue: 0.796)
    
    // MARK: - Computed helpers
    
    private var canAddCategory: Bool {
        viewModel.canAddUserCategory()
    }
    
    private var hasGeneralTiles: Bool {
        viewModel.hasAnyGeneralTiles
    }
    
    private var historyTitleText: Text {
        T("History", .header)
    }
    
    private func finalizeHistoryIfNeededOnDisappear() {
        viewModel.commitPendingUndoIfAny()
        viewModel.flushPendingSaves()
    }
    
    // MARK: - Body
    
    var body: some View {
        ScrollView {
            Page(top: 6, alignment: .center) {
                LazyVStack(alignment: .leading, spacing: 8) {
                    // $Bindings are so rows can edit categories
                    ForEach($viewModel.categories) { $category in
                        CategoryCard(
                            category: $category,
                            isArchive: category.id == viewModel.archiveCategoryID,
                            onRename: { id in
                                targetCategoryID = id
                                renameText = viewModel.name(for: id)
                                showRenameSheet = true
                            }
                        )
                        .id(category.id)
                        
                        // -- category separator --
                        separator
                        //                        Rectangle()
                        //                            .fill(colorBorder)
                        //                            .frame(height: 1)
                        //                            .padding(.vertical, 4)
                        
                    }
                }
            }
            
            // Toasts
            HistoryToasts()
                .padding(.bottom, 8)
        }
        .background(p.background)
        .tint(p.accent)
        .toolbarBackground(.visible, for: .navigationBar)
        .animation(.easeInOut(duration: 0.2), value: viewModel.lastUndoableMove != nil)
        .toolbar { historyToolbar }
        .environmentObject(theme)
        .environmentObject(viewModel)
        .overlay {
            if let error = viewModel.lastError {
                ErrorOverlay(error: error) { viewModel.setError(nil) }
                    .transition(.opacity.combined(with: .scale))
                    .zIndex(1)
                    .allowsHitTesting(true)     // opt-in to hits only when visible
            }
        }
        .onDisappear {
            finalizeHistoryIfNeededOnDisappear()
        }
        .sheet(isPresented: $showRenameSheet) {
            renameCategorySheet
        }
        
        .alert("Delete category?", isPresented: $showDeleteConfirm) {
            Button("Delete", role: .destructive) {
                if let id = targetCategoryID {
                    Task { _ = viewModel.deleteCategory(id: id) }
                } else {
                    debugPrint("[HistoryV] Delete confirm fired but targetCategoryID is nil")
                }
            }
            Button("Cancel", role: .cancel) { }
        } message: {
            T("Tiles will be moved to Archive.", .tile)
        }
    }

    // MARK: - Subviews
    private var separator: some View {
        Rectangle()
            .fill(dividerRects)
            .frame(height: 1)
            .padding(.leading, 6)
            .padding(.trailing, 6)
            .padding(.top, 6)
    }
    
    
    // MARK: - Rename Sheet
    private var renameCategorySheet: some View {
        RenamingSheetChrome(onClose: {
            showRenameSheet = false
        }) {
            let currentName: String = {
                guard let id = targetCategoryID else { return "" }
                return viewModel.name(for: id)
            }()
            
            NavigationStack {
                RenameCategoryV(
                    originalName: currentName,
                    text: $renameText,
                    onCancel: { showRenameSheet = false },
                    onSave: {
                        let trimmed = renameText.trimmingCharacters(in: .whitespacesAndNewlines)
                        if let id = targetCategoryID, !trimmed.isEmpty {
                            viewModel.renameCategory(id: id, to: trimmed)
                        } else if trimmed.isEmpty {
                            debugPrint("[HistoryV] Rename attempted with empty string; ignoring")
                        }
                        showRenameSheet = false
                    }
                )
                .navigationBarHidden(true)
                .environmentObject(theme)
            }
        }
        .interactiveDismissDisabled(false)
    }
    
    // MARK: - Toolbar
    @ToolbarContentBuilder
    private var historyToolbar: some ToolbarContent {
        ToolbarItem(placement: .principal) {
            historyTitleMenu
        }
    }
    
    private var historyTitleMenu: some View {
        historyTitleText
            .toolbarTitleMenu {
                addCategoryToolbarButton
                renameCategoryToolbarButton
                deleteCategoryToolbarButton
                
                Divider()
                
                archiveMostRecentToolbarButton
            }
    }
    
    // MARK: Toolbar button blocks (Image + T pattern)
    private var addCategoryToolbarButton: some View {
        Button(action: {
            if let id = viewModel.addEmptyUserCategory() {
                createdCategoryID = id
            } else {
                debugPrint("[HistoryV] Add category not possible (cap hit)")
            }
        }) {
            HStack {
                Image(systemName: "plus")
                T("Add Category", .action)
            }
        }
        .disabled(!canAddCategory)
    }
    
    private var renameCategoryToolbarButton: some View {
        Button(action: {
            if let only = viewModel.userCategoryIDs.only {
                targetCategoryID = only
                renameText = viewModel.name(for: only)
                showRenameSheet = true
            } else {
                showRenamePicker = true
            }
        }) {
            HStack {
                Image(systemName: "pencil")
                T("Rename Category", .action)
            }
        }
    }
    
    private var deleteCategoryToolbarButton: some View {
        Button(role: .destructive, action: {
            if let only = viewModel.userCategoryIDs.only {
                targetCategoryID = only
                showDeleteConfirm = true
            } else {
                showDeletePicker = true
            }
        }) {
            HStack {
                Image(systemName: "trash")
                T("Delete Category", .action)
            }
        }
    }
    
    private var archiveMostRecentToolbarButton: some View {
        Button(action: {
            Task { await viewModel.archiveMostRecentFromGeneral() }
        }) {
            HStack {
                Image(systemName: "arrow.up.circle")
                T("Archive Most Recent From General", .action)
            }
        }
        .disabled(!hasGeneralTiles)
    }
}


//    //    @ToolbarContentBuilder private var historyToolbar: some ToolbarContent {
//    //        ToolbarItemGroup(placement: .topBarTrailing) {
//    @ToolbarContentBuilder
//    private var historyToolbar: some ToolbarContent {
//        // Primary edit/done toggle - keep as trailing item
//        ToolbarItemGroup(placement: .principal) {
//            T("History", .header)
//                .toolbarTitleMenu {
//                    // Add category - guarded by VM cap
//                    Button {
//                        if let id = viewModel.addEmptyUserCategory() { createdCategoryID = id } else {
//                            debugPrint("Add Not Possible")
//                        }
//                    } label: {
//                        Image(systemName: "plus"); T("Add Category", .action)
//                    }
//                    .disabled(!viewModel.canAddUserCategory())
//                    .background(colorBorder)
//                    //                    .imageScale(.small).font(.headline).controlSize(.large).tint(p.accent)
//
//                    // Rename (single category fast path, else show picker in your UI)
//                    Button {
//                        if let only = viewModel.userCategoryIDs.only {
//                            targetCategoryID = only
//                            renameText = viewModel.name(for: only)
//                            showRenameSheet = true
//                        } else {
//                            showRenamePicker = true
//                        }
//                    } label: {
//                        Image(systemName: "pencil"); T("Rename Category", .action)
//                    }
//
//                    // Delete (moves tiles to Archive)
//                    Button(role: .destructive) {
//                        if let only = viewModel.userCategoryIDs.only {
//                            targetCategoryID = only
//                            showDeleteConfirm = true
//                        } else {
//                            showDeletePicker = true
//                        }
//                    } label: {
//                        Image(systemName: "trash"); T("Delete Category", .action)
//                    }
//
//                    Divider()
//
//                    // Quick archive from General
//                    Button {
//                        Task { await viewModel.archiveMostRecentFromGeneral() }
//                    } label: {
//                        Image(systemName: "arrow.up.circle"); T("Archive Most Recent From General", .action)
//                    }
//                    .disabled(!viewModel.hasAnyGeneralTiles)
//                }
//        }
//    }
//}

// UUID helper
extension Array {
    var only: Element? { count == 1 ? first : nil }
}

// MARK: - Category Card (local)
// Creates rounded card chrome around CategoryHeaderRow and CategoryTileList
private struct CategoryCard: View {
    @EnvironmentObject private var viewModel: HistoryVM
    @EnvironmentObject private var theme: ThemeManager
    
    @Binding var category: CategoriesModel
    let isArchive: Bool
    var onRename: (UUID) -> Void
    
    /// Theme hooks
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            CategoryHeaderRow(
                title: isArchive ? "Archive" : category.persistedInput.ifEmpty("Untitled"),
                count: category.tiles.count,
                isArchive: isArchive,
                allowEdit: !isArchive && category.id != viewModel.generalCategoryID,
                onRename: {  onRename(category.id) },       // NOTE: CategoryHeaderRow expects () -> Void, adapt by calling the closure with category.id
            )
            CategoryTileList(
                category: $category,
                isArchive: isArchive
            )
            .padding(.vertical, 12)
            .environmentObject(viewModel)
            .environmentObject(theme)
        }
        .padding(.horizontal, 6)
    }
}


// MARK: - RenameCategoryV
// a form - it is shown in RenamingSheetChrome
private struct RenameCategoryV: View {
    @EnvironmentObject var theme: ThemeManager
    
    var originalName: String
    @Binding var text: String
    var onCancel: () -> Void
    var onSave: () -> Void
    
    /// Theme hooks
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        VStack(spacing: 16) {
            // Handle area already provided by Chrome; minimal UI
            VStack(alignment: .leading, spacing: 12) {
                T("Rename Category", .header)
                
                TextField("Category name", text: $text)
                    .textInputAutocapitalization(.words)
                    .disableAutocorrection(true)
                    .padding(12)
                    .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 10))
                
                HStack(spacing: 12) {
                    Button(action: onCancel) {
                        HStack {
                            Image(systemName: "xmark")
                            T("Cancel", .action)
                        }
                    }
                    .secondaryActionStyle(screen: screen)
                    .frame(maxWidth: .infinity, minHeight: 44)
                    
                    Button(action: onSave) {
                        HStack {
                            Image(systemName: "checkmark")
                            T("Save", .action)
                        }
                    }
                    .primaryActionStyle(screen: screen)
                    .frame(maxWidth: .infinity, minHeight: 44)
                    .disabled(
                        text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ||
                        text.trimmingCharacters(in: .whitespacesAndNewlines) == originalName
                    )
                }
            }
            .padding(16)
            .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16))
            
            Spacer(minLength: 0)
        }
        .padding(.horizontal, 16)
        .background(Color.clear) // Chrome provides bg
    }
}

// MARK: - HistoryToasts
/// Extracted toast stack so HistoryV reads as: list → toasts → overlays.
private struct HistoryToasts: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var viewModel: HistoryVM
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    private var showsUndoToast: Bool {
        viewModel.pendingUndoMove != nil
    }
    
    private var showsArchiveCapToast: Bool {
        viewModel.tileLimitWarning
    }
    
    var body: some View {
        VStack(spacing: 8) {
            if showsUndoToast {
                undoToast
            }
            
            if showsArchiveCapToast {
                archiveCapToast
            }
        }
    }
    
    // MARK: - Individual toasts
    private var undoToast: some View {
        HStack(spacing: 12) {
            Image(systemName: "arrow.uturn.backward")
                .imageScale(.medium)
                .foregroundStyle(p.text)
            
            T("Moved.", .secondary)
            
            Spacer()
            
            Button(action: {
                viewModel.undoPendingMoveIfPossible()
            }) {
                HStack {
                    Image(systemName: "arrow.uturn.backward.circle")
                    T("Undo", .action)
                }
            }
            .primaryActionStyle(screen: screen)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 10)
        .background(.ultraThinMaterial, in: Capsule())
        .transition(.move(edge: .bottom).combined(with: .opacity))
    }
    
    private var archiveCapToast: some View {
        T("Archive capped at 200; oldest items were removed.", .tile)
            .padding(.horizontal, 12)
            .padding(.vertical, 10)
            .background(.ultraThinMaterial, in: Capsule())
            .task {
                try? await Task.sleep(for: .seconds(2))
                await MainActor.run { viewModel.tileLimitWarning = false }
            }
            .transition(.move(edge: .bottom).combined(with: .opacity))
    }
}

// UUID helper
private extension String {
    func ifEmpty(_ replacement: String) -> String { isEmpty ? replacement : self }
}

#if DEBUG
extension HistoryV {
    init(
        viewModel: HistoryVM,
        _preview_showRenameSheet: Bool = false,
        _preview_targetCategoryID: UUID? = nil,
        _preview_renameText: String = ""
    ) {
        self.viewModel = viewModel
        _showRenameSheet = State(initialValue: _preview_showRenameSheet)
        _targetCategoryID = State(initialValue: _preview_targetCategoryID)
        _renameText      = State(initialValue: _preview_renameText)
    }
}
#endif


#if DEBUG
#Preview("History (dumb)") {
    let theme = ThemeManager()
    let hist  = HistoryVM(persistence: PersistenceActor()) // no seeding
    
    HistoryV(viewModel: hist)
        .environmentObject(theme)
        .environmentObject(hist)
        .frame(maxWidth: 430)
}
#endif
-e \n\n
=== ./intention/Features/History/ArchiveActor.swift ===
//
//  ArchiveActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/26/25.
//

import Foundation
// dedicated actor to handle offloading old tiles
// receives a [CategoriesModel], trims tiles beyond the 200 tile cap and persist

/// Purpose: points to a tile where it lives without copying text or timeStamp. Different than TileM (the full model) and different than TileOrganizerVM (a ViewModel for UI organizing)
/// Identity used for offloading between actors
struct TileRef: Hashable, Codable, Sendable {
    let categoryID: UUID
    let tileID: UUID
}

/// Purpose: archives tiles into persistent list
/// dedicated, thread-safe manager - handles offloading into archive from "live" categories dedicated, thread-safe manager for archiving tiles. It handles offloading old tiles from live categories to a persistent archive, ensuring the total count of tiles remains below a specified limit.
/// The **only store of Archive tiles** (authoritative for Archive contents

actor ArchiveActor {
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let archiveKey = "archivedTiles"
//
//    struct OffloadResult: Sendable, Codable {
//        let archived: [TileM]           /// full tiles archived first, and in the bottom most location of the archive
//        let refs: [TileRef]             /// exact locations the tiles came from
//    }
//    
//    /// Offload tiles to archive storage, top-first, **excluding** Archive category
//    /// - Parameters:
//    ///     - categories: to consider
//    ///     - maxTiles: cap for *live* tiles (General + user categories)
//    /// - Returns: OffloadResult with exact refs & tiles archived; Empty if no overflow
//    func offloadOldTiles(from categories: [CategoriesModel], maxTiles: Int) async throws {
//        // 1) Flatten only non-Archive categories (HistoryVM will pass those; this is defensive)
//        let live = categories
//        // 2) oldest/bottom first across live times
//        let all = live.flatMap(\.tiles).sorted { $0.timeStamp < $1.timeStamp }
//        let overflowCount = max(0, all.count - maxTiles)
//        guard overflowCount > 0 else { return }
//        
//        // the oldest overflow that must be offloaded
//        let toArchive = Array(all.prefix(overflowCount))  // take the oldest overflow
//
//        // 3) Append to existing archive (keep newest at top in storage)
//        let existing = await loadArchivedTiles()
//        var combined = toArchive.reversed() + existing     // put “newly archived” on top
//        if combined.count > maxTiles {
//            combined.removeLast(combined.count - maxTiles) // drop oldest from bottom
//        }
//
//        let data = try encoder.encode(combined)
//        UserDefaults.standard.set(data, forKey: archiveKey)
//        #if DEBUG
//        debugPrint("ArchiveActor: Archived \(toArchive.count) tiles. Archive total: \(combined.count)")
//        #endif
//    }
    
    // Write/load archived tiles for testing or restoration.
    func loadArchivedTiles() async -> [TileM] {
        guard let data = UserDefaults.standard.data(forKey: archiveKey) else { return [] }
        do { return try decoder.decode([TileM].self, from: data) } catch { debugPrint("ArchiveActor: decode archived tiles failed:", error); return [] }
    }
    
    // Update on every Archive mutation
    func saveArchivedTiles(_ tiles: [TileM]) async {
        if let data = try? encoder.encode(tiles) {
            UserDefaults.standard.set(data, forKey: archiveKey)
        }
    }
    
    // Clear archive for testing/reset
    func clearArchive() { UserDefaults.standard.removeObject(forKey: archiveKey) }
}
-e \n\n
=== ./intention/Features/History/PendingUndoMove.swift ===
//
//  PendingUndoMove.swift
//  intention
//
//  Created by Benjamin Tryon on 11/12/25.
//

import SwiftUI

struct PendingUndoMove: Equatable {
    let tile: TileM
    let fromCategoryID: UUID
    let toCategoryID: UUID
    let expiresAt: Date
}

#Preview {
//    PendingUndoMove()
}
-e \n\n
=== ./intention/Features/History/HistoryVM.swift ===
//
//  HistoryVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

enum HistoryError: Error, Equatable, LocalizedError {
    case categoryNotFound, historyNotLoaded, saveHistoryFailed, moveFailed
    
    var errorDescription: String? {
        switch self {
        case .categoryNotFound: return "Category not found."
        case .historyNotLoaded: return "History not loaded."
        case .saveHistoryFailed: return "Could not save history."
        case .moveFailed: return "Tile move failed."
        }
    }
}

/// VM decides *when*, persistence/actors decide *how*.
/// Single source of truth for General/Archive IDs and category ordering.
@MainActor
final class HistoryVM: ObservableObject {
    // MARK: Published UI state -
    @Published var categories: [CategoriesModel] = []
    @Published var categoryValidationMessages: [UUID: [String]] = [:]
    @Published var tileLimitWarning: Bool = false
    @Published var lastUndoableMove: (tile: TileM, from: UUID, to: UUID)?       //FIXME: update with from = fromCategoryID to = toCategoryID or whatever
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    
    // Undo window
    @Published private(set) var pendingUndoMove: PendingUndoMove?       // see Undo Window Policy
    
    // MARK: Dependencies -
    private let persistence: any Persistence
    private let archiveActor = ArchiveActor()
    
    // MARK: Storage keys / caps / debounce -
    private let storageKey = "categoriesData"
    private let tileSoftCap = 200                      // Archive cap
    private var pendingSnapshot: [CategoriesModel]?
    private var debouncedSaveTask: Task<Void, Never>?
    private var lastSavedSignature: Int = 0
    private let saveDebouncedDelayNanos: UInt64 = 300_000_000 // 300 ms
    
    // MARK: Undo Window policy -
    private let undoWindowSeconds: Int = 8
    private let undoMaxTilesInDestination: Int = 5
    private var undoTickerTask: Task<Void, Never>?      // new
    
    // MARK: Canonical IDs (persisted)
    @AppStorage("generalCategoryID") private var generalCategoryIDString: String = ""
    @AppStorage("archiveCategoryID") private var archiveCategoryIDString: String = ""
    
    var generalCategoryID: UUID {
        get { UUID(uuidString: generalCategoryIDString) ?? { let u = UUID(); generalCategoryIDString = u.uuidString; return u }() }
        set { generalCategoryIDString = newValue.uuidString }
    }
    var archiveCategoryID: UUID {
        get { UUID(uuidString: archiveCategoryIDString) ?? { let u = UUID(); archiveCategoryIDString = u.uuidString; return u }() }
        set { archiveCategoryIDString = newValue.uuidString }
    }
    
    // MARK: - Init
    init(persistence: any Persistence) {
        self.persistence = persistence
        Task { await loadHistory() }
    }
    
    
    
    // MARK: erroroverlay
    func setError(_ error: Error?) { lastError = error }
    
    // MARK: - Load + Reconcile
    private func loadHistory() async {
        do {
            // Load categories from disk (without Archive tiles; those hydrate from ArchiveActor)
            if let loaded: [CategoriesModel] = try await persistence.readIfExists([CategoriesModel].self, from: storageKey) {
                categories = loaded
            } else {
                categories = []
            }
            
            // Reconcile built-in IDs by name, if present
            if let g = categories.first(where: { $0.persistedInput == "General" }) { generalCategoryID = g.id }
            if let a = categories.first(where: { $0.persistedInput == "Archive" }) { archiveCategoryID = a.id }
            
            // Ensure both built-ins exist using canonical IDs
            if !categories.contains(where: { $0.id == generalCategoryID }) {
                categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
            }
            if !categories.contains(where: { $0.id == archiveCategoryID }) {
                categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
            }
            
            // Hydrate Archive tiles from ArchiveActor and enforce cap (now that the archive ID is canonical)
            let archived = await archiveActor.loadArchivedTiles()
            if let aIdx = categories.firstIndex(where: { $0.id == archiveCategoryID }) {
                categories[aIdx].tiles = archived
                applyCaps(afterInsertingIn: aIdx) // trims if > 200 and mirrors back to actor
            }
            
            // "Persist" and "normalize": keeps data in order
            normalizeCategoryOrder()
            // save the sanitized (Archive-empty) snapshot
            saveHistory()
            
        } catch {
            debugPrint("[HistoryVM.loadHistory] error:", error)
            lastError = error
        }
    }
    
    /// Reconcile built-ins again on demand; then persist.
    func reconcileAndEnsureBuiltIns() {
        // Reconcile built-in IDs by name, if present and write them back to AppStorage.
        if let g = categories.first(where: { $0.persistedInput == "General" }) { generalCategoryID = g.id }
        if let a = categories.first(where: { $0.persistedInput == "Archive" }) { archiveCategoryID = a.id }
        
        // Ensure both built-ins exist using canonical IDs
        if !categories.contains(where: { $0.id == generalCategoryID }) {
            categories.insert(CategoriesModel(id: generalCategoryID, persistedInput: "General"), at: 0)
        }
        if !categories.contains(where: { $0.id == archiveCategoryID }) {
            categories.append(CategoriesModel(id: archiveCategoryID, persistedInput: "Archive"))
        }
        
        // "Persist" and "normalize": keeps data in order
        normalizeCategoryOrder()
        // save the sanitized (Archive-empty) snapshot
        saveHistory()
    }
    
    // MARK: Undo helpers
    //FIXME: clarity as toSourceID, fromCategoies?\
    //FIXME: lastUndoableMove = (moving, sourceID, destinationID) example?
    private var now: Date { Date() }
    
    private func categoryIndex(for id: UUID) -> Int? { categories.firstIndex(where: { $0.id == id } ) }
    private func category(for id: UUID) -> CategoriesModel? { categories.first(where: { $0.id == id } ) }
    private func canUndoCurrentMove() -> Bool {
        guard let pending = pendingUndoMove,
              let destCount = category(for: pending.toCategoryID)?.tiles.count else { return false }
        return now < pending.expiresAt && destCount <= undoMaxTilesInDestination
    }
    
    // MARK: Ordering (Canonical - General -> A-Z users, cats -> Archive)
    
    /// Rebuilds array as: General → (user categories, A–Z by name) → Archive
    /// Call after *every* mutation that could affect order.
    fileprivate func normalizeCategoryOrder() {
        // pull out General + Archive
        guard
            let gIdx = categories.firstIndex(where: { $0.id == generalCategoryID }),
            let aIdx = categories.firstIndex(where: { $0.id == archiveCategoryID })
        else { return }
        
        let general = categories[gIdx]
        let archive = categories[aIdx]
        // alphabetize remaining - as user categories
        let users = categories
            .filter { $0.id != generalCategoryID && $0.id != archiveCategoryID }
        //            .sorted { $0.persistedInput.localizedCaseInsensitiveCompare($1.persistedInput) == .orderedAscending }
        // rebuild: General first → users → Archive last
        categories = [general] + users + [archive]
    }
    
    // MARK: Sanitization & Persistence
    // sanitizedForSave() and performSaveIfChanged - Persist categories without the Archive tiles. Hydrate Archive tiles on load from ArchiveActor
    private func sanitizedForSave(_ cats: [CategoriesModel]) -> [CategoriesModel] {
        cats.map { category in
            var copy = category
            if category.id == archiveCategoryID { copy.tiles = [] }     // keep Archive empty in categoriesData - Archive tiles live in ArchiveActor
            return copy
        }
    }
    
    private func saveSignature(for categories: [CategoriesModel]) -> Int {
        var acc = categories.count
        for cat in categories {
            acc = acc &* 31 &+ cat.id.hashValue &+ cat.tiles.count  //// Mixes ID + tile count
        }
        return acc
    }
    
    // Writes only if content changed since last success - if `snapshot` is nil, uses live `categories`
    private func performSaveIfChanged(_ snapshot: [CategoriesModel]? = nil) async {
        let raw = snapshot ?? categories
        let toWrite = sanitizedForSave(raw)
        let signature = saveSignature(for: toWrite)               // compare sanitized - not raw
        guard signature != lastSavedSignature else { return }
        do {
            try await persistence.write(toWrite, to: storageKey)
            lastSavedSignature = signature
        } catch {
            debugPrint("[HistoryVM.performSaveIfChanged] error: ", error)
            await MainActor.run { self.lastError = HistoryError.saveHistoryFailed }
        }
    }
    
    /// Public save entrypoint.
    func saveHistory(immediate: Bool = false) {
        if immediate {
            let snapshot = categories
            pendingSnapshot = nil
            debouncedSaveTask?.cancel()
            debouncedSaveTask = nil
            Task { await performSaveIfChanged(snapshot) }
            return
        }
        scheduleDebouncedSave()
    }
    
    
    private func scheduleDebouncedSave() {
        let snapshot = categories       // Capture now; UI may keep mutating
        pendingSnapshot = snapshot
        debouncedSaveTask?.cancel()
        debouncedSaveTask = Task { [weak self, snapshot ] in
            guard let self else { return }
            try? await Task.sleep(nanoseconds: saveDebouncedDelayNanos)
            await self.performSaveIfChanged(snapshot)
            await MainActor.run { self.pendingSnapshot = nil }
        }
    }
    
    // Call on scenePhase changes and when leaving History
    func flushPendingSaves() {
        let snapshot = pendingSnapshot
        pendingSnapshot = nil
        debouncedSaveTask?.cancel()
        debouncedSaveTask = nil
        Task { [snapshot] in await performSaveIfChanged(snapshot) } // falls back to/uses live categories if nil
    }
    
    // MARK: - Category CRUD
    func addCategory(persistedInput: String) {
        let newCategory = CategoriesModel(persistedInput: persistedInput)
        categories.append(newCategory)
        normalizeCategoryOrder()
        saveHistory()
    }
    
    /// Adds an empty user category if allowed and returns its id (for autofocus)
    @discardableResult
    func addEmptyUserCategory(limit: Int = 2) -> UUID? {
        guard canAddUserCategory(limit: limit) else { return nil }
        let new = CategoriesModel(persistedInput: "")
        categories.append(new)
        normalizeCategoryOrder()
        saveHistory()
        return new.id
    }
    
    /// Rename category and persist. Validates and coalesces via saveHistory(). IF General is renamed...
    @MainActor
    func renameCategory(id: UUID, to newNameRaw: String) {
        let newName = newNameRaw.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !newName.isEmpty else { return }
        guard let idx = categories.firstIndex(where: { $0.id == id }) else { lastError = HistoryError.categoryNotFound; return }
        
        let renamingGeneral = (id == generalCategoryID)
        categories[idx].persistedInput = newName
        validateCategory(id: id, title: newName)
        
        // If General is renamed, create a new empty "General" and repoint the anchor
        if renamingGeneral && newName != "General" {
            let newGeneral = CategoriesModel(id: UUID(), persistedInput: "General", tiles: [])
            //                      categories.insert(newGeneral, at: 0)         // temp—normalize will place correctly //FIXME: Use *.insert* or *.append*
            categories.append(newGeneral)
            generalCategoryID = newGeneral.id            // didSet also normalizes (see below)
        }
        
        normalizeCategoryOrder()
        saveHistory()
    }
    
    /// Delete a user-defined category. Tiles are moved to Archive first (safe).
    @discardableResult
    func deleteCategory(id: UUID) -> Bool {
        // prevent permanently deleting anchors
        guard id != generalCategoryID, id != archiveCategoryID else { return false }
        guard
            let delIdx = categories.firstIndex(where: { $0.id == id }),
            let archIdx = categories.firstIndex(where: { $0.id == archiveCategoryID })
        else { lastError = HistoryError.categoryNotFound ; return false }
        
        // move tiles to Archive, "top locally" first
        let moving = categories[delIdx].tiles
        if !moving.isEmpty {
            categories[archIdx].tiles.insert(contentsOf: moving, at: 0)
            applyCaps(afterInsertingIn: archIdx)                         // 3) Trims and mirrors to actor
            
            //FIXME: This or
            //               let arch = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
            //               Task { await archiveActor.saveArchivedTiles(arch) }
            
            //FIXME: This? Which acts as we need it to?
        }
        
        categories.remove(at: delIdx)
        normalizeCategoryOrder()
        saveHistory()
        return true
    }
    
    // MARK: - Tiles API
    /// Called by Focus on completion; safe regardless of UI order (uses IDs).
    func addToHistory(_ newTile: TileM, to categoryID: UUID) {
        guard let index = categories.firstIndex(where: {  categoryItem in       // $0.id == categoryID
            categoryItem.id == categoryID
        }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            self.lastError = HistoryError.categoryNotFound
            return
        }
        /// Newest-first for UI display; enforce caps (Archive = 200, General and user-defined=10);
        categories[index].tiles.insert(newTile, at: 0)
        applyCaps(afterInsertingIn: index)
        saveHistory()
        /// If you do want a click here later, trigger it from the view after a successful action using your HapticsService env object, not from the VM
    }
    
    // MARK: valid target to call to move tiles within categories
    // Enforced (yes #2)
    func transferTile(_ tile: TileM, fromCategory sourceID: UUID, toCategory destinationID: UUID) {
        Task {
            do { try await moveTileThrowing(tile, fromCategory: sourceID, toCategory: destinationID) }
            catch { await MainActor.run { self.lastError = error } }
        }
    }
    
    func undoLastMove() {
        guard let move = lastUndoableMove else { return }
        Task {
            do {
                try await moveTileThrowing(move.tile, fromCategory: move.to, toCategory: move.from)
                await MainActor.run { self.lastUndoableMove = nil }
            } catch {
                debugPrint("[HistoryVM.undoLastMove] error: ", error)
                await MainActor.run { self.lastError = error }
            }
        }
    }
    
    /// UI-friendly sugar for cross-category moves that funnels to the canonical thrower.
    /// Keeps call sites readable without duplicating core logic.
    func moveTileBetweenCategories(_ tile: TileM, fromCategory sourceCategoryID: UUID, toCategory destinationCategoryID: UUID) {
        Task {
            do { try await moveTileThrowing(tile, fromCategory: sourceCategoryID, toCategory: destinationCategoryID) }
            catch { await MainActor.run { self.lastError = error } }
        }
    }
    
    // MARK: Wrapper for call-site (RootView) clarity
    /// Reorder tiles within the given category. Validates, re-applies caps, persists.
    // (yes #2)
    func reorderTiles(_ newOrder: [TileM], in categoryID: UUID){
        guard let idx = categories.firstIndex(where: { $0.id == categoryID } ) else { return }
        categories[idx].tiles = newOrder
        applyCaps(afterInsertingIn: idx)
        saveHistory()           // VM decides *when* to persist
    }
    
    //(yes #2)
    /// Replace an entire category’s tiles (e.g., within-category reorder).
    func updateTiles(in categoryID: UUID, to newTiles: [TileM]) {
        guard let index = categories.firstIndex(where: { $0.id == categoryID }) else { return }
        categories[index].tiles = newTiles
        /// does the Archive=200 / General+2=10 trims
        applyCaps(afterInsertingIn: index)
        saveHistory()       /// Persist change
    }
    
    /// If a VC provides a full category order, we still re-assert canonical order afterward.
    func reorderCategories(_ newOrder: [CategoriesModel]) {
        categories = newOrder
        normalizeCategoryOrder()            // General first, Archive last
        saveHistory()
    }
    
    /// Validation function to be called from the view
    // FIXME: Needed?
    func validateCategory(id: UUID, title: String) {
        let messages = title.categoryTitleMessages
        if messages.isEmpty { categoryValidationMessages.removeValue(forKey: id) } else { categoryValidationMessages[id] = messages }
    }
    
    // MARK: Caps & Archive sync
    /// Cap rules for all categories
    private func applyCaps(afterInsertingIn idx: Int) {
        let catID = categories[idx].id
        
        // archive cap: 200 (dropping oldest to bottom)
        if catID == archiveCategoryID {
            let overflow = categories[idx].tiles.count - tileSoftCap    // tileSoftCap == 200
            if overflow > 0 {
                categories[idx].tiles.removeLast(overflow)
                tileLimitWarning = true                             // An FYI for the user
            }
            // Keep ArchiveActor authoritative
            let intoArchive = categories[idx].tiles
            Task { await archiveActor.saveArchivedTiles(intoArchive) }
            return
        }
        
        // build the dynamic "capped@10" set: General + first two user-defined categories
        //    (user-defined = not General, not Archive). Uses current array order.
        let userIDs = categories
            .map(\.id)
            .filter { $0 != generalCategoryID && $0 != archiveCategoryID }
        
        var capped10 = Set<UUID>()
        capped10.insert(generalCategoryID)
        for id in userIDs.prefix(2) { capped10.insert(id) }
        
        if capped10.contains(catID) {
            let overflow = categories[idx].tiles.count - 10
            if overflow > 0 { categories[idx].tiles.removeLast(overflow) }
        }
    }
    
    
    // MARK: Utilities / Convenience
    // User-defined categories (not General/Archive)
    var userCategoryIDs: [UUID] {
        categories
            .map(\.id)
            .filter { $0 != generalCategoryID && $0 != archiveCategoryID }
    }
    
    var userDefinedCategoryCount: Int { userCategoryIDs.count }
    
    func canAddUserCategory(limit: Int = 2) -> Bool {
        userDefinedCategoryCount < limit
    }
    
    // name lookup by ID (safe default)
    func name(for id: UUID) -> String {
        categories.first(where: { $0.id == id })?.persistedInput ?? "Untitled"
    }
    
    // archive helpers
    var hasAnyGeneralTiles: Bool {
        categories.first(where: { $0.id == generalCategoryID })?.tiles.isEmpty == false
    }
    
    // archives newest item from General (quick action)
    //    @MainActor
    func archiveMostRecentFromGeneral() async {
        guard
            let gIdx = categories.firstIndex(where: { $0.id == generalCategoryID }),
            let aIdx = categories.firstIndex(where: { $0.id == archiveCategoryID }),
            let first = categories[gIdx].tiles.first
        else { return }
        
        _ = mutateMove(first, fromCategory: generalCategoryID, toCategory: archiveCategoryID)
        applyCaps(afterInsertingIn: aIdx)
        mirrorArchiveIfInvolved(fromCategory: generalCategoryID, toCategory: archiveCategoryID)
        saveHistory(immediate: true)
        //        } catch { self.lastError = error }
    }
    
    // sets automatic "General" category aka "bootstrapping"
    func ensureGeneralCategory(named name: String = "General") {
        let generalID = generalCategoryID
        if !categories.contains(where: { generalCategoryItem in generalCategoryItem.id == generalID }) {
            let new = CategoriesModel(id: generalID, persistedInput: name)
            categories.append(new)                                                      //FIXME: use `.insert(new, at: 0)` instead?
            //            debugPrint("[HistoryVM.ensureGeneralCategory] error creating 'General'")
            normalizeCategoryOrder()
            saveHistory()
        }
    }
    
    // MARK: - Sets automatic Archive category aka "bootstrapping"
    func ensureArchiveCategory(named name: String = "Archive") {
        let archiveID = archiveCategoryID
        if !categories.contains(where: { archiveCategoryItem in archiveCategoryItem.id == archiveID }) {
            let new = CategoriesModel(id: archiveID, persistedInput: name)
            categories.append(new)                                                  //FIXME: use `.insert(new, at: 0)` instead?
            //            debugPrint("[HistoryVM.ensureArchiveCategory] error creating 'Archive'")
            normalizeCategoryOrder()
            saveHistory()
        }
    }
    
    // RESETS all categories: clears model first; persists a cleared list; clear storage safely: see PersistenceActor
    func clearHistory() {
        categories = []
        saveHistory()
        Task {  await persistence.clear(storageKey); await archiveActor.clearArchive() }
    }
    
    // MARK: - RE: moving tiles; mutation and related (DRY helpers)
    @discardableResult
    private func mutateMove(_ tile: TileM,
                            fromCategory sourceID: UUID,
                            toCategory destinationID: UUID) -> TileM? {
        guard let fromIndex = categoryIndex(for: sourceID),
              let toIndex   = categoryIndex(for: destinationID),
              let tileIndex = categories[fromIndex].tiles.firstIndex(of: tile)
        else { return nil }
        
        let moving = categories[fromIndex].tiles.remove(at: tileIndex)
        categories[toIndex].tiles.insert(moving, at: 0)
        applyCaps(afterInsertingIn: toIndex)
        return moving
    }
    
    // MARK: archive mirrorer when anything is added to it
    private func mirrorArchiveIfInvolved(fromCategory sourceCategoryID: UUID,
                                         toCategory destinationCategoryID: UUID) {
        guard sourceCategoryID == archiveCategoryID || destinationCategoryID == archiveCategoryID else { return }
        let intoArchive = categories.first(where: { $0.id == archiveCategoryID })?.tiles ?? []
        Task { await archiveActor.saveArchivedTiles(intoArchive) }
    }
    
    // MARK: MOVE Undo Window Scheduler that owns timing
    private func startUndoWindow(for tile: TileM,
                                 fromCategory sourceCategoryID: UUID,
                                 toCategory destnationCategoryID: UUID) {
        pendingUndoMove = PendingUndoMove(
            tile: tile,
            fromCategoryID: sourceCategoryID,
            toCategoryID: destnationCategoryID,
            expiresAt: now.addingTimeInterval(TimeInterval(undoWindowSeconds))
        )
        lastUndoableMove = (tile, sourceCategoryID, destnationCategoryID)
        
        undoTickerTask?.cancel()
        undoTickerTask = Task { [weak self] in
            guard let self else { return }
            while self.canUndoCurrentMove() {
                try? await Task.sleep(for: .seconds(0.25))
            }
            await MainActor.run { self.commitPendingUndoIfAny() }
        }
    }
    
    // MARK: Only commits to storage when the window expires (or user leaves History / can no longer undo)
    // Delayed-persist move for non-Archive (undo window)
    func moveTileWithUndoWindow(_ tile: TileM,
                                fromCategory sourceCategoryID: UUID,
                                toCategory destinationCategoryID: UUID) {
        // Non-Archive path only: call sites should route Archive to *moveTileThrowing*
        guard destinationCategoryID != archiveCategoryID else { return }
        guard let moved = mutateMove(
            tile,
            fromCategory: sourceCategoryID,
            toCategory: destinationCategoryID
        ) else {
            lastError = HistoryError.moveFailed
            return
        }
        // Open the undo window (single timing place)
        startUndoWindow(
            for: moved,
                        fromCategory: sourceCategoryID,
                        toCategory: destinationCategoryID)
        // Persist later, don't save: commits on expire / onDisappear / undo invalid
    }
    
    
    // MARK: Immediate move & save (awaits archive mirror if involved). Use for Archive (irreversible).
    // For cross-category moves: IMMEDIATE move and save, awaits ARCHIVE persistence before returning
    func moveTileThrowing(_ tile: TileM,
                          fromCategory sourceID: UUID,
                          toCategory destinationID: UUID) async throws {
        guard let moved = mutateMove(tile,
                                     fromCategory: sourceID,
                                     toCategory: destinationID) else {
            debugPrint("[HistoryVM.moveTileThrowing //core] Category ID not found. Tile not added."); throw HistoryError.moveFailed
        }
        
        // if Archive is involved, mirror the authoritative store
        mirrorArchiveIfInvolved(fromCategory: sourceID, toCategory: destinationID)
        // persist immediately
        saveHistory()
        
        // Only show legacy "lastUndoableMove" if NO archive involved
        if sourceID != archiveCategoryID && destinationID != archiveCategoryID {
            lastUndoableMove = (moved, sourceID, destinationID)
            Task { @MainActor in
                try? await Task.sleep(for: .seconds(3))
                self.lastUndoableMove = nil
            }
        } else {
            // Archive moves are irreversible in UI → ensure no undo affordance lingers
            lastUndoableMove = nil
            clearUndoWindow()
        }
    }
    
    // MARK: - Commit || Undo window
    func commitPendingUndoIfAny() {
        // Delaying move until confirmed
        guard pendingUndoMove != nil else { return }
        // Persist current category state
        saveHistory()
        clearUndoWindow()
    }
    
    func undoPendingMoveIfPossible() {
        guard let anythingPending = pendingUndoMove, canUndoCurrentMove(),
              let toIdx = categoryIndex(for: anythingPending.toCategoryID),
              let fromIdx = categoryIndex(for: anythingPending.fromCategoryID),
              let tileIdx = categories[toIdx].tiles.firstIndex(of: anythingPending.tile)
        else { return }
        
        // revert
        let revertBack = categories[toIdx].tiles.remove(at: tileIdx)
        categories[fromIdx].tiles.insert(revertBack, at: 0)
        applyCaps(afterInsertingIn: fromIdx)
        // persist the reversion immediately (keeps state consistent)
        saveHistory()
        clearUndoWindow()
    }
    
    private func clearUndoWindow() {
        pendingUndoMove = nil
        lastUndoableMove = nil
        undoTickerTask?.cancel()
        undoTickerTask = nil
    }
    
    
    // MARK: - View lifecycle helper
    // Commit any pending move; then flush debounced writes
    func finalizeHistoryIfNeededOnDisappear() {
        commitPendingUndoIfAny()
        flushPendingSaves()
    }
    
    // MARK: - Throwing save (direct)
    func saveHistoryThrowing() async throws {
        try await persistence.write(sanitizedForSave(categories), to: storageKey)
    }
    
    
    // MARK: - Convenience throwers for call sites that want explicit errors
    func addToHistoryThrowing(_ tile: TileM, to categoryID: UUID) async throws {
        guard let index = categories.firstIndex(where: {  categoryItem in categoryItem.id == categoryID }) else {
            debugPrint("HistoryVM.addToHistory] Category ID not found. Tile not added.")
            throw HistoryError.categoryNotFound
        }
        categories[index].tiles.insert(tile, at: 0)
        applyCaps(afterInsertingIn: index)
        saveHistory()
    }
}
-e \n\n
=== ./intention/Features/History/HVM+Computed-userCats-name.swift ===
//
//  HVM+Computed-userCats-name.swift
//  intention
//
//  Created by Benjamin Tryon on 9/19/25.
//

import SwiftUI
import Foundation

extension HistoryVM {

    

}

//
//    var sortedCategories: [CategoriesModel] {
//        categories.sorted { a, b in
//            // non-archive first, Archive always last
//            let aRank = (a.id == archiveCategoryID) ? 1 : 0
//            let bRank = (b.id == archiveCategoryID) ? 1 : 0
//            if aRank != bRank { return aRank < bRank }
//            // Alphabetical by persistedInput
//            return a.persistedInput.localizedCaseInsensitiveCompare(b.persistedInput) == .orderedAscending
//        }
//    }
//}
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationKind.swift ===
//
//  RecalibrationKind.swift
//  intention
//
//  Created by Benjamin Tryon on 9/3/25.
//

import Foundation

enum RecalibrationKind: String, Codable, Hashable {
    case breathing, balancing
}

struct RecalibrationRecord: Codable, Identifiable, Equatable {
    let id: UUID
    let date: Date
    let kind: RecalibrationKind
    let durationSeconds: Int
}
-e \n\n
=== ./intention/Features/Recalibration/BalanceSideDots.swift ===
//
//  BalanceSideDots.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BalanceSideDots: View {
    let activeIndex: Int   // 0 = Left, 1 = Right
    let p: ScreenStylePalette

    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    private let fWOn:  CGFloat = 50
    private let fWOff: CGFloat = 10
    private let fHOn:  CGFloat = 50
    private let fHOff: CGFloat = 10
    
    var body: some View {
        HStack(spacing: 16) {
            dot(label: "Left Foot", isActive: activeIndex == 0)
            dot(label: "Right Foot", isActive: activeIndex == 1)
        }
        .frame(maxWidth: .infinity)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(activeIndex == 0 ? "Left foot" : "Right foot")
    }

    private func dot(label: String, isActive: Bool) -> some View {
        HStack(spacing: 8) {
            Circle()
                .fill(isActive ? p.accent : colorBorder)
                .frame(
                    width: isActive ? fWOn : fWOff,
                    height: isActive ? fHOn : fHOff)
                .overlay(Circle()
                    .stroke(colorBorder, lineWidth: isActive ? 0 : 1)
                )
                .scaleEffect(isActive ? 1.2 : 1.0)
                .animation(
                    .spring(response: 0.20, dampingFraction: 0.85), value: isActive)
            
            Text(label)
                .font(.callout.weight(isActive ? .semibold : .regular))
                .foregroundStyle(isActive ? p.text : textSecondary)
        }
        .padding(.horizontal, 10)
               .padding(.vertical, 6)
               .background(
                   RoundedRectangle(cornerRadius: 999)
                       .fill(isActive ? p.accent.opacity(0.12) : Color.clear)
               )
               .overlay(
                   RoundedRectangle(cornerRadius: 999)
                       .stroke(isActive ? p.accent : colorBorder,
                               lineWidth: isActive ? 1.5 : 1.0)
               )
               .animation(.spring(response: 0.25, dampingFraction: 0.85),
                          value: isActive)
           }
       }


#if DEBUG
#Preview("Balance Dots") {
    let theme = ThemeManager()
    let pal = theme.palette(for: .recalibrate)
    
    BalanceSideDots(
        activeIndex: 0, p: pal
    )
        .environmentObject(theme)
}
#endif
-e \n\n
=== ./intention/Features/Recalibration/BreathingPhaseGuide.swift ===
//
//  BreathingPhaseGuide.swift
//  intention
//
//  Created by Benjamin Tryon on 9/14/25.
//

import SwiftUI

struct BreathingPhaseGuide: View {
    @EnvironmentObject var theme: ThemeManager
    
    let phases: [String]
    let activeIndex: Int
    let p: ScreenStylePalette
    
    // --- Local Color Definitions by way of Recalibration ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    
    var body: some View {
        HStack(spacing: 10) {
            ForEach(phases.indices, id: \.self) { i in
                VStack(spacing: 4){
                Text(phases[i])
                    .font(.footnote.weight(i == activeIndex ? .semibold : .regular))
                    .padding(.horizontal, 10).padding(.vertical, 6)
                    .background(
                        Capsule().fill(i == activeIndex ? p.accent.opacity(0.90) : .clear)
                    )
                    .overlay(
                        Capsule().stroke(i == activeIndex ? colorBorder : .clear, lineWidth: 1)
                    )
                    .foregroundStyle(i == activeIndex ? p.text : textSecondary)
                    .scaleEffect(i == activeIndex ? 1.5 : 1.0)
                    .animation(.spring(response: 0.22, dampingFraction: 0.85), value: activeIndex)
                
                // MARK: Active phase dot
                Circle()
                    .fill(i == activeIndex ? p.accent : .clear)
                    .frame(width: 6, height: 6)
                    .opacity(i == activeIndex ? 1 : 0)
                    .animation(.easeInOut(duration: 0.2), value: activeIndex)
            }
                    .accessibilityLabel("\(phases[i])\(i == activeIndex ? ", current" : "")")
            }
        }
        .frame(maxWidth: .infinity)
        .padding(10)
        // thin accent border around the whole guide
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(p.accent.opacity(0.85), lineWidth: 1.5)
        )
        .padding(.horizontal, 2)
    }
}


#if DEBUG
#Preview("Breathing Guide") {
    let theme = ThemeManager()
    let pal = theme.palette(for: .recalibrate)
    
    BreathingPhaseGuide(
        phases: ["Inhale", "Hold", "Exhale", "Hold"],
        activeIndex: 0,
        p: pal
    )
    .environmentObject(theme)
}
#endif
-e \n\n
=== ./intention/Features/Recalibration/RecalibrateV.swift ===
//
//  RecalibrateV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import SwiftUI

struct RecalibrationV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var vm: RecalibrationVM
    @State private var insetHeight: CGFloat = 72        // height of sticky bar
    @State private var breathingChoice: Int = 2
    @State private var balancingChoice: Int = 2
    @State private var isBusy = false
    
    // Tunable presets users expect: quick, obvious, one tap.
    private let breathePreset = 60   // 1 min
    private let balancePreset = 60   // 1 min
    
    private let screen: ScreenName = .recalibrate
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    private let recColor = Color(red: 0.96, green: 0.96, blue: 0.96) // #F5F5F5
    
    // MARK: Computed helpers
    private var PresetPicker: some View {
        HStack(spacing: 8) {
            // theme drives contract, don't need .foregroundStyle
            T("Length of Time", .caption)
            Picker("", selection: $breathingChoice) {
                Text("2m").tag(2); Text("3m").tag(3); Text("4m").tag(4)
            }
            .pickerStyle(.segmented)
        }
        .onChange(of: breathingChoice) { new in
            do { try vm.setBreathingMinutes(new) } catch { vm.lastError = error }
        }
    }
    
    private var PresetPickerBal: some View {
        HStack(spacing: 8) {
            Toggle(isOn: $vm.eyesClosedMode) {
                T("Expert Mode: Eyes-closed", .caption)
            }
            .toggleStyle(.automatic)
        }
        .onChange(of: balancingChoice) { new in
            do { try vm.setBalancingMinutes(new) } catch { vm.lastError = error }
        }
    }
    
    var body: some View {
        ZStack {
            // True gradient if available
            BackplateGradient(p: p)
            
        VStack {
            ScrollView {
                Page {
                    // MARK: H1 centered; prose
                    /*left-aligned = calmer eye path*/
                    T("Reset & Recalibrate", .largeTitle)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding(.top, 24)
                    
                    // -- separator --
                    VStack(spacing: 2) {
                        Rectangle()
                            .fill(recColor)
                            .frame(height: 2)
                            .shadow(radius: 2, y: 1)
                        // ↑ was 4
                        // .padding(.vertical, 8)
                        Rectangle()
                            .fill(recColor)
                            .frame(height: 2)
                            .shadow(radius: 2, y: 1)
                        // ↑ was 4
//                            .padding(.vertical, 4)
                    }
                    
                    // MARK: Supporting copy
                    /* left-aligned, subdued */
                    T("These short physical resets relax and reinvigorate your focus.", .title3)
                        .foregroundStyle(textSecondary)
                        // a bit below the separator
//                        .padding(.top, 1)
                    
                    // -- separator --
                    Rectangle()
                        .fill(p.accent)
                        .frame(height: 2)
                        // was 4, ↑ a touch
                        .padding(.vertical, 4)
                        .shadow(radius: 2, y: 1)
                    
                    Spacer()
                    // MARK: Action block
                    T("Choose one below:", .title3)
                        .foregroundStyle(textSecondary)
                        // a bit below the separator
                        .padding(.top, 28)
                    
                    // the ONLY CTA/timer block
                    actionArea
                        .padding(.top, 16)
                    
                    // MARK: Guidance
                    if vm.phase == .none || vm.phase == .idle, let theMode = vm.mode {
                        InstructionList( items: theMode.instructions, p: p, theme: theme )
                            .padding(.top, 12)
                    }
                    
                    // MARK: Live indicators
                    // Balancing - “Switch feet” flashes briefly each minute
                    // Breathing - modes and expanding dot
                    if vm.mode == .balancing {
                        BalanceSideDots(activeIndex: vm.balancingPhaseIndex, p: p)
                                .padding(.top, 12)
                    } else if vm.mode == .breathing, vm.phase != .none, vm.phase != .idle {
                        BreathingPhaseGuide(
                            phases: vm.breathingPhases,
                            activeIndex: vm.breathingPhaseIndex,
                            p: p
                        )
                        .padding(.top, 10)
                    }
                }
                // Room for sticky inset + it never covers buttons/picker
                .padding(.bottom, insetHeight + 16)
                .padding(.horizontal, 16)
            }
        }
    }
        //.background(p.background.ignoresSafeArea())
        .tint(p.accent)
        // instant task, OK for previews
        .task { breathingChoice = vm.currentBreathingMinutes }
        .presentationDragIndicator(.visible)
        // Fill-height sheet so users don’t have to expand it first
        .presentationDetents([.large])
        // Sticky bottom chrome
//        .safeAreaInset(edge: .bottom, spacing: 0) {
//            BottomInset
//                .background(.ultraThinMaterial)
//                .readHeight($insetHeight)   // helper below to measure height
//        }
        // MARK: error overlay
        .overlay {
            if let err = vm.lastError {
                ErrorOverlay(error: err) { vm.lastError = nil }
            }
        }
        // MARK: Let people leave
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                Button { dismiss() } label: {
                    Image(systemName: "xmark").imageScale(.small).font(.headline).controlSize(.large)
                }
                .buttonStyle(.plain)
                .accessibilityLabel("Close")
            }
        }
    }
    
    @ViewBuilder
    private var actionArea: some View {
        switch vm.phase {
        case .none, .idle:
            VStack(spacing: 12) {
                if vm.phase == .none || vm.phase == .idle { PresetPicker }   // 2m / 3m / 4m
                Button {
                    vm.performAsyncAction { try await vm.start(mode: .breathing) }
                } label: { T("Breathing", .action) }
                    .recalibrationActionStyle(screen: screen)
                
                Divider()
                if vm.phase == .none || vm.phase == .idle { PresetPickerBal }
                Button {
                    vm.performAsyncAction { try await vm.start(mode: .balancing) }
                } label: { T("Balancing", .action) }
                    .recalibrationActionStyle(screen: screen)
            }
            
        case .running, .pause:
            VStack(spacing: 8) {
                T(vm.mode == .breathing ? "Breathing" : "Balancing", .section)
                    .frame(maxWidth: .infinity, alignment: .center)
                
                Text(vm.formattedTime)
                    .font(.system(size: 56, weight: .semibold, design: .rounded))
                    .monospacedDigit()
                    .frame(maxWidth: .infinity, alignment: .center)
                
                Button(role: .destructive) {
                    vm.performAsyncAction { try await vm.stop() }
                } label: { T("Cancel", .action)
                        .recalibrationActionStyle(screen: screen)
                }
            }
        case .finished:
            EmptyView()
        }
    }
}
    // MARK: - Computed Helpers
    private struct InstructionList: View {
        let items: [String]
        let p: ScreenStylePalette
        let theme: ThemeManager
        var body: some View {
            VStack(alignment: .leading, spacing: 4) {
                ForEach(items, id: \.self) { Text("• \($0)") }
            }
            .font(theme.fontTheme.toFont(.footnote))
            .foregroundStyle(p.text)
        }
    }
    private struct HeightReader: View {
        var onChange: (CGFloat) -> Void
        var body: some View {
            GeometryReader { proxy in
                Color.clear
                    .preference(key: HeightKey.self, value: proxy.size.height)
            }
        }
    }
    private struct HeightKey: PreferenceKey {
        static var defaultValue: CGFloat = 0
        static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) { value = nextValue() }
    }

    private extension View {
        func readHeight(_ binding: Binding<CGFloat>) -> some View {
            background(HeightReader { binding.wrappedValue = $0 })
                .onPreferenceChange(HeightKey.self) { binding.wrappedValue = $0 }
        }
    }

#if DEBUG
#Preview("Recalibrate (dumb)") {
    let theme = ThemeManager()
    let vm    = RecalibrationVM(haptics: NoopHapticsClient())

    RecalibrationV(vm: vm)
        .environmentObject(theme)
    /* read ONLY if/when everything else is stable */
    /// .canvasCheap()
        .frame(maxWidth: 430)
}
#endif
-e \n\n
=== ./intention/Features/Recalibration/RecalibrationType.swift ===
//
//  RecalibrationMode.swift
//  intention
//
//  Created by Benjamin Tryon on 7/22/25.
//

import SwiftUI

// Authoritiative model - Operation + duration, View can request preset cleanly
/// Role-only; Durations live in the VM's config

enum RecalibrationMode: String, Hashable, Codable, CaseIterable {
    case balancing
    case breathing
    
    var label: String {
        switch self {
        case .balancing: return "Balancing Reset"
        case .breathing: return "Breathing Reset"
        }
    }
    
    var iconName: String {
        switch self {
        case .balancing: return "figure.stand"
        case .breathing: return "lungs.fill"
        }
    }
    
        var instructions: [String] {
            switch self {
            case .balancing:
                /// 4 minutes, switch every minute
                return [
                    "Stand on one foot.",
                    "Switch feet, every minute",
                    "Level up: close eyes and repeat."
                ]
            case .breathing:
                /// 6-3, 6-3
                return [
                    "Inhale 6 sec, hold 3 sec.",
                    "Exhale 6 sec, hold 3 sec.",
                    "Repeat until timer ends."
                ]
            }
        }
}

-e \n\n
=== ./intention/Features/Recalibration/RecalibrationVM.swift ===
//
//  RecalibrationVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/14/25.
//

import Foundation

enum RecalibrationError: LocalizedError {
    case invalidBreathingMinutes, cannotChangeWhileRunning
    var errorDescription: String? {
        switch self {
        case .invalidBreathingMinutes:   return "Breathing must be 2–4 minutes."
        case .cannotChangeWhileRunning:  return "You can’t change duration while a session is running."
        }
    }
}

/// One entry point: start(mode:)
/// VM decides duration + cadence (no durations in the View).
/// Haptics are triggered from VM only (View stays quiet).
/// Swift-6 friendly captures; cancel on deinit.

/* Why MainActor.run at all if RecalibrationVM is @MainActor? */

/// VM is @MainActor, but loop work runs in a Task on a background executor.
/// We touch @Published state only inside MainActor.run { ... } blocks.

@MainActor
final class RecalibrationVM: ObservableObject {
    enum Phase { case none, idle, running, finished, pause }
    
    @Published private(set) var phase: Phase = .none
    @Published private(set) var mode: RecalibrationMode?
//    @Published private(set) var startedAt: Date?    // part of "snapshotting" the wall-clock to recompute remaining time on re-activation
    @Published private(set) var timeRemaining: Int = 0
    @Published var lastError: Error?
    @Published var breathingPhaseIndex: Int = 0     // 0:Inhale, 1:Hold, 2:Exhale, 3:Hold
    @Published var promptText: String = ""          // “Switch feet” pulses EMOM
    @Published var eyesClosedMode: Bool = false     // UI toggles this before start()
    @Published var balancingPhaseIndex: Int = 0
    
    var formattedTime: String {
        TimeString.mmss(timeRemaining)
    }
    
    // Counts
    var onCompleted: ((RecalibrationMode) -> Void)?
    
    // VMs current default on present
    var currentBreathingMinutes: Int { breathingMinutes }
    var currentBalancingMinutes: Int { balancingMinutes }
    
    // Prompts
    let breathingPhases = ["Inhale", "Hold", "Exhale", "Hold"]
    var breathingPhaseLine: String { breathingPhases.joined(separator: " . ") }
    
    // Policy knobs (VM decides "when")
    private var breathingMinutes: Int
    private var balancingMinutes: Int
    private let inhale = 6, hold1 = 3, exhale = 6, hold2 = 3

    private let haptics: HapticsClient
    private var task: Task<Void, Never>?
    @Published private(set) var didHaptic: Set<Int> = []
    
    // Related to time the user backgrounded/spent time outside the app
    private var recalDeadline: Date?
//    private var intendedDuration: Int = 0       // seconds (for .current mode)


    init(haptics: HapticsClient, breathingMinutes: Int = 2, balancingMinutes: Int = 4) {
        self.haptics = haptics
        self.breathingMinutes = min(4, max(2, breathingMinutes))
        self.balancingMinutes = min(4, max(1, balancingMinutes))
    }

    deinit { task?.cancel() }
    
    // MARK: Core API (async throws; View calls these)
    // When starting (not resuming when re-activated after leaving, see `appDidBecomeActive()`):
    func start(mode: RecalibrationMode) async throws {
        cancel()
        self.mode = mode
        self.phase = .running
        
        let mins = (mode == .breathing ? breathingMinutes : balancingMinutes)
        let seconds = mins * 60
        
        self.timeRemaining = seconds
        self.recalDeadline = Date().addingTimeInterval(TimeInterval(seconds))
        
        // Reset phase indices and prompt on each start
        self.promptText = ""
        self.breathingPhaseIndex = 0
        self.balancingPhaseIndex = 0
        
        
        switch mode {
        case .balancing: runBalancing()
        case .breathing: runBreathing()
        }
    }
    
    func stop() async throws {
        cancel()
        phase = .idle
        mode = nil
        promptText = ""
    }

    private func cancel() {
        task?.cancel()
        task = nil
        recalDeadline = nil
    }
    
    func setBreathingMinutes(_ minutes: Int) throws {
        guard (2...4).contains(minutes) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        breathingMinutes = minutes
    }
    
    func setBalancingMinutes(_ mins: Int) throws {
        guard (1...4).contains(mins) else { throw RecalibrationError.invalidBreathingMinutes }
        guard phase != .running else { throw RecalibrationError.cannotChangeWhileRunning }
        balancingMinutes = mins
    }
    
    
    func appWillResignActive() { /* no-op; wall clock handles it */}
    
    // Resuming when re-activated after leaving, see `start(mode:)`
    // is called un RootView when scene becomes active:
    func appDidBecomeActive() {
        guard phase == .running, let returned = recalDeadline else { return }
        let remain = max(0, Int(returned.timeIntervalSinceNow))         // "clamps": UI never shows -00:01
        
        if remain != timeRemaining { timeRemaining = remain }
        if remain == 0 {
            // finish immediately
            phase = .finished
            let finished = mode
            mode = nil
            promptText = ""
            if let m = finished { onCompleted?(m) }
            fireHapticsNotifyDone()
        }
    }
    
    // Pattern to call haptic once per completion
//    private func fireDoneHapticOnce() {
//        guard !didHapticForChunk.contains(currentSessionChunk) else { return }
//        didHapticForChunk.insert(currentSessionChunk)
//        haptics.notifyDone()
//    }
    private func fireHapticsNotifyDone() { haptics.notifyDone() }
    
    
    // MARK: Balancing - short-short every min; long-long-short on done
    // MARK: Balancing - short cues every minute; long–long–short on done
    private func runBalancing() {
        // Capture the starting time so we can compute elapsed minutes.
        let totalAtStart = timeRemaining

        task = Task { [weak self] in
            guard let self else { return }

            // Tracks which minute we’ve already fired a cue for.
            // -1 means “none yet”.
            var lastMinuteCued: Int = -1

            while true {
                // Snapshot remaining time on the main actor.
                let remaining = await MainActor.run { self.timeRemaining }

                // Exit if cancelled or time has fully elapsed.
                if Task.isCancelled || remaining <= 0 {
                    break
                }

                // Compute how many seconds have elapsed since start.
                let elapsed       = totalAtStart - remaining
                let currentMinute = elapsed / 60   // 0, 1, 2, ...

                // Fire cue ON the minute, but:
                // - only once per minute
                // - never on minute 0 (skip start)
                if currentMinute > 0 && currentMinute != lastMinuteCued {
                    lastMinuteCued = currentMinute

                    await MainActor.run {
                        // Alternate which “side” is active (0 ↔ 1).
                        self.balancingPhaseIndex = currentMinute % 2

                        // Tactile bump, bump, bump when it’s time to switch.
                        self.haptics.added()
                        self.haptics.added()
                        self.haptics.added()
                        // No promptText now – BalanceSideDots does the visual work.
                    }

                    #if !os(watchOS)
                    // Let the user feel/see the cue for a moment before the next tick.
                    try? await Task.sleep(for: .seconds(0.8))
                    #endif
                }

                // Tick every second, counting down.
                try? await Task.sleep(for: .seconds(1))

                await MainActor.run {
                    // Clamp to 0 so the UI never shows -00:01.
                    self.timeRemaining = max(0, self.timeRemaining - 1)
                }
            }

            // If cancelled at any point, don't run "finished" logic.
            guard !Task.isCancelled else { return }

            // Finish + notify exactly once, on the main actor.
            await MainActor.run {
                self.fireHapticsNotifyDone()          // long–long–short
                self.phase = .finished
                let finishedMode = self.mode
                self.mode = nil
                self.promptText = ""
                if let m = finishedMode {
                    self.onCompleted?(m)
                }
            }
        }
    }


    // MARK: Breathing — 6/3/6/3, tiny cue each phase
    private func runBreathing() {
        
        let phases: [(idx: Int, secs: Int)] = [
            (0, inhale),
            (1, hold1),
            (2, exhale),
            (3, hold2)
        ]
        
        // Show one line “Inhale · Hold · Exhale · Hold” and move a subtle dot via breathingPhaseIndex
        task = Task { [weak self] in
            guard let self else { return }
            
            while true {
                let remaining = await MainActor.run { self.timeRemaining }
                if Task.isCancelled || remaining <= 0 {
                    break
                }
                
                for (idx, secs) in phases {
                    // set active phase index on the main actor
                    await MainActor.run {
                        // NOTE: No big label per phase; UI uses breathingPhaseLine + index to draw the dot
                        self.breathingPhaseIndex = idx
                    }
                    
                    for _ in 0..<secs {
                        let remainingInner = await MainActor.run { self.timeRemaining }
                        if Task.isCancelled || remainingInner <= 0 { break }
                        
                        try? await Task.sleep(for: .seconds(1))
                        
                        await MainActor.run {
                            self.timeRemaining = max(0, self.timeRemaining - 1)
                        }
                    }
                    
                    if Task.isCancelled { return }
                    
                    let afterPhaseRemaining = await MainActor.run { self.timeRemaining }
                    if afterPhaseRemaining <= 0 {
                        break
                    }
                    
                    await MainActor.run {
                        // phase boundary cue
                        self.haptics.added(); self.haptics.added(); self.haptics.added()
                    }
                }
            }
            
            guard !Task.isCancelled else { return }
            
            // all the “we’re finished” work in a single block
            await MainActor.run {
                self.fireHapticsNotifyDone()
                self.phase = .finished
                let finishedMode = self.mode
                self.mode = nil
                self.promptText = ""
                if let m = finishedMode { self.onCompleted?(m) }
            }
//            
//            let seq: [(idx: Int, secs: Int)] = [(0, inhale), (1, hold1), (2, exhale), (3, hold2)]
//            while self.timeRemaining > 0 && !Task.isCancelled {
//                for (idx, secs) in seq {
////                    await MainActor.run {
//                        self.breathingPhaseIndex = idx
//                        
////                    }
//                    for _ in 0..<secs {
//                        guard !Task.isCancelled else { return }
//                        try? await Task.sleep(for: .seconds(1))
////                        await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }
//                        self.timeRemaining = max(0, self.timeRemaining - 1) // "clamps": UI never shows -00:01
//                        if self.timeRemaining == 0 { break }
//                    }
//                    if self.timeRemaining == 0 { break }
//                    haptics.added()             // tiny cue at phase boundaries
//                }
//            }
//            guard !Task.isCancelled else { return }
//            haptics.notifyDone()                // long–long–short
////            await MainActor.run {
//                self.phase = .finished
//                let finished = self.mode
//                self.mode = nil
//                self.promptText = ""
//                if let m = finished { self.onCompleted?(m) }
////            }
            
        }
    }

       private func phaseBlock(label: String, seconds: Int) async {
           haptics.added()                          // single short cue at each phase start
           for _ in 0..<seconds {
               guard !Task.isCancelled else { return }
               try? await Task.sleep(for: .seconds(1))
               await MainActor.run { self.timeRemaining = max(0, self.timeRemaining - 1) }  // "clamps": UI never shows -00:01
           }
       }
    
    func performAsyncAction(_ action: @escaping () async throws -> Void) {
        Task {
            do {
                try await action()
            } catch {
                debugPrint("[FocusSessionVM.performAsyncAction] error:", error)
                self.lastError = error
            }
        }
    }
}

#if DEBUG
@MainActor
extension RecalibrationVM {
    /// Debug-only setters; returning Self enables fluent build-up in previews.
    @discardableResult func _debugSetPhase(_ p: Phase) -> Self { self.phase = p; return self }
    @discardableResult func _debugSetMode(_ m: RecalibrationMode?) -> Self { self.mode = m; return self }

    /// Canonical preview factory: shows a running breathing session with a visible countdown.
    static func mockForDebug() -> RecalibrationVM {
        let vm = RecalibrationVM(
            haptics: NoopHapticsClient(),
            breathingMinutes: 1,
            balancingMinutes: 1
        )
        vm._debugSetMode(.breathing)
          ._debugSetPhase(.running)
        vm.timeRemaining = 17 // 1:30 gives a nice visual
        return vm
    }
}
#endif
-e \n\n
=== ./intention/Features/Stats/StatsVM.swift ===
//
//  StatsVM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/30/25.
//

import Foundation
import SwiftUI

enum StatsError: Error, Equatable, LocalizedError {
    case calculationFailed
    
    var errorDescription: String? {
        switch self {
        case .calculationFailed: return "Calculation failed."
        }
    }
}

@MainActor
final class StatsVM: ObservableObject {
    @Published private(set) var averageCompletionRate: Double = 1.0
    @Published private(set) var totalCompletedIntentions: Int = 0
    @Published private(set) var recalibrationCounts: [RecalibrationMode: Int] = [:] // what?
    @Published private(set) var lastRecalibrationChoice: RecalibrationMode?
    @Published private(set) var streak: Int = 0
    @Published private(set) var longestStreak: Int = 0
    @Published var shouldPromptForMembership: Bool = false  // is good flag
    @Published var lastError: Error?
    
    private let persistence: any Persistence
    private let storageKey = "completedSessions"
    private let membershipThreshold = 2
    private var completedSessions: [CompletedSession] = []
    
    weak var memVM: MembershipVM?
    
    init(persistence: any Persistence) {
        self.persistence = persistence
        Task {  await loadSessions()    }
    }
    
    func logSession(_ session: CompletedSession) {
        completedSessions.append(session)
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        memVM?.triggerPromptIfNeeded(afterSessions: completedSessions.count)
        
        /// if user did recalibrate (picked breathing or balancing), type will be non-nil, and count incremented
        if let type = session.recalibration {
            recalibrationCounts[type, default: 0] += 1
            lastRecalibrationChoice = type
        }
        
        recalculateStats()
        
        /// Updates to trigger membership prompt ($0.99 then $5.99 for 3 months?)
        /// Keeps onboarding friction at zero: the user never types anything.
        if completedSessions.count == membershipThreshold {
            shouldPromptForMembership = true    // Observe in the RootView and present as alert/sheet
        }
        
        Task {
            do {
                try await persistence.write(completedSessions, to: storageKey)
            } catch {
                debugPrint("[StatsVM.logSession persistence.saveHistory] error:", error)
                await MainActor.run { self.lastError = error }
            }
        }
    }
    
    private func loadSessions() async {
        do {
            if let loaded: [CompletedSession] = try await persistence.readIfExists([CompletedSession].self, from: storageKey) {
                completedSessions = loaded
                recalculateStats()
            }
        } catch {
            debugPrint("[StatsVM.loadSessions] from PersistenceActor: ", error)
            await MainActor.run { self.lastError = error }
        }
    }
    private func recalculateStats() {
        // Update intention count
        totalCompletedIntentions = completedSessions.flatMap(\.tileTexts).count
        let intendedTiles = completedSessions.count * 2
        /// Update average completion rate
        averageCompletionRate = intendedTiles == 0 ? 1.0 : Double(totalCompletedIntentions) / Double(intendedTiles)
        
        /// Update recalibration counts - counts and “last choice” are always correct after app relaunch
        var newCounts: [RecalibrationMode: Int] = [:]
        var last: RecalibrationMode?
        for sesh in completedSessions {
            if let t = sesh.recalibration {
                newCounts[t, default: 0] += 1
                last = t
            }
        }
        recalibrationCounts = newCounts
        lastRecalibrationChoice = last
        
        updateRunStreak()
    }
    
    private func updateRunStreak() {
        let calendar = Calendar.current
        let daysWithSessions = Set(completedSessions.map {
            calendar.startOfDay(for: $0.date)
        })
        let sortedDays = daysWithSessions.sorted(by: >) // descending: [today, yesterday, ...]
        
        // If empty, no streak, otherwise start/continue Current Streak
        guard !sortedDays.isEmpty else {
            streak = 0
            longestStreak = 0
//            tilesCompletedThisWeek = 0
            return
            }
        
        // Run streak (most recent backward)
        var maxStreak = 1
        var currentStreak = 1
        var isTrackingCurrent = true
        for i in 1..<sortedDays.count {
            let diff = calendar.dateComponents([.day], from: sortedDays[i], to: sortedDays[i - 1]).day ?? 0
            if diff == 1 {
                currentStreak += 1
                if isTrackingCurrent { streak = currentStreak }
                maxStreak = max(maxStreak, currentStreak)
            } else {
                isTrackingCurrent = false
                currentStreak = 1
            }
        }
        // If all dates are consecutive, streak isn't updated in the loop
        if isTrackingCurrent { streak = currentStreak }
        longestStreak = maxStreak
    }
    
    // MARK: Helpers + Throwing Core
    
    /// Throwing core (async throws): use when the caller wants to decide how to handle the error
    
    func logSessionThrowing( _ s: CompletedSession) async throws {
        completedSessions.append(s)
        recalculateStats()
        try await persistence.write(completedSessions, to: storageKey)
    }
    
    // Background
    func autosaveStats() {
        //            Task {
        //                do { try await persistence.saveHistory(self, to: "statsData") }
        //                catch {
        //                    debugPrint("[StatsVM.autosaveStats] error:", error)
        //                    self.lastError = error
        //                }
    }
    
    var totalRecalibrations: Int {
        recalibrationCounts.values.reduce(0, +)
    }
}

// MARK: Supporting Types -
// Keeps CompletedSession simple and fully Codable for PersistenceActor
struct CompletedSession: Codable {
    let date: Date
    let tileTexts: [String]
    let recalibration: RecalibrationMode?
}
-e \n\n
=== ./intention/Features/Stats/StatsSummaryBar.swift ===
//
//  StatsSummaryBar.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import SwiftUI

struct StatsSummaryBar: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var vm: StatsVM
    private let screen: ScreenName = .settings
        private var p: ScreenStylePalette { theme.palette(for: screen) }
        private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }

    var body: some View {
        HStack(spacing: 12) {
            StatPill(icon: "flame",
                      value: "\(vm.streak)",
                      caption: "Your Streak",
                      screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns

            StatPill(icon: "checkmark",
                     value: PercentString.whole(vm.averageCompletionRate), // FIXME: value: vm.avgCompletionString, label: "Avg.")
                      caption: "Completion",
                      screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns

            StatPill(icon: (vm.lastRecalibrationChoice?.iconName ?? "arrow.triangle.2.circlepath"),
                     value: "\(vm.totalRecalibrations)",
                     caption: "Recalibrations",
                     screen: .settings)
            .frame(maxWidth: .infinity)         // Not a child -> parent problem: makes equal columns
        }
    }
}
-e \n\n
=== ./intention/Features/Stats/StatPill.swift ===
//
//  StatPill.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct StatPill: View {
    @EnvironmentObject var theme: ThemeManager
    let icon: String
    let value: String
    let caption: String
    let screen: ScreenName
    
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(p.primary)
                .frame(height: 24)
            
            // Top Row: the number (scales, doesn't wrap)
            T(value, .title3)
                .statNumberStyle(p)
                .frame(height: 22)
            T(caption, .caption)
                .statCaptionStyle(p)
                .frame(height: 16)
        }
        .multilineTextAlignment(.center)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(caption) \(value)")
    }
}
-e \n\n
=== ./intention/Features/Membership/redeemOfferCode.swift ===
//
//  redeemOfferCode.swift
//  intention
//
//  Created by Benjamin Tryon on 9/25/25.
//

import Foundation
import StoreKit

@MainActor
func redeemOfferCode() async {
    if let scene = UIApplication.shared.connectedScenes.first as? UIWindowScene {
        try? await AppStore.presentOfferCodeRedeemSheet(in: scene)   // iOS 16+
    }
}
-e \n\n
=== ./intention/Features/Membership/MembershipVM.swift ===
//
//  MembershipVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import SwiftUI
import StoreKit

enum MembershipError: Error, Equatable, LocalizedError {
    case purchaseFailed, restoreFailed, invalidCode, networkError, appEnvironmentFail

    var errorDescription: String? {
        switch self {
        case .purchaseFailed:     return "Purchase could not be completed."
        case .restoreFailed:      return "No purchases to restore."
        case .invalidCode:        return "That code isn’t valid."
        case .networkError:       return "Network error. Please try again."
        case .appEnvironmentFail: return "App environment error."
        }
    }
}

/// pure async/await for purchase/restore paths, one paywall, stable entitlement refresh
/// `isMember` flips only from verified entitlements in PaymentService.refreshEntitlementStatus(), and the VM just mirrors that via updates()
@MainActor
final class MembershipVM: ObservableObject {
    // UI state mirrored from PaymentService
    @Published private(set) var isMember: Bool = false
    @Published var shouldPrompt: Bool = false
    @Published var showCodeEntry: Bool = false
    @Published var primaryProduct: Product?         /// Shows "¢/day • $X.XX"
    @Published var lastError: Error?                /// Used to trigger the UI visual error overlay
    
    let payment: PaymentService             //FIXME: only use the injected instance, and not p let paymentService = PaymentService()?
    private let codeService = MembershipCodeService()
    
    init(payment: PaymentService) {
        self.payment = payment
        // Observe payment service state
        // "Mirror service state" (✅ this is how VM learns membership)
        Task {
            for await state in await payment.updates(){
                self.isMember = state.isMember
                self.primaryProduct = state.products.first
            }
        }
        // Initial configuration
        Task { await payment.configure() }
    }
        
//        paymentService.$isMember
//            .receive(on: RunLoop.main)
//            .assign(to: &$isMember)
//        
//        paymentService.$products
//            .map { $0.first }   // FIXME: not $0, what is 0 made of?
//            .receive(on: RunLoop.main)
//            .assign(to: &$primaryProduct)
//    }

    func buy() async {
        do {
            let paid = try await payment.purchaseMembership()
            if !paid { await payment.refreshEntitlementStatus() }
        } catch {
            lastError = error
        }
    }
    
    /// Trigger helper to reopen form anywhere (starts in RootView, can be in a banner, Settings, locked feature)
    @MainActor func presentPaywall() { shouldPrompt = true }

    func restore() async {
        do {
            try await payment.restorePurchases()
            if !isMember { lastError = MembershipError.restoreFailed }
        } catch {
            lastError = error
        }
    }

    // Public UI API (never sets isMember directly)
    func purchaseMembershipOrPrompt() async throws {
        let before = isMember
        do {
            let paid = try await payment.purchaseMembership()
            await payment.refreshEntitlementStatus()
            shouldPrompt = !(paid || isMember)
            if !(paid || isMember) { throw MembershipError.purchaseFailed }
        } catch {
            shouldPrompt = !before
            lastError = error
            throw error
        }
    }
    
    func restoreMembershipOrPrompt() async throws {
        do {
            try await payment.restorePurchases()
            shouldPrompt = !isMember
            if !isMember { throw MembershipError.restoreFailed }
            } catch {
                let err = MembershipError.restoreFailed; setError(err); throw err
        }
    }
    
    @MainActor
    func verifyCode(_ code: String) async throws {
        let deviceID = UIDevice.current.identifierForVendor?.uuidString ?? "unknown"
        let result = await codeService.verify(code: code, deviceID: deviceID)
        switch result {
        case .success:
            // Treat as an unlocked entitlement
            isMember = true
            shouldPrompt = false
            showCodeEntry = false
        case .invalid:
            let err = MembershipError.invalidCode; setError(err); throw err
        case .networkError:
            let err = MembershipError.networkError; setError(err); throw err
        }
    }
    
    func triggerPromptIfNeeded(afterSessions sessionCount: Int, threshold: Int = 2) {
        if !isMember && sessionCount >= threshold { shouldPrompt = true }
    }
    
    func setError(_ error: Error?) { lastError = error }
    
    func perDayBlurb(for product: Product) -> String {
        guard let sub = product.subscription else { return "" }
        // Very rough: 30-day month, 365-day year. It’s just a blurb.
        let days: Decimal
        switch sub.subscriptionPeriod.unit {
        case .month: days = 30
        case .year:  days = 365
        case .week:  days = 7
        case .day:   days = 1
        @unknown default: days = 30
        }
        // Product.price is Decimal in StoreKit 2.
        let daily = (product.price / days) as NSDecimalNumber
        let cents = (daily.multiplying(by: 100)).doubleValue.rounded()
        return "about \(Int(cents))¢/day"
    }
    
    var showSheetBinding: Binding<Bool> {
        Binding(
            get: { self.shouldPrompt },
            set: { newVal in self.shouldPrompt = newVal  }
            // ^ aka, self.shouldPrompt = $0
        )
    }
    
    #if DEBUG
    // Preview/testing hook to flip membership without touching StoreKit
    // because this method is inside the type, it can write to the private(set) property
    func _debugSetIsMember(_ value: Bool) { self.isMember = value }
    #endif
}
-e \n\n
=== ./intention/Shared/Haptics/AppPreferencesVM.swift ===
//
//  AppPreferencesVM.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import SwiftUI

/// The delivery mechanism: inject a HapticsService from RootView (no singletons), @MainActor, warmed generators, safe everywhere
@MainActor
final class AppPreferencesVM: ObservableObject {
    @AppStorage("hapticsOnly") var hapticsOnly: Bool = true  /// default ON
    @AppStorage("showSwatches") var showSwatches: Bool = false
    @AppStorage("soundEnabled") var soundEnabled: Bool = false 
    
    /// optional: add more later ( reduceAnimations, etc.)
}
-e \n\n
=== ./intention/Shared/Haptics/LiveHapticsClient.swift ===
//
//  LiveHapticsClient.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import Foundation
import UIKit

@MainActor
final class HapticsService: ObservableObject {
    private let light   = UIImpactFeedbackGenerator(style: .light)
    private let impact  = UIImpactFeedbackGenerator(style: .medium)
    private let heavy   = UIImpactFeedbackGenerator(style: .heavy)
    private let notify  = UINotificationFeedbackGenerator()
    
    init() { prepareGenerators() }
    
    /// Pre-warms the generators; safe to call often
    func warm() { prepareGenerators() }
    private func prepareGenerators() {
        light.prepare(); impact.prepare(); heavy.prepare(); notify.prepare()
    }
    
    func added() { impact.impactOccurred(intensity: 0.8) }
    func warn() { notify.notificationOccurred(.warning) }
    func notifyDone() {
        heavy.impactOccurred()                      // 1st heavy
        
        Task {
            let longerPause: UInt64 = 200_000_000   // 200 million nanoseconds - 200 milisecdons
            let shortPause: UInt64 = 90_000_000     // 90 million nanoseconds - 90 milisecdons
            // wait; second heavy
            try? await Task.sleep(nanoseconds: longerPause); heavy.impactOccurred()
            // wait; third heavy
            try? await Task.sleep(nanoseconds: shortPause); heavy.impactOccurred()
            // wait; last heavy
            try? await Task.sleep(nanoseconds: shortPause); heavy.impactOccurred()
        }
        notify.notificationOccurred(.success)
    }
}
/// Gates haptics; VMs only talk to this protocol
@MainActor
protocol HapticsClient {
    func added()
    func warn()
    func notifyDone()
}

/// No-op (for tests or to disable globally)
struct NoopHapticsClient: HapticsClient {
    func added() {}
    func warn() {}
    func notifyDone() {}
}

/// Live client that checks prefs.hapticsOnly and calls the engine
 @MainActor
struct LiveHapticsClient: HapticsClient {
    let prefs: AppPreferencesVM
    let engine: HapticsService
    private var enabled: Bool { prefs.hapticsOnly }

    func added()    { guard enabled else { return }; engine.added() }
    func warn()     { guard enabled else { return }; engine.warn() }
    func notifyDone() { guard enabled else { return }; engine.notifyDone() }
}
-e \n\n
=== ./intention/Shared/HelperLayout+Effects/PulseAura.swift ===
//
//  PulseAura.swift
//  intention
//
//  Created by Benjamin Tryon on 11/3/25.
//

import SwiftUI

/// its own animation driver (TimelineView(.animation)), so the view stays “how,” not “when.”
struct PulseAura: ViewModifier {
    let color: Color
    let isActive: Bool
    
    /// 1.4s “breathing” period to match the design note
    private let period: TimeInterval = 1.4
    //    @State private var thisPulses = 0.0     // formerly t
    
    func body(content: Content) -> some View {
        ZStack {
            if isActive {
                TimelineView(.animation) { ctx in
                    // Smooth, preview-safe time source
                    let t = ctx.date.timeIntervalSinceReferenceDate
                    let phase = sin((2 * .pi / period) * t)  // -1...+1
                    Circle()
                        .fill(color.opacity(0.18))
                        .scaleEffect(1.0 + 0.03 * CGFloat(1 + phase)) // ~3% “breath”
                        .blur(radius: 12)
                        .frame(height: 54)
                    //                                       .animation(.easeInOut(duration: 1.4).repeatForever(autoreverses: true), value: thisPulses)
                    //                                       .onAppear { t = .pi / 2 }
                        .transition(.opacity)
                        .accessibilityHidden(true)
                }
            }
            content
        }
    }
}

extension View {
    func pulseAura(color: Color, active: Bool) -> some View {
        modifier(PulseAura(color: color, isActive: active))
    }
}
// MARK: - Minimal Demo Views (for Previews only)

private struct PulseButtonDemo: View {
    @EnvironmentObject var theme: ThemeManager
    @State private var isActive = true
    
    var body: some View {
        let p = theme.palette(for: .focus)
        
        VStack(spacing: 16) {
            Button("Pulse Aura") { /* no-op */ }
                .frame(maxWidth: .infinity, minHeight: 48)
                .pulseAura(color: p.accent, active: isActive)
                .buttonStyle(.plain) // you’ll likely use your PrimaryActionStyle elsewhere
            
            Toggle("Active", isOn: $isActive)
                .toggleStyle(.switch)
        }
        .padding(20)
        .background(p.background.ignoresSafeArea())
    }
}

// MARK: - Previews
#Preview("Always Active") {
    let theme = ThemeManager()
    
    Button("Pulse Aura") { }
        .frame(maxWidth: .infinity, minHeight: 48)
        .pulseAura(color: theme.palette(for: .focus).accent, active: true)
        .padding(20)
        .background(theme.palette(for: .focus).background)
        .environmentObject(theme)
}

#Preview("Interactive Toggle") {
    let theme = ThemeManager()
    
    PulseButtonDemo()
        .environmentObject(theme)
}
-e \n\n
=== ./intention/Shared/HelperLayout+Effects/Layout+Helpers.swift ===
//
//  Layout+Helpers.swift
//  intention
//
//  Created by Benjamin Tryon on 8/27/25.
//

import SwiftUI
/// Only the Page applies horizontal padding. Children don’t.
/// Add to any top-level screen container (ScrollView or VStack)
struct Page<Content: View>: View {
    let top: CGFloat
    let alignment: HorizontalAlignment
    let content: () -> Content
    init(top: CGFloat = 8,
         alignment: HorizontalAlignment = .leading,
         @ViewBuilder _ content: @escaping () -> Content) {
        self.top = top; self.alignment = alignment; self.content = content
    }
    var body: some View {
        /// One horizontal margin to rule them all
        VStack(alignment: alignment, spacing: 16, content: content)
            .padding(.horizontal, 16)
            .padding(.top, 8)                       /// Small top; adjust per screen
            .frame(maxWidth: .infinity, alignment: .leading)
    }
}

/// Card section with consistent look for Settings, History blocks
struct Card<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        VStack(alignment: .leading, spacing: 16, content: content)
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
    }
}

/// Bottom toast that clears tab bar safely on all devices
struct BottomToast<Content: View>: View {
    let content: () -> Content
    init(@ViewBuilder _ content: @escaping () -> Content) { self.content = content }
    var body: some View {
        content()
            .padding(12)
            .background(.ultraThinMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
            .shadow(radius: 2, y: 1)
    }
}

struct TileCell: View {
    let tile: TileM
    
    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(tile.text).font(.callout)
        }
        .padding(12)
//        .background(RoundedRectangle(cornerRadius: 12).fill(.ultraThinMaterial))
    }
}
-e \n\n
=== ./intention/Shared/Dev+TestFlight/BuildInfo.swift ===
//
//  BuildInfo.swift
//  intention
//
//  Created by Benjamin Tryon on 12/2/25.

import Foundation

enum BuildInfo {
    static var isDebug: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    /// TestFlight builds have a sandbox receipt
    static var isTestFlight: Bool {
        Bundle.main.appStoreReceiptURL?.lastPathComponent == "sandboxReceipt"
    }
    static var isDebugOrTestFlight: Bool { isDebug || isTestFlight }
}

-e \n\n
=== ./intention/Shared/Resources/Bundle+AppIcon.swift ===
//
//  AppIcon.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI
import UIKit

extension Bundle {
    var appIconFileName: String? {
        guard let icons = infoDictionary?["CFBundleIcons"] as? [String: Any],
              let primaryIcon = icons["CFBundlePrimaryIcon"] as? [String: Any],
              let iconFiles = primaryIcon["CFBundleIconFiles"] as? [String],
              let iconFileName = iconFiles.last
        else { return nil }
        return iconFileName
    }
    
    // Convenience key/computed property to load the app icon (as a UIImage)
    var appIcon: UIImage? {
        guard let appIconFileName = appIconFileName else { return nil }
        return UIImage(named: appIconFileName)      // already GETS and returns the image... do NOT need map
    }
//    don't need the flatMap and map chain in the View's body because the intermediate optional states are already handled by your appIcon computed property
}
-e \n\n
=== ./intention/Shared/Resources/PillSandbox.swift ===
//
//  PillSandbox.swift
//  intention
//
//  Created by Benjamin Tryon on 10/2/25.
//

import SwiftUI

struct PillSandbox: View {
    var body: some View {
        HStack(spacing: 16){
//            StatPill
        }
    }
}

#Preview {
    PillSandbox()
        
}
-e \n\n
=== ./intention/Shared/Resources/BackplateGradient.swift ===
//
//  BackplateGradient.swift
//  intention
//
//  Created by Benjamin Tryon on 11/19/25.
//
import SwiftUI

struct BackplateGradient: View {
    // drives tiny animation of liveliness
    @State private var tinydrift: CGFloat = 0
    let p: ScreenStylePalette
    
    var body: some View {
        // vertical drive amound ~2%
        let offset = 0.02 * sin(tinydrift)
        
        Group {
            if let g = p.gradientBackground {
                LinearGradient(colors: g.colors,
                               startPoint: UnitPoint(x: g.start.x, y: g.start.y + offset),
                               endPoint: UnitPoint(x: g.end.x, y: g.end.y + offset)
                )
            } else {
                p.background
            }
        }
        .ignoresSafeArea()
        .task {
            // maintain static previews
            guard !IS_PREVIEW else { return }
            
            // 30s cycle - very long frequency/time frame
            // auto-cancelled when view disappears
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: 200_000_000)     // 0.2s tick
                withAnimation(.linear(duration: 0.2)) { tinydrift += 0.04 }
            }
        }
        .accessibilityHidden(true)
    }
}
-e \n\n
=== ./intention/Shared/Time/ContinuousClockActor.swift ===
//
//  ContinuousClockActor.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import Foundation

// VM = “when” (state machine + orchestration + UI/session snapshot), Actor = “how” (monotonic time with ContinuousClock, tick loop, background math, tiny safety snapshot
// session's start time and the tiles that have been added within that session context
// Owns ContinuousClock, tick loop, background/foreground math.
// Supports user pause/resume vs. app background suspend/resume.
// Provides an auxiliary safety snapshot.
actor ContinuousClockActor {
    /// Short debug/UI tests without touching production logic
    // MARK: init
    private let config: TimerConfig
    init(config: TimerConfig) { self.config = config }
    
    // MARK: session state Convenience
    private(set) var sessionStartDate: Date?
    // -- delete currenttiles if no error --
//    private(set) var currentTiles: [TileM] = []     // NOTE: adding = [] dismisses 'has no initializers'
    
    // MARK: Ticking
    private let clock = ContinuousClock()
    // Ticking stops on *backgrounding*, but endInstant keeps track without pausing
    private var tickingTask: Task<Void, Never>?
    // Time keeps elapsing from this
    private var endInstant: ContinuousClock.Instant?
    // Used for *user* paused, not app backgrounding
    private var pausedRemaining: Int?
    
    
    /// Starts a new session window; clears actor's tile buffer.
    // MARK: Session lifecycle (called by VM)
    func startSessionTracking() {
        guard !IS_PREVIEW else { return }
        sessionStartDate = Date()
        // -- delete currenttiles if no error --
        // currentTiles = []           /// Clear tiles for new session
        pausedRemaining = nil
    }
    
    // -- delete this addTile and currenttiles if no error: VM controls --
//    /// Append a tile; returns false if limit (2) already reached.
//    func addTile(_ tile: TileM) -> Bool {
//        guard currentTiles.count < 2 else { return false }
//        currentTiles.append(tile)
//        return true
//    }
    
    func shouldCheckIn() -> Bool {
        guard let start = sessionStartDate else { return false }
        return Date().timeIntervalSince(start) >= Double(config.chunkDuration)      /// Should be 1200 - don't hardcode
    }
    
    func resetSessionTracking() {
        sessionStartDate = nil
        // -- delete currenttiles if no error --
//        currentTiles = []
        cancelTicking()
        endInstant = nil
        pausedRemaining = nil
    }
    
    // MARK: - Ticking control
    func startTicking(
        totalSeconds: Int? = nil,
        onTick: @Sendable @escaping (Int) -> Void,
        onFinish: @Sendable @escaping () -> Void
    ) async {
        guard !IS_PREVIEW else { return }
        cancelTicking()
        
        let total = max(0, totalSeconds ?? config.chunkDuration) // "clamps": UI never shows -00:01
        endInstant = clock.now.advanced(by: .seconds(total))
        
        
        // run the loop on the actor via a private actor-isolated function (tickLoop), the Task only calls into that function
        tickingTask = Task { [weak self] in
            guard let self else { return }
            await self.tickLoop(onTick: onTick, onFinish: onFinish)
        }
    }
    
    // User-initiated pause (unchanged semantics): freezes remaining and clears end
    func pauseTicking(currentRemaining: Int) {
        pausedRemaining = max(0, currentRemaining)      // "clamps": UI never shows -00:01
        cancelTicking()
        endInstant = nil                    // true pause: time stops
    }
    
    // Resume from user pause (unchanged time keeping)
    func resumeTicking(
        onTick:     @Sendable @escaping (Int) -> Void,
        onFinish:   @Sendable @escaping () -> Void
    ) async {
        guard !IS_PREVIEW else { return }
        let resumeFrom = pausedRemaining ?? secondsRemaining() ?? config.chunkDuration
        pausedRemaining = nil
        await startTicking(totalSeconds: resumeFrom, onTick: onTick, onFinish: onFinish)
    }
    
    func suspendForBackground(){
        // App background: stop work but KEEP endInstant so wall time keeps elapsing.
        // endInstant remains set; the key difference vs a user pause
        cancelTicking()
    }
    
    // Foreground: compute remaining using endInstant and, either finish or  return nil
    func remainingAfterForeground() async -> Int? {
        guard let end = endInstant else { return pausedRemaining }
        // let now = clock.now
        // return max(0, Int(ceil(end.duration(to: now).magnitude.seconds)))
        return remainingSeconds(to: end)
    }
    
    func secondsRemaining() -> Int? {
        guard let end = endInstant else { return pausedRemaining }
        return remainingSeconds(to: end)
    }
    
    // MARK: actor-isolated tickLoop
    private func tickLoop(
        onTick:     @Sendable (Int) -> Void,
        onFinish:   @Sendable () -> Void
    ) async {
        // a guard against any bug in 'secs' that misreads to count upwards and now a countdown
        var lastEmitted = -1
        while !Task.isCancelled {
            // Sleep to the next second boundary
            guard let end = endInstant else { break }
            let secs = remainingSeconds(to: end)
            if secs != lastEmitted {
                lastEmitted = secs
                onTick(secs)
            }
            if secs == 0 { break }
            try? await clock.sleep(for: .seconds(1))
        }
        if !Task.isCancelled { onFinish() }
    }
    
    // Use this helper anywhere you derive remaining time so it’s consistent and non-negative
    private func remainingSeconds(to end: ContinuousClock.Instant) -> Int {
        let dur = clock.now.duration(to: end)                   // positive if end in the future
        let secs = Int(ceil(Double(dur.components.seconds)))    // ignore attoseconds; 1 Hz UI
        return max(0, secs)                                     // "clamps": UI never shows -00:01
    }
    
    private func cancelTicking(){
        tickingTask?.cancel()
        tickingTask = nil
    }
    
    // MARK: Auxiliary safety snapshot
    //    Why: App background suspends your task, not wall-clock time. Keeping endInstant lets you recompute exactly how much time passed while the app was away.
    // Optional: still keep snapshot if you like; not strictly required if endInstant persists in memory.
    struct Snapshot: Codable, Sendable {
        let sessionStartEpoch: TimeInterval
        let remainingSeconds: Int
        let capturedAtEpoch: TimeInterval
    }
    
    func makeSnapshot() -> Snapshot? {
        guard let start = sessionStartDate else { return nil }
        let remaining = (secondsRemaining()) ?? config.chunkDuration
        return Snapshot(
            sessionStartEpoch: start.timeIntervalSince1970,
            remainingSeconds: remaining,
            capturedAtEpoch: Date().timeIntervalSince1970
        )
    }
    
    func restoreFromSafetySnapshot(_ snap: Snapshot) {
        sessionStartDate = Date(timeIntervalSince1970: snap.sessionStartEpoch)
        pausedRemaining = snap.remainingSeconds
        endInstant = nil
        cancelTicking()
    }
}
-e \n\n
=== ./intention/Shared/Utilities/friendlyAnimatedHelper.swift ===
//
//  friendlyAnimatedHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 8/23/25.
//

import SwiftUI

extension View {
    /// Mark as a rotor-friendly heading
    func friendlyHelper() -> some View { self.accessibilityAddTraits(.isHeader) }

    /// Gate animations for motion sensitivity
    func friendlyAnimatedHelper(_ value: AnyHashable, animation: Animation = .easeInOut) -> some View {
        modifier(AnimatedIfAllowed(value: value, animation: animation))
    }
}

private struct AnimatedIfAllowed<V: Hashable>: ViewModifier {
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    let value: V
    let animation: Animation
    func body(content: Content) -> some View {
        content.animation(reduceMotion ? nil : animation, value: value)
    }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig.swift ===
//
//  TimerConfig.swift
//  intention
//
//  Created by Benjamin Tryon on 8/7/25.
//

import SwiftUI
import Foundation

/// Single source of truth for all durations
/// In UI tests, pass a launch argument to flip to short timers
struct TimerConfig: Sendable {
    // MARK: Focus/session
    let chunkDuration: Int          /// 20-min chunks (1200)
    
    // MARK: Haptics policy
    struct Haptics: Sendable {
        let endCountdownStart: Int       // 3s
        let halfwayTick: Bool
        let balanceSwapInterval: Int     // 60s
    }
    let haptics: Haptics
    
    // sensible default haptics
    init(chunkDuration: Int,
         haptics: Haptics = .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 60)) {
        self.chunkDuration = chunkDuration
        self.haptics = haptics
    }

    static let prod = TimerConfig(chunkDuration: 20 * 60)
    static let shortDebug = TimerConfig(chunkDuration: 10,
                                        haptics: .init(endCountdownStart: 3, halfwayTick: true, balanceSwapInterval: 5))

    static var current: TimerConfig {
        #if DEBUG
        let override = UserDefaults.standard.integer(forKey: "debug.chunkSeconds")
        return TimerConfig(chunkDuration: override > 0 ? override : 20 * 60)
        #else
        return TimerConfig(chunkDuration: 20 * 60)
        #endif
    }
}
-e \n\n
=== ./intention/Shared/Utilities/TimerConfig+UITest.swift ===
//
//  TimerConfig+UITest.swift
//  intention
//
//  Created by Benjamin Tryon on 9/8/25.
//

//import Foundation
//
//extension TimerConfig {
//    static let fastUITest = TimerConfig(
//    chunkDuration: 3,
//        haptics: .init(endCountdownStart: 1, halfwayTick: false, balanceSwapInterval: 1)
//    )
//}
-e \n\n
=== ./intention/Shared/Components/UnwindingPie.swift ===
//
//  UnwindingPie.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI

struct UnwindingPieShape: Shape {
    var progress: Double        // from 0.0 to 1.0
    
    var animatableData: Double {
        get { progress }
        set { progress = newValue }
    }
    
    func path(in rect: CGRect) -> Path {
        var path = Path()
        
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2
        let startAngle = -90.0
        let endAngle = startAngle - (progress * 360)

        path.move(to: center)
        path.addArc(
            center: center,
            radius: radius,
            startAngle: .degrees(startAngle),
            endAngle: .degrees(endAngle),
            clockwise: true
        )
        path.closeSubpath()

        return path
    }
}

//struct Pie: View {
//    @EnvironmentObject var theme: ThemeManager
//    @State private var remainingTime = 60.0
//    let totalTime: TimeInterval = 60.0
//    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
//    
//    var body: some View {
//        let palette = theme.palette(for: .focus)
//        ZStack {
//            Circle()
//                .fill(palette.background.opacity(0.2))
//            
//            UnwindingPieShape(progress: remainingTime / totalTime)
//                .fill(palette.accent)
//            
//        }
//        .frame(width: 400, height: 300)
//        .onReceive(timer) { _ in
//            if remainingTime > 0 {
//                remainingTime -= 1
//            }}
//    }
//}
//
//#if DEBUG
//#Preview {
//    Pie()
//        
//}
//#endif
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/BuildEnv.swift ===
////
////  BuildEnv.swift
////  intention
////
////  Created by Benjamin Tryon on 10/31/25.
////
//
//import Foundation
//
//enum BuildEnv {
//    static var isPreview: Bool {
//        ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PREVIEWS"] == "1"
//    }
//}
-e \n\n
=== ./intention/Shared/Mocks+PreviewsDebug/DebugPreviewFlags.swift ===
//
//  DebugPreviewFlags.swift
//  intention
//
//  Created by Benjamin Tryon on 11/1/25.

import SwiftUI
import Foundation

@inline(__always)
var IS_PREVIEW: Bool {
    #if DEBUG
    return ProcessInfo.processInfo.environment["XCODE_RUNNING_FOR_PLAYGROUNDS"] != nil
    #else
    return false
    #endif
}

/// Wrap any async/side-effect call you never want to run in Canvas.
@inline(__always)
func previewGuard(_ work: () -> Void) {
    if !IS_PREVIEW { work() }
}

extension View {
    /// Disable animations + transitions in Canvas (avoids AG graph thrash).
    func canvasCheap() -> some View {
        self
            .transaction { t in
                t.disablesAnimations = true
                t.animation = nil
            }
    }
}
-e \n\n
=== ./intention/Shared/Legal/LegalConfig.swift ===
//
//  LegalConfig.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI
import UIKit

// MARK: - File config (do NOT include .md)
/// Gate logic checks acceptedVersion < currentVersion. After you ship an update with currentVersion = 2, any user who previously accepted version 1 will see the legal sheet again on next launch.
enum LegalConfig {
    static let currentVersion = 1               // "bumping" this (1 to 2 to 3)
    static let termsFile   = "termsmarkdown"
    static let privacyFile = "privacymarkdown"
    static let medicalFile = "medicalmarkdown"
}
-e \n\n
=== ./intention/Shared/Legal/LegalAgreementSheetV.swift ===
//
//  LegalAgreementSheetV.swift
//  intention
//
//  Created by Benjamin Tryon on 9/4/25.
//

import SwiftUI

struct LegalAgreementSheetV: View {
    @EnvironmentObject private var theme: ThemeManager

    let onAccept: () -> Void
    let onShowTerms: () -> Void
    let onShowPrivacy: () -> Void
    var onShowMedical: (() -> Void)?   // optional extra link
    
    // --- Local Color Definitions for Legal ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    /// Theme hooks
    private let screen: ScreenName = .focus
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        NavigationStack {
            ZStack {
            p.background.ignoresSafeArea()
                
            VStack(spacing: 14){
                T("Please review the policies below. By tapping **Agree & Continue**, you accept them.", .body)
                //                .lineLimit()
                
                // Links row
                HStack(alignment: .center, spacing: 10) {
                    Button { onShowTerms()
                    } label: { T("Terms", .label).underline() }
                        .buttonStyle(.plain).underline()
                    
                    T("•", .secondary).foregroundStyle(.tertiary)
                    
                    Button{ onShowPrivacy()
                    } label: { T("Privacy Policy", .label).underline() }
                        .buttonStyle(.plain)
                }
                //                .font(.subheadline)
                
                if let onShowMedical {
                    Button { onShowMedical()
                    } label: {T("Wellness Disclaimer", .label).underline() }
                        .buttonStyle(.plain)
                }
            }
                Spacer(minLength: 0)
                .frame(maxWidth: 520)
            }
            .frame(maxWidth: 520)
            .navigationTitle("Legal")
            .navigationBarTitleDisplayMode(.inline)
            .interactiveDismissDisabled(true)
            // Full-screen style
            .presentationDetents([.large])
            .safeAreaInset(edge: .bottom){
                // Sticky, always-visible CTA area
                VStack(spacing: 8){
                    Button("Agree & Continue", action: onAccept)
                        .buttonStyle(.borderedProminent)
                        .tint(p.accent)
                        .controlSize(.large)

                    T("You can review these anytime in **Settings › Legal**.", .caption)
                }
                .padding(.horizontal, 16)
                .padding(.top, 10)
                .padding(.bottom, 16)
                .background(.ultraThinMaterial)
            }
            
        }
    }
}

#if DEBUG
#Preview("Legal Sheet (dumb)") {
    let theme = ThemeManager()

    LegalAgreementSheetV(
        onAccept: {},
        onShowTerms: {},
        onShowPrivacy: {}
    )
    .environmentObject(theme)
    .frame(maxWidth: 430)
}
#endif
-e \n\n
=== ./intention/Shared/Legal/SimpleMarkdownView.swift ===
//
//  SimpleMarkdownView.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

/// Renders a very simple "paragraphs only" view from Markdown input.
/// - Strips markdown formatting (headers, lists, emphasis, code ticks, links),
///   collapses blank lines, and shows paragraphs with uniform spacing.
struct SimpleMarkdownView: View {
    let markdown: String
    
    // Layout “dials”
    var h1Font: Font = .title.weight(.semibold)
    var h2Font: Font = .title2.weight(.semibold)
    var h3Font: Font = .headline
    var bodyFont: Font = .body
    
    var h1Top: CGFloat = 4, h1Bottom: CGFloat = 8
    var h2Top: CGFloat = 12,h2Bottom: CGFloat = 6
    var h3Top: CGFloat = 10, h3Bottom: CGFloat = 4
    var paragraphSpacing: CGFloat = 10
    var horizontalPadding: CGFloat = 20
    var verticalPadding: CGFloat = 24
    
    private var blocks: [Block] { Self.parse(markdown: markdown) }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            ForEach(blocks.indices, id:\.self) { i in
                let block = blocks[i]
                switch block {
                case .h1(let t):
                    Text(t)
                        .font(h1Font)
                        .padding(.top, h1Top)
                        .padding(.bottom, h1Bottom)
                case .h2(let t):
                    Text(t)
                        .font(h2Font)
                        .padding(.top, h2Top)
                        .padding(.bottom, h2Bottom)
                case .h3(let t):
                    Text(t)
                        .font(h3Font)
                        .padding(.top, h3Top)
                        .padding(.bottom, h3Bottom)
                case .p(let p):
                    Text(p)
                        .font(bodyFont)
                        .padding(.bottom, paragraphSpacing)
                }
            }
        }
        .padding(.horizontal, horizontalPadding)
        .padding(.vertical, verticalPadding)
    }
}

// MARK: - Parser
extension SimpleMarkdownView {
    enum Block { case h1(String), h2(String), h3(String), p(String) }

    static func parse(markdown: String) -> [Block] {
        // Normalize endings and strip BOM
        var s = markdown
            .replacingOccurrences(of: "\r\n", with: "\n")
            .replacingOccurrences(of: "\r", with: "\n")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        if s.hasPrefix("\u{FEFF}") { s.removeFirst() }

        // Build blocks
        var blocks: [Block] = []
        var paragraphBuffer: [String] = []

        func flushParagraph() {
            guard !paragraphBuffer.isEmpty else { return }
            let text = paragraphBuffer.joined(separator: " ").trimmingCharacters(in: .whitespacesAndNewlines)
            if !text.isEmpty { blocks.append(.p( stripInline(text) )) }
            paragraphBuffer.removeAll()
        }

        for rawLine in s.split(separator: "\n", omittingEmptySubsequences: false) {
            let line = String(rawLine).trimmingCharacters(in: .whitespaces)

            if line.isEmpty { flushParagraph();continue }

            // Headings only when the line *starts* with hashes
            if let h = headingText(line, level: 1) {
                flushParagraph()
                blocks.append(.h1( stripInline(h) ))
                continue
            }
            if let h = headingText(line, level: 2) {
                flushParagraph()
                blocks.append(.h2( stripInline(h) ))
                continue
            }
            if let h = headingText(line, level: 3) {
                flushParagraph()
                blocks.append(.h3( stripInline(h) ))
                continue
            }

            // Otherwise accumulate paragraph
            paragraphBuffer.append(line)
        }

        flushParagraph()
        return blocks
    }

    /// If line starts with `# ` (repeated `level` times), return text after the marker; else nil.
    private static func headingText(_ line: String, level: Int) -> String? {
        let prefix = String(repeating: "#", count: level) + " "
        return line.hasPrefix(prefix)
            ? String(line.dropFirst(prefix.count)).trimmingCharacters(in: .whitespaces)
        : nil
        }

    /// Strip simple inline markdown: **bold**, __bold__, *em*, _em_, `code`, and [text](url) → text
    private static func stripInline(_ s: String) -> String {
        var out = s
        // Links: [text](url) -> text  (manual pass to avoid $1 issues)
        out = stripLinks(out)
        // Remove paired markers by just deleting the markers
        let markers = ["**", "__", "*", "_", "`"]
        for m in markers {
            out = out.replacingOccurrences(of: m, with: "")
        }
        // Collapse internal extra spaces
        while out.contains("  ") { out = out.replacingOccurrences(of: "  ", with: " ") }
        return out.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    /// Very small link stripper: replaces `[label](...)` with `label`
    private static func stripLinks(_ s: String) -> String {
        var result = ""
        var i = s.startIndex
        while i < s.endIndex {
            if s[i] == "[",
               // closeBracket, closeParen
                let closeBracket = s[i...].firstIndex(of: "]"),
               closeBracket < s.index(before: s.endIndex),
                   s[s.index(after: closeBracket)] == "(",
                   let closeParen = s[s.index(after: closeBracket)...].firstIndex(of: ")"){
                    // Append label only
                    let label = s[s.index(after: i)..<closeBracket]
                    result.append(contentsOf: label)
                    i = s.index(after: closeParen)
                    continue
                }
            result.append(s[i])
            i = s.index(after: i)
        }
        return result
    }
}
-e \n\n
=== ./intention/Shared/Legal/LegalDocV.swift ===
//
//  LegalDocV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: Reusable Markdown screen
struct LegalDocV: View {
//    @EnvironmentObject var theme: ThemeManager
    
    let title: String
    let markdown: String
    // Restricted to value, no OO or EO, lets the sheet control it
    let palette: ScreenStylePalette
    
    /// Theme hooks
//    private let screen: ScreenName = .focus
//    private var p: ScreenStylePalette { theme.palette(for: screen) }
//    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        ScrollView {
            SimpleMarkdownView(markdown: markdown)
                .frame(maxWidth: 700)
                .foregroundStyle(palette.text)
        }
//        .background(p.background.ignoresSafeArea())
        .background(palette.background.ignoresSafeArea())
        .navigationTitle(title)
        .navigationBarTitleDisplayMode(.inline)
        .toolbarBackground(.visible, for: .navigationBar)
        .scrollIndicators(.hidden)
    }
}
-e \n\n
=== ./intention/Shared/Legal/LegalKeys.swift ===
//
//  LegalKeys.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: - Persisted acceptance state
struct LegalKeys {
    static let acceptedVersion = "legal.acceptedVersion"
    static let acceptedAtEpoch = "legal.acceptedAtEpoch"
}

enum LegalConsent {
    static func needsConsent(currentVersion: Int = LegalConfig.currentVersion) -> Bool {
        UserDefaults.standard.integer(forKey: LegalKeys.acceptedVersion) < currentVersion
    }
    static func recordAcceptance(currentVersion: Int = LegalConfig.currentVersion) {
        UserDefaults.standard.set(currentVersion, forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.set(Date().timeIntervalSince1970, forKey: LegalKeys.acceptedAtEpoch)
    }
    /// DEBUG: clear all acceptance so the sheet will show again
    static func clearForDebug() {
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedVersion)
        UserDefaults.standard.removeObject(forKey: LegalKeys.acceptedAtEpoch)
    }
}
-e \n\n
=== ./intention/Shared/Legal/MarkdownLoader.swift ===
//
//  MarkdownLoader.swift
//  intention
//
//  Created by Benjamin Tryon on 10/22/25.
//

import SwiftUI

// MARK: - Markdown loader (accepts base name; always reads .md from bundle)
enum MarkdownLoader {
    /// Loads a Markdown file from the app bundle by base name.
    /// - Parameter name: The file base name, with or without the `.md` suffix.
    /// - Returns: The normalized Markdown text, or an empty string if not found.
    static func load(named name: String) -> String {
        let trimmed = name.trimmingCharacters(in: .whitespacesAndNewlines)
        let base = trimmed.lowercased().hasSuffix(".md") ? String(trimmed.dropLast(3)) : trimmed
        
        // Try locating "<base>.md" in the main bundle
        guard let url = Bundle.main.url(forResource: base, withExtension: "md") else {
            print("⚠️ MarkdownLoader: Missing \(base).md in the main bundle.")
            return ""
        }
        
        do {
            var text = try String(contentsOf: url, encoding: .utf8)
            // normalize endings + strip leading BOM in case an editor added it
            if text.hasPrefix("\u{FEFF}") { text.removeFirst() }
            text = text.replacingOccurrences(of: "\r\n", with: "\n")
                .replacingOccurrences(of: "\r", with: "\n")
            return text
        } catch {
            print("⚠️ MarkdownLoader: Failed to read \(base).md - \(error)")
            return ""
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/DragPayload.swift ===
//
//  DragPayload.swift
//  intention
//
//  Created by Benjamin Tryon on 9/20/25.
//

import Foundation
import UniformTypeIdentifiers
import SwiftUI

struct DragPayload: Codable, Hashable, Transferable {
    let tile: TileM
    let sourceCategoryID: UUID

    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .data)
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CategoryTileList.swift ===
//
//  CategoryTileList.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//

import SwiftUI
import UniformTypeIdentifiers

// Rows only -> movement handled by VM via `.dropDestination`
struct CategoryTileList: View {
    @Binding var category: CategoriesModel
    @EnvironmentObject var viewModel: HistoryVM
    @EnvironmentObject var theme: ThemeManager
    @Environment(\.editMode) private var editMode
    
    // per-row expansion under a tile when you tap Move in the right-swipe
    @State private var expandedMoveRowID: UUID?   // which tile shows the move bar
    @State private var confirmArchiveFor: (tile: TileM, sourceID: UUID)?
    @State private var confirmDeleteFor:  (tile: TileM, sourceID: UUID)?
    
    let isArchive: Bool
    
    /// Theme hooks
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let dividerRects = Color(red: 0.878, green: 0.847, blue: 0.796)
    
    // MARK: - Computed helpers
    private var isEmpty: Bool {
        category.tiles.isEmpty
    }
    
    /// All possible move destinations (excluding the current category)
    private var destinationCategories: [CategoriesModel] {
        viewModel.categories.filter { $0.id != category.id }
    }
    
    private func isLast(_ tile: TileM) -> Bool {
        tile.id == category.tiles.last?.id
    }
    
    private func isArchiveCategory(_ id: UUID) -> Bool {
        id == viewModel.archiveCategoryID
    }
    
    private func isExpanded(for tile: TileM) -> Bool {
        expandedMoveRowID == tile.id
    }
    
    private func toggleMoveBar(for tile: TileM) {
        withAnimation {
            expandedMoveRowID = (expandedMoveRowID == tile.id ? nil : tile.id)
        }
    }
    
    private var archiveAlertBinding: Binding<Bool> {
        Binding(
            get: { confirmArchiveFor != nil },
            set: { if !$0 { confirmArchiveFor = nil }}
        )
    }
    
    private var deleteAlertBinding: Binding<Bool> {
        Binding(
            get: { confirmDeleteFor != nil },
            set: { if !$0 { confirmDeleteFor = nil }}
        )
    }
    
    // MARK: - Body
    var body: some View {
        Group {
            if isEmpty {
                emptyState
            } else {
                tilesLazyStack
            }
        }
        .alert(
            "Permanently archive?",
            isPresented: archiveAlertBinding,
            actions: archiveAlertActions,
            message: archiveAlertMessage
        )
        .alert("Delete this tile?",
               isPresented: deleteAlertBinding,
               actions: deleteAlertActions,
               message: deleteAlertMessage
        )
    }
    
    // MARK: - Subviews
    
    private var emptyState: some View {
        T(isArchive ? "No archived items yet." : "Completed", .caption)
            .foregroundStyle(textSecondary)
            .frame(maxWidth: .infinity, alignment: .leading)
            .padding(10)
            .background(p.background, in: RoundedRectangle(cornerRadius: 8, style: .continuous))
    }
    
    // MARK: tiles stack
    private var tilesLazyStack: some View {
        LazyVStack(spacing: 12) {
            ForEach(category.tiles, id: \.id) { tile in
                VStack(spacing: 0) {
                    tileRow(for: tile)
                    
                    if isExpanded(for: tile) {
                        MoveChipRow(
                            tile: tile,
                            sourceCategoryID: category.id,
                            isArchiveList: isArchive,
                            onArchiveConfirm: { tileToArchive, sourceID in
                                confirmArchiveFor = (tileToArchive, sourceID)
                            },
                            onMovedNonArchive: {
                                withAnimation { expandedMoveRowID = nil }
                            }
                        )
                        .environmentObject(theme)
                        .environmentObject(viewModel)
                    }
                    
                    if !isLast(tile) {
                        separator
                    }
                }
            }
        }
        // dropDestination applied to the LazyVStack
        .dropDestination(for: DragPayload.self) { items, _ in
            guard let payload = items.first else { return false }
            // from == category.id lets the organizer or per-category reorder handle it
            guard payload.sourceCategoryID != category.id else { return false }
            
            Task {
                if category.id == viewModel.archiveCategoryID {
                    // archive path: immediate persist through thrower
                    do {
                        try await viewModel.moveTileThrowing(
                            payload.tile,
                            fromCategory: payload.sourceCategoryID,
                            toCategory: category.id
                        )
                    } catch {
                        viewModel.lastError = error;
                        debugPrint("[CategoryTileList] dropDestination failed")
                    }
                } else {
                    // non-archive path: dalayed persist + a window of undo-ness
                    await MainActor.run {
                        viewModel.moveTileWithUndoWindow(
                            payload.tile,
                            fromCategory: payload.sourceCategoryID,
                            toCategory: category.id
                        )
                    }
                }
            }
            return true
        }
    }
    
    // MARK: - tile rows + separator
    private func tileRow(for tile: TileM) -> some View {
        HStack(alignment: .firstTextBaseline) {
            T(tile.text, .tile)
                .foregroundStyle(p.text)
                .multilineTextAlignment(.leading)
            
            Spacer()
            
        }
        .padding(10)
        .background(p.surfaces, in: RoundedRectangle(cornerRadius: 8, style: .continuous))
        .draggable(DragPayload(tile: tile, sourceCategoryID: category.id))
        // swipe right - opens Move bar
        .swipeActions(edge: .leading, allowsFullSwipe: false) {
            moveSwipeButtons(for: tile)
        }
        // swipe left - Delete || Archive
        .swipeActions(edge: .trailing, allowsFullSwipe: !isArchive) {
            destructiveSwipeButtons(for: tile)
        }
    }
    
    private var separator: some View {
        Rectangle()
        // light tan between tiles
            .fill(dividerRects)
            .frame(height: 1)
            .padding(.leading, 6)
            .padding(.trailing, 6)
            .padding(.top, 6)
    }
    
    
    // MARK: - Swipe helpers
    @ViewBuilder
    private func moveSwipeButtons(for tile: TileM) -> some View {
        Button(
            role: .none,
            action: { toggleMoveBar(for: tile) }
        ) {
            HStack {
                Image(systemName: "arrow.right.circle")
                T("Move", .action)
            }
        }
    }
    
    @ViewBuilder
    private func destructiveSwipeButtons(for tile: TileM) -> some View {
        if !isArchive {
            
            // Delete (with confirm alert)
            Button(
                role: .destructive,
                action: {
                    // alert does actual removal
                    confirmDeleteFor = (tile, category.id)
                }
            ) {
                HStack {
                    Image(systemName: "trash")
                    T("Delete", .action)
                }
            }
            
            // Archive (with confirm alert)
            Button(
                role: .none,
                action: {
                    confirmArchiveFor = (tile, category.id)
                }
            ) {
                HStack {
                    Image(systemName: "archivebox")
                    T("Archive", .action)
                }
            }
        }
    }
    
    // MARK: - Alert content helpers
    @ViewBuilder
    private func archiveAlertActions() -> some View {
        Button("Cancel", role: .cancel) { }
        
        Button("Archive", role: .destructive) {
            if let arch = confirmArchiveFor {
                Task {
                    do {
                        try await viewModel.moveTileThrowing(
                            arch.tile,
                            fromCategory: arch.sourceID,
                            toCategory: viewModel.archiveCategoryID
                        )
                    } catch {
                        viewModel.lastError = error
                        debugPrint("[CategoryTileList] Archive confirm failed")
                    }
                }
            } else {
                debugPrint("[CategoryTileList] Archive confirm fired but confirmArchiveFor is nil")
            }
            confirmArchiveFor = nil
            withAnimation { expandedMoveRowID = nil }
        }
    }
    
    @ViewBuilder
    private func archiveAlertMessage() -> some View {
        Text("This cannot be undone.")
    }
    
    @ViewBuilder
    private func deleteAlertActions() -> some View {
        Button("Cancel", role: .cancel) { }
        
        Button("Delete", role: .destructive) {
            if let del = confirmDeleteFor,
               let idx = category.tiles.firstIndex(of: del.tile) {
                category.tiles.remove(at: idx)
                viewModel.reorderTiles(category.tiles, in: del.sourceID)
            } else {
                debugPrint("[CategoryTileList] Delete confirm fired but tile not found")
            }
            confirmDeleteFor = nil
            withAnimation { expandedMoveRowID = nil }
        }
    }
    
    @ViewBuilder
    private func deleteAlertMessage() -> some View {
        Text("This cannot be undone.")
    }
}

// MARK: MoveChipRow struct
private struct MoveChipRow: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var viewModel: HistoryVM
    
    let tile: TileM
    let sourceCategoryID: UUID
    let isArchiveList: Bool
    
    /// Called when user chooses Archive as destination (we just set state, alerts do work)
    var onArchiveConfirm: (TileM, UUID) -> Void
    
    /// Called after a non-archive move completes (to collapse the bar)
    var onMovedNonArchive: () -> Void
    
    /// Theme hooks
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 8) {
                ForEach(viewModel.categories) { dest in
                    if dest.id != sourceCategoryID {
                        destinationChip(for: dest)
                    }
                }
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
        }
        .background(p.surfaces.opacity(0.8), in: RoundedRectangle(cornerRadius: 8, style: .continuous))
        .transition(.opacity.combined(with: .move(edge: .top)))
    }
    
    //    private func moveDestinationChip(for tile: TileM,
    //                                     destination dest: CategoriesModel) -> some View {
    @ViewBuilder
    private func destinationChip(for dest: CategoriesModel) -> some View {
        let isArchiveDest = dest.id == viewModel.archiveCategoryID
        
        Button(
            role: isArchiveDest ? .destructive : .none,
            action: {
                if isArchiveDest {
                    // Archive destination: confirm first, then immediate persist via VM
                    onArchiveConfirm(tile, sourceCategoryID)
                    //                if confirmArchiveFor == nil {
                    //                    confirmArchiveFor = (tile, category.id)
                    //                } else {
                    //                    debugPrint("[CategoryTileList] Archive confirm already pending (chip)")
                    //                }
                } else {
                    // Non-archive destination: delayed persist + undo window
                    viewModel.moveTileWithUndoWindow(
                        tile,
                        fromCategory: sourceCategoryID,
                        toCategory: dest.id
                    )
                    onMovedNonArchive()
                }
            }
        ) {
            HStack {
                if isArchiveDest {
                    Image(systemName: "archivebox")
                } else {
                    Image(systemName: "")
                }
                T(dest.persistedInput.ifEmpty("Untitled"), .action)
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                isArchiveDest
                ? p.accent.opacity(0.20)
                : p.surfaces.opacity(0.15),
                in: Capsule()
            )
        }
    }
}

private extension String {
    func ifEmpty(_ replacement: String) -> String { isEmpty ? replacement : self }
}
-e \n\n
=== ./intention/Shared/Helpers/Math.swift ===
//
//  Math.swift
//  intention
//
//  Created by Benjamin Tryon on 9/16/25.
//

//      Add something tiny to test (in the app target)
//          create code → make a test that passes → then make it fail.
//      Create App/Helpers/Math.swift (target membership: your app target, not the test target):
import Foundation

// Minimal test seam
struct Math {
    static func sum(_ a: Int, _ b: Int) -> Int { a + b }
}
-e \n\n
=== ./intention/Shared/Helpers/DevButtonsInSettings.swift ===
//
//  DevButtonsInSettings.swift
//  intention
//
//  Created by Benjamin Tryon on 10/24/25.
//

import Foundation

extension Notification.Name {
    static let devOpenRecalibration      = Notification.Name("ShowRecalibrationToDebug")
//    static let devOpenOrganizerOverlay   = Notification.Name("ShowOrganizerOverlayToDebug")
    static let devOpenMembership         = Notification.Name("ShowMembershipToDebug")
    static let debugShowSampleError       = Notification.Name("ShowSampleErrorToDebug")
    
}

// Helper struct for keys when passing data
enum DebugNotificationKey {
    static let errorTitle = "errorTitleKey"
    static let errorMessage = "errorMessageKey"
}
-e \n\n
=== ./intention/Shared/Helpers/KeychainHelper.swift ===
//
//  KeychainHelper.swift
//  intention
//
//  Created by Benjamin Tryon on 7/10/25.
//

import Foundation
import Security

actor KeychainHelper {
    //    any issues with KeychainHelper as an actor,
    //    change to final class KeychainHelper: @unchecked Sendable { static let standard = KeychainHelper
    //      // _ same methods, but add 'async' AND call await KeychainHelper.shared.getUserIdentifier()
    
    static let shared = KeychainHelper()
    private init() {}
    
    /// Grabs system-provided bundle ID string - `private let` restrict `service` to that file
    private let service = Bundle.main.bundleIdentifier!
    private let account = "anonymousUserID"
    
    /// Returns the existing UUID, or generates+stores a new one
    func getUserIdentifier() -> String {
        if let existing = readUUID() {
            return existing
        } else {
            let newID = UUID().uuidString
            saveUUID(newID)
            #if DEBUG
            debugPrint("KeychainHelper: newID - \(newID)")
            #endif
            return newID
        }
    }
    
    /// Keep saveUUID() and readUUID() synchronous internally - no "async"
    private func saveUUID(_ uuid: String) {
            let data = Data(uuid.utf8)
            let query: [String: Any] = [
                kSecClass as String: kSecClassGenericPassword,
                kSecAttrService as String: service,
                kSecAttrAccount as String: account,
                kSecValueData as String: data
            ]
            // Remove any old and add new
            SecItemDelete(query as CFDictionary)
            SecItemAdd(query as CFDictionary, nil)
        }
    
    private func readUUID() -> String? {
            let query: [String: Any] = [
                kSecClass as String: kSecClassGenericPassword,
                kSecAttrService as String: service,
                kSecAttrAccount as String: account,
                kSecReturnData as String: true,
                kSecMatchLimit as String: kSecMatchLimitOne
            ]
            var result: AnyObject?
            let status = SecItemCopyMatching(query as CFDictionary, &result)
            guard status == errSecSuccess,
                  let data = result as? Data,
                  let str = String(data: data, encoding: .utf8)
            else { return nil }
            return str
        }
}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerWrapper.swift ===
////
////  TileOrganizerWrapper.swift
////  intention
////
////  Created by Benjamin Tryon on 8/5/25.
////
//
//import SwiftUI
//
//// SwiftUI -> UIKit Bridge
//struct TileOrganizerWrapper: UIViewControllerRepresentable {
//    @EnvironmentObject var theme: ThemeManager
//    
//    // --- Local Color Definitions for Overlay ---
//    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
//    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
//    private let colorDanger = Color.red
//    
//    
//    @Binding var categories: [CategoriesModel]
//    let onMoveTile: (TileM, UUID, UUID) -> Void
//    let onReorder: ([TileM], UUID) -> Void
//    
//    func makeUIViewController(context: Context) -> TileOrganizerVC {
//        let vc = TileOrganizerVC()
//        vc.onMoveTile = onMoveTile
//        vc.onReorder = onReorder    // Hookup for persistence, called in/by HistoryVM
//        
//        // supply Organizer palette colors to UIKit
//        //  - allows SwiftUI to access colors for it (the Overlay)
//        
//        let p = theme.palette(for: .organizer)
//        vc.textColor = UIColor(p.accent)            //FIXME: is .accent correct?
//        vc.tileSeparatorColor = UIColor(p.accent)   //FIXME: is .intTan correct?
//        vc.sectionSeparatorColor = UIColor(colorBorder)
//        vc.headerTextColor = UIColor(theme.palette(for: .history).text)
//        vc.view.backgroundColor = .clear
//        return vc
//    }
//    
//    func updateUIViewController(_ uiViewController: TileOrganizerVC, context: Context) {
//        uiViewController.update(categories: categories)
//    }
//}
-e \n\n
=== ./intention/Shared/Helpers/TileOrganizerVC.swift ===
////
////  TileOrganizerVC.swift
////  intention
////
////  Created by Benjamin Tryon on 8/5/25.
////
//
//#if !NO_POWER_ORGANIZER
//import UIKit
//// Authority on delegates and section headers - with reorder support and onReorder callback
////Within-category reorder (UIKit reordering, SwiftUI list drag end)
//
//final class TileOrganizerVC: UICollectionViewController {
//    var onMoveTile: (TileM, UUID, UUID) -> Void = { _, _, _ in }
//    var onReorder: (([TileM], UUID) -> Void)?
//    
//    // injected from wrapper
//    var textColor: UIColor = .label
//    var tileSeparatorColor: UIColor = .separator
//    var sectionSeparatorColor: UIColor = .separator
//    var headerTextColor: UIColor = .label
//
//    private var categories: [CategoriesModel] = []
//    private var dragSourceIndexPath: IndexPath?
//
//    init() {
//        let layout = UICollectionViewFlowLayout()
//        layout.sectionInset = UIEdgeInsets(top: 12, left: 16, bottom: 12, right: 16)
//        // Self-sizing cells: give an estimated size, let Auto Layout compute height
//        layout.estimatedItemSize = CGSize(width: UIScreen.main.bounds.width - 48, height: 56)
//        layout.itemSize = UICollectionViewFlowLayout.automaticSize
//        layout.headerReferenceSize = CGSize(width: UIScreen.main.bounds.width, height: 30)
//        super.init(collectionViewLayout: layout)
//    }
//
//    required init?(coder: NSCoder) { fatalError("init(coder:) not implemented") }
//
//    override func viewDidLoad() {
//        super.viewDidLoad()
//        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "Cell")
//        collectionView.register(HeaderView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: "Header")
//        collectionView.dragDelegate = self
//        collectionView.dropDelegate = self
//        collectionView.dragInteractionEnabled = true
//        collectionView.reorderingCadence = .immediate
//        collectionView.backgroundColor = .clear
//    }
//
//    func update(categories: [CategoriesModel]) {
//        self.categories = categories
//        collectionView.reloadData()
//    }
//
//    override func numberOfSections(in collectionView: UICollectionView) -> Int {
//        categories.count
//    }
//
//    override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
//        categories[section].tiles.count
//    }
//
//    override func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
//        let tile = categories[indexPath.section].tiles[indexPath.row]
//        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
//
//        var config = UIListContentConfiguration.cell()
//        config.text = tile.text
//        config.textProperties.numberOfLines = 0          // allow wrapping
//        config.textToSecondaryTextVerticalPadding = 6
//        config.directionalLayoutMargins = .init(top: 10, leading: 12, bottom: 10, trailing: 12)
//        
//        config.textProperties.color = textColor             // accent label from struct TileOrganizerWrapper
//        cell.contentConfiguration = config
//        cell.backgroundColor = UIColor.secondarySystemBackground
//        cell.layer.cornerRadius = 8
//        cell.clipsToBounds = true
//        
//        // add/remove bottom separator (tan) except for the last row in the section
//        cell.contentView.subviews.filter { $0.tag == 999 }.forEach { $0.removeFromSuperview() }
//        let isLast = indexPath.row == collectionView.numberOfItems(inSection: indexPath.section) - 1
//        if !isLast {
//            let sep = UIView()
//            sep.tag = 999
//            sep.backgroundColor = tileSeparatorColor
//            sep.translatesAutoresizingMaskIntoConstraints = false
//            cell.contentView.addSubview(sep)
//            NSLayoutConstraint.activate([
//                sep.heightAnchor.constraint(equalToConstant: 1.0 / UIScreen.main.scale),
//                sep.leadingAnchor.constraint(equalTo: cell.contentView.leadingAnchor, constant: 6),
//                sep.trailingAnchor.constraint(equalTo: cell.contentView.trailingAnchor, constant: -6),
//                sep.bottomAnchor.constraint(equalTo: cell.contentView.bottomAnchor)
//        ])
//        }
//
//        return cell
//    }
//    
//    // reordering within a single category, but prevents dragging into a different category via reorder
//    override func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
//        guard kind == UICollectionView.elementKindSectionHeader else { return UICollectionReusableView() }
//        let header = collectionView.dequeueReusableSupplementaryView(ofKind: kind, withReuseIdentifier: "Header", for: indexPath) as! HeaderView
//        header.label.text = categories[indexPath.section].persistedInput
//        header.label.textColor = headerTextColor
//
//                // bottom line between categories using "history" border
//                header.subviews.filter { $0.tag == 777 }.forEach { $0.removeFromSuperview() }
//                let line = UIView()
//                line.tag = 777
//                line.backgroundColor = sectionSeparatorColor
//                line.translatesAutoresizingMaskIntoConstraints = false
//                header.addSubview(line)
//                NSLayoutConstraint.activate([
//                    line.heightAnchor.constraint(equalToConstant: 1.0 / UIScreen.main.scale),
//                    line.leadingAnchor.constraint(equalTo: header.leadingAnchor),
//                    line.trailingAnchor.constraint(equalTo: header.trailingAnchor),
//                    line.bottomAnchor.constraint(equalTo: header.bottomAnchor)
//                ])
//        return header
//    }
//    
//    // reorders within a same section/ category persist with `moveItemAt()
//    override func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
//        guard sourceIndexPath.section == destinationIndexPath.section else {
//            collectionView.reloadData()
//            return
//        }
//
//        let categoryID = categories[sourceIndexPath.section].id
//        var tiles = categories[sourceIndexPath.section].tiles
//        let movedTile = tiles.remove(at: sourceIndexPath.row)
//        tiles.insert(movedTile, at: destinationIndexPath.row)
//        categories[sourceIndexPath.section].tiles = tiles
//
//        // Persist the reorder
//        onReorder?(tiles, categoryID)
//    }
//}
//
//extension TileOrganizerVC: UICollectionViewDragDelegate, UICollectionViewDropDelegate {
//    func collectionView(_ collectionView: UICollectionView, itemsForBeginning session: UIDragSession, at indexPath: IndexPath) -> [UIDragItem] {
//        dragSourceIndexPath = indexPath
//        let tile = categories[indexPath.section].tiles[indexPath.row]
//        let itemProvider = NSItemProvider(object: tile.text as NSString)
//        let dragItem = UIDragItem(itemProvider: itemProvider)
//        dragItem.localObject = tile
//        return [dragItem]
//    }
//
//    func collectionView(_ collectionView: UICollectionView, canHandle session: UIDropSession) -> Bool {
//        session.localDragSession != nil
//    }
//
//    func collectionView(_ collectionView: UICollectionView, dropSessionDidUpdate session: UIDropSession, withDestinationIndexPath indexPath: IndexPath?) -> UICollectionViewDropProposal {
//        if let from = dragSourceIndexPath, let to = indexPath, from.section == to.section {
//            return UICollectionViewDropProposal(operation: .move, intent: .insertAtDestinationIndexPath)
//        } else {
//            return UICollectionViewDropProposal(operation: .move, intent: .insertIntoDestinationIndexPath)
//        }
//    }
//
//    func collectionView(_ collectionView: UICollectionView, performDropWith coordinator: UICollectionViewDropCoordinator) {
//        guard
//            let destinationIndexPath = coordinator.destinationIndexPath,
//            let sourceIndexPath = dragSourceIndexPath,
//            let item = coordinator.items.first,
//            let tile = item.dragItem.localObject as? TileM
//        else {
//            return
//        }
//        // Reordering within section
//        let fromCategoryID = categories[sourceIndexPath.section].id
//        let toCategoryID = categories[destinationIndexPath.section].id
//
//        onMoveTile(tile, fromCategoryID, toCategoryID)
//        dragSourceIndexPath = nil
//    }
//}
//#endif
-e \n\n
=== ./intention/Shared/Helpers/CategoryHeaderRow.swift ===
//
//  CategoryHeaderRow.swift
//  intention
//
//  Created by Benjamin Tryon on 7/17/25.
//
//
import SwiftUI

struct CategoryHeaderRow: View {
    @EnvironmentObject var theme: ThemeManager
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    let title: String
    let count: Int
    let isArchive: Bool
    
    // Only allow edit menu for user categories (not General/Archive).
    var allowEdit: Bool = true
    var onRename: () -> Void
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    
    // MARK: - Computed helpers
    
    private var iconName: String? {
        isArchive ? "archivebox.fill" : nil
    }
    
    private var iconTint: Color {
        isArchive ? p.text : p.accent
    }
    
    private var countText: String {
        "\(count)"
    }
    
    private var canEdit: Bool {
        allowEdit
    }
    
    private var accessibilityLabelText: String {
        "\(title), \(count) items"
    }
    
    // MARK: - Body
    
    var body: some View {
        HStack(spacing: 10) {
            if let iconName {
                Image(systemName: iconName)
                    .imageScale(.small)
                    .foregroundStyle(iconTint)
            }
            
            T(title, .label)
                .lineLimit(2)
            
            Spacer()
            
            Text(countText)
                .font(.callout.monospacedDigit())
                .foregroundStyle(textSecondary)
            
            if canEdit {
                editMenu
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel(accessibilityLabelText)
    }
    
    // MARK: Edit menu
    
    private var editMenu: some View {
        Menu {
            Button(action: onRename) {
                HStack {
                    Image(systemName: "pencil")
                    T("Rename Category", .action)
                }
            }
        } label: {
            HStack(spacing: 4) {
                Image(systemName: "ellipsis.circle")
                T("More", .action)
            }
            .imageScale(.medium)
            .foregroundStyle(p.primary)
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/AvailabilityTarget+.swift ===
//
//  AvailabilityTarget+.swift
//  intention
//
//  Created by Benjamin Tryon on 8/8/25.
//
import SwiftUI

// iOS 18-only helper so .bounce never appears in a broader-availability symbol
@available(iOS 18.0, *)
private extension View {
    @ViewBuilder
    func bounceSymbolEffect(isActive: Bool) -> some View {
        self.symbolEffect(.bounce, isActive: isActive)
    }
}

extension View {
    @ViewBuilder
    func symbolBounceIfAvailable(active: Bool = true) -> some View {
        if #available(iOS 18.0, *) {
            self.bounceSymbolEffect(isActive: active)               /// uses .bounce only in an iOS18 context
        } else if #available(iOS 17.0, *) {
            /// fallback for iOS 17
            self.symbolEffect(.pulse, isActive: active)
        } else {
            self
        }
    }
    
    //FIXME: -  affect does this have now?
    @ViewBuilder
    func safeAreaTopPadding() -> some View {
        if #available(iOS 17.0, *) {
            self.safeAreaPadding(.top)      /// adjusts with device & bars
        } else {
            self.padding(.top)              /// simple fallback
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/Pie.swift ===
//
//  Pie.swift
//  intention
//
//  Created by Benjamin Tryon on 11/3/25.
//
import SwiftUI

struct Pie: View {
    @EnvironmentObject var theme: ThemeManager
    @State private var remainingTime = 60.0
    let totalTime: TimeInterval = 60.0
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    
    var body: some View {
        let palette = theme.palette(for: .focus)
        ZStack {
            Circle()
                .fill(palette.background.opacity(0.2))
            
            UnwindingPieShape(progress: remainingTime / totalTime)
                .fill(palette.accent)
            
        }
        .frame(width: 400, height: 300)
        .onReceive(timer) { _ in
            if remainingTime > 0 {
                remainingTime -= 1
            }}
    }
}

#if DEBUG
#Preview {
    Pie()
        
}
#endif
-e \n\n
=== ./intention/Shared/Helpers/ProgressOverlay.swift ===
//
//  ProgressOverlay.swift
//  intention
//
//  Created by Benjamin Tryon on 9/20/25.
//

/*
 Use anywhere:
 @State private var isBusy = false body: some View {... .progressOverlay($isBusy, text: "Loading..."}
 func someLongAction() { isBusy = true;  Task { defer [ isBusy = false } try? await Task // do work } }
 */
import SwiftUI

struct ProgressOverlay: ViewModifier {
    @Binding var isPresented: Bool
    var text: String = "Loading..."
    
    func body(content: Content) -> some View {
        ZStack {
            content
            if isPresented {
                Color.black.opacity(0.2).ignoresSafeArea()
                VStack(spacing: 10){
                    ProgressView()
                    Text(text).font(.footnote).foregroundStyle(.secondary)
                }
                .padding(16)
                .background(.ultraThinMaterial)
                .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
                .shadow(radius: 3, y: 1)
                .transition(.opacity)
            }
        }
    }
}
extension View {
    func progressOverlay(_ isPresented: Binding<Bool>, text: String = "Loading...") -> some View {
        modifier(ProgressOverlay(isPresented: isPresented, text: text))
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CountBadge+Archive.swift ===
//
//  CountBadge+Archive.swift
//  intention
//
//  Created by Benjamin Tryon on 8/14/25.
//

import SwiftUI

struct CountBadge_Archive: View {
    let fontTheme: AppFontTheme
    let count: Int
    
    var body: some View {
        Text("\(count)")
            .font(fontTheme.toFont(.caption2))
            .padding(.horizontal, 6).padding(.vertical, 3)
            .background(.thinMaterial)
            .clipShape(Capsule())
    }
}
-e \n\n
=== ./intention/Shared/Helpers/HeaderView.swift ===
//
//  HeaderView.swift
//  intention
//
//  Created by Benjamin Tryon on 8/6/25.
//

import UIKit

final class HeaderView: UICollectionReusableView {
    let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        label.translatesAutoresizingMaskIntoConstraints = false
        addSubview(label)
        NSLayoutConstraint.activate([
            label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16),
            label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16),
            label.topAnchor.constraint(equalTo: topAnchor),
            label.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}
-e \n\n
=== ./intention/Shared/Helpers/ActionButtonStyle.swift ===
//
//  ActionButtonStyle.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.

import SwiftUI

// MARK: - PrimaryActionStyle
// filled with Accent, white text
struct PrimaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    @Environment(\.colorScheme) private var scheme
    let palette: ScreenStylePalette
    
    func makeBody(configuration: Configuration) -> some View {
        let base = palette.accent
        let pressed = configuration.isPressed
        
        return configuration.label
            .font(.headline)
            // always, for contrast
            .foregroundStyle(Color.white)
            .padding(.vertical, 14)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 14, style: .continuous)
                    .fill(base)
                    // vertical gloss - light mode shows more; dark mode gently
                    .overlay(
                        LinearGradient(
                            colors: [
                                Color.white.opacity(pressed ? 0.08 : 0.16),
                                Color.white.opacity(0.00)
                            ],
                            startPoint: .top, endPoint: .bottom
                        )
                        .clipShape(RoundedRectangle(cornerRadius: 14, style: .continuous))
                                  )
                        // 1pt highlight stroke - definition on dark
                            .overlay(
                                RoundedRectangle(cornerRadius: 14, style: .continuous)
                                    .stroke(Color.white.opacity(0.10), lineWidth: 1)
                            )
                        // a lift/shadow that reacts to press
                            .shadow(color: Color.black.opacity(isEnabled ? (pressed ? 0.10 : 0.22) : 0.00 ),
                                    radius: pressed ? 6 : 12, y: pressed ? 2 : 6)
                    )
                    .scaleEffect(pressed ? 0.985 : 1.0)                         // press feedback
                    .opacity(isEnabled ? 1.0 : 0.85)                            // disabled dim
                    .animation(.easeInOut(duration: 0.12), value: configuration.isPressed)
    }
}

// MARK: Secondary (surface chip with tinted text)
struct SecondaryActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    let palette: ScreenStylePalette

    func makeBody(configuration: Configuration) -> some View {
        let pressed = configuration.isPressed
        let fill = palette.surfaces.opacity(0.9)

        return configuration.label
            .font(.headline)
            .foregroundStyle(palette.text.opacity(0.9))
            .padding(.vertical, 12)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(fill)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(palette.text.opacity(0.10), lineWidth: 1)
                    )
                    .shadow(color: Color.black.opacity(isEnabled ? (pressed ? 0.06 : 0.14) : 0.0),
                            radius: pressed ? 3 : 8, y: pressed ? 1 : 3)
            )
            .scaleEffect(pressed ? 0.992 : 1.0)
            .opacity(isEnabled ? 1.0 : 0.75)
            .animation(.easeInOut(duration: 0.12), value: configuration.isPressed)
    }
}

// MARK: Recalibration (outline / inverted accent)
struct RecalibrationActionStyle: ButtonStyle {
    @Environment(\.isEnabled) private var isEnabled
    let palette: ScreenStylePalette

    func makeBody(configuration: Configuration) -> some View {
        let pressed = configuration.isPressed
        let stroke = palette.accent

        return configuration.label
            .font(.headline)
            .foregroundStyle(palette.accent)
            .padding(.vertical, 12)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(Color.clear)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(stroke.opacity(pressed ? 0.9 : 1.0), lineWidth: 2)
                    )
                    .shadow(color: stroke.opacity(isEnabled ? (pressed ? 0.10 : 0.20) : 0.0),
                            radius: pressed ? 3 : 6, y: pressed ? 1 : 3)
            )
            .scaleEffect(pressed ? 0.992 : 1.0)
            .opacity(isEnabled ? 1.0 : 0.80)
            .animation(.easeInOut(duration: 0.12), value: configuration.isPressed)
    }
}

extension View {
    func primaryActionStyle(screen: ScreenName) -> some View {          modifier(_PrimaryActionStyleMod(screen: screen)) }
    func secondaryActionStyle(screen: ScreenName) -> some View {        modifier(_SecondaryActionStyleMod(screen: screen)) }
    func recalibrationActionStyle(screen: ScreenName) -> some View {    modifier(_RecalibrationActionStyleMod(screen: screen)) }
}

// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct _PrimaryActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(PrimaryActionStyle(palette: p))
    }
}
// env-aware wrapper (replaces the current one that calls ThemeManager())
private struct _SecondaryActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(SecondaryActionStyle(palette: p))
    }
}

private struct _RecalibrationActionStyleMod: ViewModifier {
    @EnvironmentObject var theme: ThemeManager
    let screen: ScreenName
    func body(content: Content) -> some View {
        let p = theme.palette(for: screen)
        content.buttonStyle(RecalibrationActionStyle(palette: p))
    }
}

/// Helper to apply ButtonStyle inside a View modifier chain
private struct _ButtonStyleWrapper<S: ButtonStyle>: ViewModifier {
    let style: S
    func body(content: Content) -> some View { content.buttonStyle(style) }
}
-e \n\n
=== ./intention/Shared/Helpers/DynamicCountdown.swift ===
//
//  DynamicCountdown.swift
//  intention
//
//  Created by Benjamin Tryon on 8/13/25.
//

import SwiftUI

struct DynamicCountdown: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var fVM: FocusSessionVM
    let palette: ScreenStylePalette
    
    /// Current progress sizes (0.0 to 1.0), passed from FocusSessionActiveV
    let progress: CGFloat
    private let activeSize: CGFloat = 280       // was 220
    private let compactSize: CGFloat = 72       // was 60
    let digitSize: CGFloat = 44                 // small so circle/pause feel larger
    
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: .focus) }
    }
    
    private var isActive: Bool {
        fVM.phase == .running ||
        fVM.phase == .paused  ||
        (fVM.phase == .finished && fVM.currentSessionChunk == 2)
    }
    
    private var isBetweenChunks: Bool {
        let oneDone = fVM.phase == .finished && fVM.currentSessionChunk == 1
        return oneDone
    }
    
    private var isBothChunksDone : Bool {
        let oneDone = fVM.phase == .finished && fVM.currentSessionChunk == 1
        let twoDone = fVM.phase == .finished && fVM.currentSessionChunk == 2
        return oneDone && twoDone
    }
    
    private func handleTap() {
        if fVM.phase == .running {
            fVM.performAsyncAction { await fVM.pauseCurrent20MinCountdown() }
        } else if fVM.phase == .paused {
            fVM.performAsyncAction { try await fVM.resumeCurrent20MinCountdown() }
        }
    }
    
    // --- Local Color Definitions for the Pie and Countdown ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    // MARK: Countdown Label (digits with outline + shadow)
    private var countdownLabel: some View {
        // Base styled text from ThemeManager (role: .label)
        let base = T(fVM.formattedTime, .label)
        
        // Apply the monospaced, large font *once*
        let styled = base
            .font(.system(size: digitSize, weight: .bold, design: .monospaced))
        
        // Main “visible” layer
        let mainLayer = styled
            .foregroundStyle(palette.text)
        
        // Soft pseudo-outline by drawing the same text 4x slightly offset
        let outlineLayer = ZStack {
            // or styled.foregroundStyle(Color.defaultUtilityGray?).offset(x:  0.75, y:  0.75)
            styled.foregroundStyle(Color.intText).offset(x:  0.75, y:  0.75)
            styled.foregroundStyle(Color.intText).offset(x: -0.75, y:  0.75)
            styled.foregroundStyle(Color.intText).offset(x:  0.75, y: -0.75)
            styled.foregroundStyle(Color.intText).offset(x: -0.75, y: -0.75)
        }
        
        return mainLayer
            .overlay(outlineLayer)
            .shadow(color: .black.opacity(0.20), radius: 2, x: 0, y: 1)
    }

    // MARK: - Body
    var body: some View {
        if isActive {
            ZStack {
                // Background circle
                Circle()
                // Use opacity(0.2) or Color.clear here, the dimmed effect is applied below
                    .fill(palette.background.opacity( 0.2))
                
                // Pause overlay -- appears last, on top of everything
                if fVM.phase == .paused {
                    // PAUSED STATE
                    ZStack {
                        // The translucent opaque background for the pause state
                        Circle().fill(Color.black.opacity(0.35))     // Uses black for a better opaque look
                        
                        VStack(spacing: 8) {
                            Image(systemName: "pause.circle.fill")
                                .resizable()
                                .frame(width: 56, height: 56)       // was 40 x 40
                                .foregroundStyle(palette.accent)
                                .shadow(radius: 2)
                            
                            T("Paused", .title3)
                                .foregroundStyle(palette.text)
                                .fontWeight(.bold)
                        }
                    }
                    .clipShape(Circle())                        // Clips ZStack to circle here
                    .transition(.opacity)
                } else {
                    // RUNNING/ACTIVE STATE
                    
                    // Pie slicing
                    UnwindingPieShape(progress: progress)
                        .fill(palette.accent)
                    
                    
                    // Time text in the center
                    countdownLabel
                    // optional dim when paused; here it's only active/running so keep full
                        .opacity(fVM.phase == .paused ? 0.3 : 1.0)
                }
            }
            .frame(width: activeSize, height: activeSize)
            .contentShape(Circle())                             // tap target matches the circle
            .onTapGesture { handleTap() }                       // Keep as-is: the tap target persists across both `paused` and `running`, applies to entire ZStack, which is what is wanted
            .accessibilityAddTraits(.isButton)
            .accessibilityLabel(fVM.phase == .paused ? "Resume" : "Pause")
            .accessibilityHint("Tap to \(fVM.phase == .paused ? "resume" : "pause") the countdown")
            .animation(.easeInOut(duration: 0.2), value: progress)
            
        } else if isBetweenChunks {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(palette.background.opacity(0.1))
                // Text("✓").font(.largeTitle).foregroundStyle(palette.primary)
                
            }
            .frame(width: compactSize, height: compactSize)
            .transition(.opacity)
            .animation(.easeInOut(duration: 0.2), value: isBetweenChunks)
            
        } else if isBothChunksDone {
            ZStack {
                RoundedRectangle(cornerRadius: 4)
                    .fill(palette.background.opacity(0.1))
                // Text("✓").font(.largeTitle).foregroundStyle(palette.primary)
            }
            .frame(width: compactSize, height: compactSize)
            .transition(.opacity)
            .animation(.easeInOut(duration: 0.2), value: isBothChunksDone)
        } else {
            EmptyView()             /// Releases vertical space
        }
    }
}
-e \n\n
=== ./intention/Shared/Helpers/Text+StatStyles.swift ===
//
//  Text+StatStyles.swift
//  intention
//
//  Created by Benjamin Tryon on 10/3/25.
//

import SwiftUI

struct StatNumberStyle: ViewModifier {
    let p: ScreenStylePalette
    
    func body(content: Content) -> some View {
        content
            .bold()
            .monospacedDigit()
            .lineLimit(1)                           // never wrap
            .minimumScaleFactor(0.6)                // shrink, instead
            .allowsTightening(true)
            .foregroundStyle(p.text)
            .layoutPriority(2)
    }
}
struct StatCaptionStyle: ViewModifier {
    //    let p: ScreenStylePalette
    
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    
    func body(content: Content) -> some View {
        content
            .lineLimit(1)                           // never wrap
            .minimumScaleFactor(0.6)                // shrink, instead
            .allowsTightening(true)
            .foregroundStyle(textSecondary)
            .layoutPriority(1)
    }
}
extension View {
    func statNumberStyle(_ p: ScreenStylePalette) -> some View { modifier(StatNumberStyle(p:p)) }
    //    func statCaptionStyle(_ p: ScreenStylePalette) -> some View { modifier(StatCaptionStyle(p:p)) }
    func statCaptionStyle(_ p: ScreenStylePalette) -> some View { modifier(StatCaptionStyle()) }
}
-e \n\n
=== ./intention/Shared/Helpers/TimeString.swift ===
//
//  TimeString.swift
//  intention
//
//  Created by Benjamin Tryon on 10/31/25.
//

import Foundation

enum TimeString {
    /// Formats seconds as "MM:SS". Clamps negatives to 0.
    @inlinable
    static func mmss(_ seconds: Int) -> String {
        // any negative clamps to `0`; `0` stays `0`; positive values are passed through
        let s: Int = max(0, seconds)
        let m: Int = s / 60
        let r: Int  = s % 60
        
        // Manual zero-padding - do not use String(format: "%02d:%02d",m,r)
        // avoids objC entirely
        let mm = m < 10 ? "0\(m)" : "\(m)"
        let ss = r < 10 ? "0\(r)" : "\(r)"

        return "\(mm):\(ss)"
    }
//    static func mmss(_ seconds: Int) -> String {
//        if #available(iOS 15.0, *) {
//            return Duration.seconds(seconds).formatted(.time(pattern: .minuteSecond))
//        } else {
//            let f = DateComponentsFormatter()
//            f.allowedUnits = [.minute, .second]
//            f.unitsStyle = .positional
//            f.zeroFormattingBehavior = [.pad]
//            return f.string(from: TimeInterval(seconds)) ?? "00:00"
//        }
//    }
}

enum PercentString {
    /// Formats a 0.0...1.0 ratio as whole-percent (e.g., 0.87 -> "87%").
    static func whole(_ ratio: Double) -> String {
        ratio.formatted(.percent.precision(.fractionLength(0)))
    }
}
-e \n\n
=== ./intention/Shared/Helpers/CategorySection.swift ===
////
////  CategorySection.swift
////  intention
////
////  Created by Benjamin Tryon on 7/21/25.
////
//
//import SwiftUI
//
//struct CategorySection: View {
//    @Binding var categoryItem: CategoriesModel
//    let palette: ScreenStylePalette
//    let fontTheme: AppFontTheme
//    let saveHistory: () -> Void
//    let isArchive: Bool
//    var autoFocus: Bool = false
//    @Binding var newTextTiles: [UUID: String]
//    @State private var collapsed: Set<UUID> = []
//
//    var body: some View {
//        VStack(alignment: .leading, spacing: 8) {
//            CategoryHeaderRow(
//                categoryItem: $categoryItem,
//                palette: palette,
//                fontTheme: fontTheme,
//                newTextTiles: $newTextTiles,
//                saveHistory: saveHistory,
//                isArchive: isArchive,
//                autoFocus: autoFocus
//            )
//            
//            if !collapsed.contains(categoryItem.id) {
//                CategoryTileList(
//                    category: $categoryItem,
//                    palette: palette,
//                    fontTheme: fontTheme,
//                    saveHistory: saveHistory,
//                    isArchive: isArchive
//                )
//            }
//        }
//        .padding(.horizontal)
//        .padding(.bottom, 12)
//    }
//}
-e \n\n
=== ./intention/Shared/Helpers/DynamicMessageAndActionArea.swift ===
//
//  DynamicMessageAndActionArea.swift
//  intention
//
//  Created by Benjamin Tryon on 6/18/25.
//

import SwiftUI

struct DynamicMessageAndActionArea: View {
    @EnvironmentObject var theme: ThemeManager
    @EnvironmentObject var focusVM: FocusSessionVM
    
    let onRecalibrateNow: () -> Void
    
    private let screen: ScreenName = .focus
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text { { key, role in theme.styledText(key, as: role, in: screen) } }
    
    // MARK: Computed helpers
    private var recalibrateNowLabel: some View {
        HStack {
            Image(systemName: "sparkles")
            T("Recalibrate Now", .action)
        }
    }
    
    private var endEarlyLabel: some View {
        HStack {
            Image(systemName: "xmark.circle")
            T("End Early", .action)
        }
    }
    
    private var isBetweenChunks: Bool {
        focusVM.currentSessionChunk == 1 && focusVM.phase == .finished
    }
    
    // MARK: - Body
    var body: some View {
        VStack(spacing: 16) {
            // Session complete -> recalibration
            if focusVM.showRecalibrate {
                T("""
                Session complete!
                Time to Rest and Recalibrate Your Mind.
                """,.title3)
                .foregroundStyle(p.text)
                .multilineTextAlignment(.center)
                
                VStack(spacing: 10) {
                    Button(action: onRecalibrateNow ){
                        recalibrateNowLabel
                    }
                    .primaryActionStyle(screen: screen)
                    
                    Button(action: { focusVM.performAsyncAction { try await focusVM.beginOverallSession() } }) {
                        HStack {
                            Image(systemName: "play.circle.fill")
                            T("Start", .action)
                        }
                    }
                    .primaryActionStyle(screen: screen)
                    
                    Button(role: .destructive, action: {
                        focusVM.performAsyncAction { await focusVM.resetSessionStateForNewStart() }
                    }) {
                        endEarlyLabel
                    }
                    .secondaryActionStyle(screen: screen)
                }
            } else if isBetweenChunks {
                // text only here, relies on bottom CTA for "Next" button
                T("Done, Continue Your Streak to the Next One?", .title3)
                    .foregroundStyle(p.text)
                    .multilineTextAlignment(.center)
                
            } else if focusVM.tiles.count < 2, focusVM.phase == .running {
                T("Finish adding", .label)
            } else if focusVM.phase == .idle {                           // if needed, hint like "Add next intention above"
            } else if focusVM.phase == .paused {                        // no text needed - handled in DynamicCountdown()
            }
        }
            .padding(.vertical, 8)
    }
}

-e \n\n
=== ./intention/Shared/Helpers/Helper_AppIconV.swift ===
//
//  Helper_AppIconV.swift
//  intention
//
//  Created by Benjamin Tryon on 6/5/25.
//

import SwiftUI

// MARK: - AppIconView
struct Helper_AppIconV: View {
    @State var isBusy = false
    var body: some View {
        // safely unwraps uiimage from bundle extension
        if let uiImage = AppIconProvider.icon {
            // Good: have a non-optional UIImage to create a SwiftUI Image
            Image(uiImage: uiImage)
                .resizable()
                .aspectRatio(contentMode: .fit) // maintain aspect ratio
        } else {
            // Generic app icon SF Symbol
            Image(systemName: "app.fill")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .foregroundStyle(Color.intGreen)
                .progressOverlay($isBusy, text: "Loading...")
        }
    }
}

#if DEBUG
#Preview {
    Helper_AppIconV()
        .frame(width: 50, height: 50)
        .padding()
        
}
#endif
-e \n\n
=== ./intention/Shared/Helpers/AppEnvironment.swift ===
//
//  AppEnvironment.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

struct AppEnvironment {
    static let isAppStoreReviewing: Bool = {
        #if DEBUG
        return false
        #else
        return true
        #endif
    }()
}
-e \n\n
=== ./intention/Shared/Services/MembershipCodeService.swift ===
//
//  MembershipCodeService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/4/25.
//

import Foundation

// Apple Pay: users expect no codes. Just the StoreKit sheet → done.
// Stripe/web: a simple redeem code screen is the most anonymous and familiar approach without accounts.
//Redeem Code Screen:
//
//They pay, see a short code (6–10 chars).
//
//In the app, they go to “Enter Code”, type/paste it.
//
//App unlocks.
//
//--Familiar from gift cards and beta programs.
//
//-- No email or account but still feels anonymous but valid.

actor MembershipCodeService {
    
    enum VerificationResult {
        case success
        case invalid
        case networkError
    }
    
    // Replace with backend URL
    private let verifyEndpoint = URL(string: "https://argonnesoftware.com/api/verify")!
    
    func verify(code: String, deviceID: String) async -> VerificationResult {
        // FIXME: Placeholder - similate network verification
        try? await Task.sleep(nanoseconds: 500_000_000)       // 0.5s delay

        // FIXME: In production: POST code to backend and check response
        if code.uppercased() == "INTENTION-BETA" {
            UserDefaults.standard.set(true, forKey: "isMember")
            return .success
        } else {
            return .invalid
        }
    }
}
-e \n\n
=== ./intention/Shared/Services/PersistenceActor.swift ===
//
//  PersistenceActor.swift
//  intention
//
//  Created by Benjamin Tryon on 7/23/25.
//

import Foundation

// All I/O (encoding/decoding) logic here

/// Testing seam
public protocol Persistence: Sendable {
    func write<T: Codable & Sendable>(_ object: T, to key: String) async throws
    func readIfExists<T: Codable & Sendable>(_ type: T.Type, from key: String) async throws -> T?
    func clear(_ key: String) async
}

/// All business logic (when to save, what to save) belongs in the VM
/// VM decides when to persist; PersistenceActor decides how (encode/decode, storage)
///     PersistenceActor continues to store the **categories list**
public actor PersistenceActor {
    public enum PersistenceActorError: Error {
        case encodingFailed(Error)
        case decodingFailed(Error)
    }
    
    // Isolated - no need for .detach elsewhere
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    
    public init() {}
}

/// Actor conforms
extension PersistenceActor: Persistence {
    
    // MARK: Generic write; crossing int othis actor requires `await` from outside
    /// Encode and Save any Codable object and write it (to UserDefaults)
    public func write<T: Codable>(_ object: T, to key: String) async throws {
        do {
            let data = try encoder.encode(object)   // object is `categories` here
            UserDefaults.standard.set(data, forKey: key)
        } catch {
            debugPrint("[PersistenceActor.saveHistory] failed to encode and save:", error)
            throw PersistenceActorError.encodingFailed(error)
        }
    }
    
    // MARK: Load a Codable object from UserDefaults
    public func readIfExists<T: Codable>(_ type: T.Type, from key: String) async throws -> T? {
        guard let data = UserDefaults.standard.data(forKey: key) else { return nil }
        do {
            return try decoder.decode(T.self, from: data)
        } catch {
            debugPrint("[PersistenceActor.loadHistory] deocding failed: ", error)
            throw PersistenceActorError.decodingFailed(error)
        }
    }
    
    // MARK: Clear stored value at a key (from UserDefaults)
    public func clear(_ key: String) async {
UserDefaults.standard.removeObject(forKey: key) // keeps in-memory state (like categories), is seralized and background-safe
    }
}
-e \n\n
=== ./intention/Shared/Services/PaymentService.swift ===
//
//  PaymentService.swift
//  intention
//
//  Created by Benjamin Tryon on 8/3/25.
//

import StoreKit

// Service = "how". Actor is concurrency-safe and long-term correct.
// Owns StoreKit logic of products, entitlement refresh, refunds/cancellations
/// Apple processes payment; app never sees card info; Only reads entitlements (transactions) and set isMember; keeping app "anonymous" (device-scoped)
public struct PaymentState: Sendable, Equatable {
    public var isMember: Bool
    public var products: [Product]
}

public actor PaymentService {
    private let productIDs: [String]
    private var productsCache: [Product] = []
    private var isMemberCache: Bool = false
    
    // Async plumbing
    private var continuations: [UUID: AsyncStream<PaymentState>.Continuation] = [:]
    private var updatesTask: Task<Void, Never>?
    
    public init(productIDs: [String]) {
        self.productIDs = productIDs
    }
    
    // RootView calls this once, at launch
    public func configure() async {
        await refreshProducts()
        await refreshEntitlementStatus()
        // Start listening for transaction updates
        updatesTask?.cancel()
        updatesTask = listenForTransactions()
    }
    
    deinit { updatesTask?.cancel() }
    
    //
    //    public func updates() -> AsyncStream<PaymentState> {
    //        AsyncStream { cont in
    //            continuations.append(cont)
    //            // Immediately emit current snapshot
    //            cont.yield(.init(isMember: isMemberCache, products: productsCache))
    //            cont.onTermination = { [weak self] _ in
    //                guard let self else { return }
    //                self.continuations.removeAll { $0 === cont }
    //            }
    //        }
    //    }
    
    public func updates() -> AsyncStream<PaymentState> {
        AsyncStream { cont in
            let id = UUID()
            continuations[id] = cont
            // Immediately emit current snapshot
            cont.yield(.init(isMember: isMemberCache, products: productsCache))
            cont.onTermination = { [weak self] _ in
                Task { await self?.removeContinuation(id) }
            }
        }
    }
    
    // MARK: Queries
    public func products() -> [Product] { productsCache }
    public func isMember() -> Bool { isMemberCache }
    
    // MARK: Entitlement hydration
    // ➳ this is where membership flips as verified
    public func refreshEntitlementStatus() async {
        var active = false
        for await entitlement in Transaction.currentEntitlements {
            guard case .verified(let t) = entitlement else { continue }
            if t.productID == productIDs.first, t.revocationDate == nil {
                active = true
            }
        }
        isMemberCache = active
        notify()
    }
    
    // MARK: Products
    public func refreshProducts() async {
        do {
            let prods = try await Product.products(for: productIDs)
            productsCache = prods.sorted(by: { $0.price < $1.price })
            notify()
        } catch {
            // leave cache as-is
        }
    }
    
    // MARK: Purchase/Restore
    // Does NOT set isMember diretly (good)
    @discardableResult
    public func purchaseMembership() async throws -> Bool {
        let product: Product
        if let first = productsCache.first {
            product = first
        } else {
            await refreshProducts()
            guard let loaded = productsCache.first else { throw StoreKitError.unknown }
            product = loaded
        }
        
        let result = try await product.purchase()
        switch result {
        case .success(let verification):
            switch verification {
            case .verified(let transaction):
                await transaction.finish()
                await refreshEntitlementStatus()        // ✅ flip driven by entitlement re-read
                return true
            case .unverified:
                return false
            }
        case .userCancelled, .pending:
            return false
        @unknown default:
            return false
        }
    }
    
    public func restorePurchases() async throws {
        try await AppStore.sync()
        await refreshEntitlementStatus()             // ✅ flip driven by entitlement re-read
    }
    
    
    // MARK: Dependencies
    private func listenForTransactions() -> Task<Void, Never> {
        // Capture while on the actor
        let targetID = self.productIDs.first
        
        return Task { [weak self] in
            guard let self else { return }
            for await result in Transaction.updates {
                do {
                    // Pure helper, no actor state involved
                    let transaction = try checkVerified(result)
                    
                    if transaction.productID == targetID {
                        await self.refreshEntitlementStatus()       // ✅ flip driven by entitlement re-read
                    }
                    await transaction.finish()
                } catch {
                    // ignore unverified
                }
            }
        }
    }
    
    private nonisolated func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let value): return value
        case .unverified(_, let err): throw err
        }
    }
    
    private func notify() {
        let snapshot = PaymentState(isMember: isMemberCache, products: productsCache)
        for cont in continuations.values { cont.yield(snapshot) }
    }
    
    private func removeContinuation(_ id: UUID) {
        continuations.removeValue(forKey: id)
    }
    
    
    
    private let membershipProductID = "com.argonnesoftware.intention"
    //
    //    init() {
    //        /// Start updates (refunds/cancellation)  listener and hydrate state
    //        updatesTask = listenForTransactions()
    //        Task { await loadProducts(); await refreshEntitlementStatus() }
    //    }
    

}
-e \n\n
=== ./intention/Shared/Services/AppIconProvider.swift ===
//
//  AppIconProvider.swift
//  intention
//
//  Created by Benjamin Tryon on 6/10/25.
//

import UIKit

struct AppIconProvider {
    // Returns runtime display of icon
    static var icon: UIImage? {
        UIImage(named: "RuntimeAppIcon") // From AppDisplayIcon.imageset
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationCaption.swift ===
//
//  ValidationCaption.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

struct ValidationCaption: View {
    let state: ValidationState

    // --- Local Color Definitions for Validations ---
    private let colorDanger = Color.red

    var body: some View {
        if case .invalid (let msgs) = state {
            HStack(spacing: 6) {
                Image(systemName: "exclamationmark.triangle.fill")
                Text(msgs.joined(separator: " "))
            }
            .font(.footnote)
            .foregroundStyle(colorDanger)
            .accessibilityLabel("Validation error")
            .accessibilityHint(msgs.joined(separator: " "))
            .transition(.opacity.combined(with: .move(edge: .top)))     //TODO: Test this Aim for a 0.2-second transition
        }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidationResults+Fuzzy.swift ===
//
//  ValidationResults+Fuzzy.swift
//  intention
//
//  Created by Benjamin Tryon on 6/12/25.
//

import Foundation
//
// MARK: - non-fragile assertions and Generic Result Validations
//count matches the message and gate display via a flag
extension String {
    // FIXME: THIS SHOULD RENDER THE HELPERS NIL-SAFE (that is, prevents trying to append `String?` into `[String]`
    var isEmptyValidationMessage: String? {
        isEmpty ? "The field cannot be empty or just spaces." : nil
    }

    var taskValidationMessages: [String] {
        var messages: [String] = []
        let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.count > 200 { messages.append("200 character limit.") }
        if trimmed.isEmpty, let m = isEmptyValidationMessage { messages.append(m) }
        return messages
    }

        // NOTE: if ever necessary, uncomment... below are known "bad actor" threat patterns
//        let consecutiveCharacterPattern = "(&{3,}|={3,}|<{3,}|>{3,}|\\+{3,}|,{3,}|\\.{4,})"
//        let consecutiveCharacterRegex = try! NSRegularExpression(pattern: consecutiveCharacterPattern)
//        if consecutiveCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Avoid long runs of special symbols.")
//        }
//
//        let invalidCharacterPattern = "[^A-Za-z0-9 .,!?'-@#$%^&*()_+=/\\`~{}\\[\\]|:;\"\\\\]"
//        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
//        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Contains unsupported characters.")
//        }
//        
//        return messages
//    }
    
    var categoryTitleMessages: [String] {
        var messages: [String] = []
        let trimmedTitle = trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedTitle.count > 15 { messages.append("15 character limit.") }
        if trimmedTitle.isEmpty, let m = isEmptyValidationMessage { messages.append(m) }
        return messages
    }
}

        // NOTE: if ever necessary, uncomment... below are known "bad actor" threat patterns
//        let consecutiveCharacterPattern = "([.,?!'#@&-]){3,}"
//        if trimmedTitle.range(of: consecutiveCharacterPattern, options: .regularExpression) != nil {
//            messages.append("Avoid 3 or more consecutive symbols.")
//        }
//
//        let invalidCharacterPattern = "(?i)[^a-z0-9 .,?!#'@()&]"
//        let invalidCharacterRegex = try! NSRegularExpression(pattern: invalidCharacterPattern)
//        if invalidCharacterRegex.firstMatch(in: self, options: [], range: NSRange(location: 0, length: self.utf16.count)) != nil {
//            messages.append("Title contains unsupported characters.")
//        }
//
//        return messages
//    }
//}
-e \n\n
=== ./intention/Shared/Validation/ValidationState.swift ===
//
//  ValidationState.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import Foundation
/// decide when to surface errors in the view (on submit / CTA) instead of by default while the field is empty
enum ValidationState: Equatable {
    case none
    case valid
    case invalid(messages: [String])

    var isInvalid: Bool {
        if case .invalid = self { return true } else { return false }
    }
    var message: String? {
        if case .invalid(let msgs) = self { return msgs.joined(separator: " ") } else { return nil }
    }
}
-e \n\n
=== ./intention/Shared/Validation/ValidatingField.swift ===
//
//  ValidatingField.swift
//  intention
//
//  Created by Benjamin Tryon on 9/5/25.
//

import SwiftUI

/// Text always charcoal; change border color when invalid:
///         Visual treatment for validated fields using your ScreenStylePalette tokens
struct ValidatingField: ViewModifier {
    let state: ValidationState
    let p: ScreenStylePalette
    
    // --- Local Color Definitions ---
    let textSecondary = Color(red: 0.286, green: 0.290, blue: 0.290)
    let colorDanger = Color.red
    let colorBorder = Color(red: 0.286, green: 0.290, blue: 0.290).opacity(0.4) // or use neutralBorderColor: Color
    
    func body(content: Content) -> some View {
        content
            .textFieldStyle(.plain)                                 // no background/box
            .foregroundStyle(textSecondary)                   // Always charcoal text
            .tint(p.text)                                     // selection = charcoal
            .padding(12)
            .background(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                // transparent fill, allow parent view background to show throw
                    .fill(Color.clear)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                // Set stroke color based on validation state
                    .stroke(state.isInvalid ? colorDanger : colorBorder, lineWidth: 1)
            )
            .clipShape(RoundedRectangle(cornerRadius: 10, style: .continuous))
    }
}

extension View {
    func validatingField(
        state: ValidationState,
        palette: ScreenStylePalette
    ) -> some View {
        modifier(
            ValidatingField(state: state, p: palette)
        )
    }
}
-e \n\n
=== ./intention/Shared/Debug/debugModifier.swift ===
//
//  debugModifier.swift
//  intention
//
//  Created by Benjamin Tryon on 6/13/25.
//
import SwiftUI

extension View {
    @ViewBuilder
    func debugModifier<T: View>(_ modifier: (Self) -> T) -> some View {
        #if DEBUG
        modifier(self)
        #else
        self
        #endif
    }
    
    //  append a call at the end of view { }.here declaration, just like any other modifier
    //      only actually prints a value within debug builds if used as `.debugPrint()`
    @discardableResult
        func debugAction(_ closure: () -> Void) -> Self {
        #if DEBUG
        closure()
        #endif
            return self
        }

    /*
     example:
     extension View {
         func debugPrint(_ value: Any) -> Self {
             debugAction { print(value) }
         }
     }

     struct EventView: View {
         @ObservedObject var viewModel: EventViewModel

         var body: some View {
             VStack {
                 ...
             }
             .debugPrint(viewModel.bannerImage.size)
         }
     }
     */

    // Convenience wrappers
    func debugBorder(_ on: Bool = true) -> some View {
        overlay(on ? Rectangle().strokeBorder(.red, lineWidth: 1) : nil )
    }
    
    func debugBackground(_ color: Color = .red) -> some View {
        debugModifier { $0.background(color) }
    }
}

/*
 
 Text(viewModel.formattedDate)
                .debugBackground(.green)
 or
 
 VStack {
        // code
    }
    .debugBorder()
 */
-e \n\n
=== ./intention/Shared/Debug/DebugKeys.swift ===
//
//  DebugKeys.swift
//  intention
//
//  Created by Benjamin Tryon on 9/12/25.
//

import SwiftUI

#if DEBUG
struct DebugKeys {
    static let forceLegalNextLaunch = "debug.forceLegalNextLaunch"
}

/// Call once at app startup (e.g., in App/RootView.onAppear)
func bootstrapLegalGate() {
    // Test plan env var still works if you keep using it
    if ProcessInfo.processInfo.environment["RESET_LEGAL_ON_LAUNCH"] == "1" {
        LegalConsent.clearForDebug()
    }
    if UserDefaults.standard.bool(forKey: DebugKeys.forceLegalNextLaunch) {
        LegalConsent.clearForDebug()
        UserDefaults.standard.set(false, forKey: DebugKeys.forceLegalNextLaunch)
    }
}
#endif

-e \n\n
=== ./intention/Models/ActivityAndDataIdentifier.swift ===
//
//  ActivityAndDataIdentifier.swift
//  intention
//
//  Created by Benjamin Tryon on 7/8/25.
//

import Foundation

//  Generate UUID on first launch
//      - user identified anonymously but trackable
//  Store (locally) UUID for persistence
//  Use to track history and sessions, no User input needed
func getUserIdentifier() -> String {
    if let storedUUID = UserDefaults.standard.string(forKey: "userUUID") {
        return storedUUID
    } else {
        let newUUID = UUID().uuidString
        UserDefaults.standard.set(newUUID, forKey: "userUUID")
        return newUUID
    }
}
-e \n\n
=== ./intention/Models/TileM.swift ===
//
//  TileM.swift
//  intention
//
//  Created by Benjamin Tryon on 6/11/25.
//

import Foundation

// DragPayload: Transferable handles drag and drop
struct TileM: Identifiable, Sendable, Codable, Hashable {
    let id: UUID
    var text: String
//    var timeStamp: Date
    
    init(id: UUID = UUID(), text: String) {
//        self.id = UUID()
        self.id = id
        self.text = text
//        self.timeStamp = Date()
    }
}
-e \n\n
=== ./intention/Models/CategoriesModel.swift ===
//
//  Categories.swift
//  intention
//
//  Created by Benjamin Tryon on 7/12/25.
//

import Foundation
import SwiftUI

// MARK: - Inject a known, stable ID
// DragPayload: Transferable handles drag and drop
struct CategoriesModel: Identifiable, Codable, Hashable {
    let id: UUID
    var persistedInput: String
    var tiles: [TileM]
    
    init(id: UUID = UUID(), persistedInput: String, tiles: [TileM] = []) {
        self.id = id
        self.persistedInput = persistedInput
        self.tiles = tiles
    }
}
-e \n\n
=== ./intention/Models/ActiveSessionSnapshot.swift ===
//
//  ActiveSessionSnapshot.swift
//  intention
//
//  Created by Benjamin Tryon on 9/18/25.
//

import SwiftUI

/// Preserve session state (so tiles/timer don’t vanish on relaunch)
struct ActiveSessionSnapshot: Codable, Sendable {
    let tileTexts: [String]
    let phase: FocusSessionVM.Phase
    let chunkIndex: Int
    let deadline: Date       // <- single source of truth
}
-e \n\n
=== ./HistoryV.swift ===
//
//  HistoryV.swift
//  intention
//
//  Created by Benjamin Tryon on 10/27/25.
//


import SwiftUI

/// content-management screen with an explicit Edit/Done mode
struct HistoryV: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var theme: ThemeManager
    @ObservedObject var viewModel: HistoryVM
    @Environment(\.editMode) private var editMode
    
    // UI State
    //    @State private var newTextTiles: [UUID: String] = [:]       /// Store new tile text per category using its `id` as key
    @State private var isOrganizing = false
    @State private var showOrganizerOverlay = false
    @State private var showErrorOverlay = false
    @State private var createdCategoryID: UUID?
    @State private var targetCategoryID: UUID?
    @State private var showRenamePicker = false
    @State private var showDeletePicker = false
    @State private var showRenameSheet = false
    @State private var renameText = ""
    @State private var showDeleteConfirm = false
    @State private var isBusy = false
    
    private let screen: ScreenName = .history
    private var p: ScreenStylePalette { theme.palette(for: screen) }
    private var T: (String, TextRole) -> Text {
        { key, role in theme.styledText(key, as: role, in: screen) }
    }
    
    // --- Local Color Definitions for History ---
    private let textSecondary = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.72)
    private let colorBorder = Color(red: 0.333, green: 0.333, blue: 0.333).opacity(0.22)
    private let colorDanger = Color.red
    
    var body: some View {
        ScrollView {
            Page(top: 6, alignment: .center) {
                
                LazyVStack(alignment: .leading, spacing: 8) {
                    // $Bindings are so rows can edit categories
                    ForEach($viewModel.categories) { $category in
                        CategoryCard(
                            category: $category,
                            isArchive: category.id == viewModel.archiveCategoryID,
                            onRename: { id in
                                targetCategoryID = id
                                renameText = viewModel.name(for: id)
                                showRenameSheet = true
                            },
                            onDelete: { id in
                                targetCategoryID = id
                                showDeleteConfirm = true
                            }
                        )
                        .id(category.id)
                        //                        .padding(.vertical, 12)
                        //                        .padding(.horizontal, 16)
                        //                        .environmentObject(theme)
                        // -- category separator --
                        Rectangle()
                            .fill(colorBorder)
                            .frame(height: 1)
                            .padding(.vertical, 4)
                    }
                }
                //                Divider().overlay(Color.intTan)
                //                .padding(.vertical, 12)
            }
            // Toasts
            VStack(spacing: 8) {
                if let move = viewModel.lastUndoableMove {
                    HStack {
                        //                        Text("\(move.tile.text) moved").font(.footnote)
                        //                        Spacer()
                        Button {viewModel.undoLastMove()} label: { T("Undo?", .action) }.primaryActionStyle(screen: screen)
                    }
                    .padding(.horizontal, 12)           // Card instead?
                    .padding(.vertical, 10)             // Card instead?
                    .background(.ultraThinMaterial, in: Capsule())
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                }
                
                if viewModel.tileLimitWarning {
                    T("Archive capped at 200; oldest items were removed.", .caption)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 10)
                        .background(.ultraThinMaterial, in: Capsule())
                        .task {
                            try? await Task.sleep(nanoseconds: 2_000_000_000)
                            await MainActor.run { viewModel.tileLimitWarning = false }
                        }
                        .transition(.move(edge: .bottom).combined(with: .opacity))
                }
            }
        }
        .background(p.background)
        .tint(p.accent)
        .animation(.easeInOut(duration: 0.2), value: viewModel.lastUndoableMove != nil)
        .toolbar { historyToolbar }.environmentObject(theme)
        /// [.medium] is half-screen, .visible affordance
        .sheet(isPresented: $showRenameSheet) {
            renameSheet
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
        }
        .alert("Delete category?", isPresented: $showDeleteConfirm) {
            Button("Delete", role: .destructive) {
                if let id = targetCategoryID {
                    Task { _ = viewModel.deleteCategory(id: id) }
                }
            }
            Button("Cancel", role: .cancel) { }
        } message: { Text("Tiles will be moved to Archive.") }
        
//        // Organizer overlay (your fullScreenCover is driven by isOrganizing)
//            .onReceive(NotificationCenter.default.publisher(for: .devOpenOrganizerOverlay)) { _ in
//                withAnimation { isOrganizing = true }
//            }
        
        // Error overlay
//            .onReceive(NotificationCenter.default.publisher(for: .debugShowSampleError)) { _ in
//                showErrorOverlay = true
//            }
//            .overlay {
//                if showErrorOverlay {
//                    ErrorOverlayV(onClose: { showErrorOverlay = false })
//                }
//            }
            .fullScreenCover(isPresented: $isOrganizing
                             //                             //FIXME: - Does this =work without onDismiss?
                             //                             onDismiss: { viewModel.flushPendingSaves() }
            ) {
                OrganizerOverlayChrome(onClose: {
                    //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                    //                    viewModel.flushPendingSaves()
                    isOrganizing = false
                }) {
                    OrganizerOverlayScreen(
                        categories: $viewModel.categories,
                        onMoveTile: { tile, fromID, toID in
                            Task { @MainActor in
                                do { try await viewModel.moveTileThrowing(tile, from: fromID, to: toID) }
                                catch { viewModel.lastError = error }
                            }
                        },
                        onReorder: { newTiles, categoryID in
                            // reorderTiles already applies caps AND persists, saveHistory() isn't needed
                            viewModel.reorderTiles(newTiles, in: categoryID)
                        },
                        onDone: {
                            // close path X/drag like RecalibrationChrome
                            //FIXME: - Does this CLOSE AND save without flushPendingSaves?
                            // viewModel.flushPendingSaves()
                            isOrganizing = false
                        }
                    )
                    .environmentObject(theme)
                }
                // Chrome owns gesture/X dismissal
                .interactiveDismissDisabled(true)
            }
        // HistoryV: the flush in .task(id: isOrganizing) when it becomes false,
        // - happens ONCE here, when the cover closes
            .task(id: isOrganizing) {
                // On leaving organize mode, force-flush pending saves.
                if !isOrganizing { viewModel.flushPendingSaves() }
            }
        Spacer(minLength: 0)
    }
    
    //    @ToolbarContentBuilder private var historyToolbar: some ToolbarContent {
    //        ToolbarItemGroup(placement: .topBarTrailing) {
    @ToolbarContentBuilder
    private var historyToolbar: some ToolbarContent {
        ToolbarItemGroup(placement: .topBarTrailing) {
            Button {
                if isOrganizing { viewModel.flushPendingSaves() }
                withAnimation { isOrganizing.toggle() }
            } label: {
                Label(
                    isOrganizing ? "Done" : "Edit", systemImage: "arrow.up.arrow.down"
                ).foregroundStyle(p.primary)
            }
            
            Menu {
                Button("Rename Category") {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        renameText = viewModel.name(for: only)
                        showRenameSheet = true
                    } else {
                        showRenamePicker = true
                    }
                }
                
                Button("Delete Category", role: .destructive) {
                    if let only = viewModel.userCategoryIDs.first, viewModel.userCategoryIDs.count == 1 {
                        targetCategoryID = only
                        showDeleteConfirm = true
                    } else {
                        showDeletePicker = true
                    }
                }
                
                Divider()
                
                Button("Add Category") {
                    if let id = viewModel.addEmptyUserCategory() {
                        createdCategoryID = id
                    }
                }
                .disabled(!viewModel.canAddUserCategory())
            } label: {
                Image(systemName: "ellipsis.circle").foregroundStyle(p.primary)
            }
        }
    }
    
    
    @ViewBuilder private var renameSheet: some View {
        NavigationStack {
            Form {
                Section("New Name") {
                    TextField("Category name", text: $renameText)
                        .textInputAutocapitalization(.words)
                        .disableAutocorrection(true)
                    
                    Button { Task { viewModel.canAddUserCategory() } } label: { T("Rename Category", .action) }
                        .primaryActionStyle(screen: screen)
                }
            }
            .navigationTitle("Rename")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { showRenameSheet = false }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        if let id = targetCategoryID {
                            viewModel.renameCategory(id: id, to: renameText.trimmingCharacters(in: .whitespacesAndNewlines))
                        }
                        showRenameSheet = false
                    }
                    .disabled(renameText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
        }
        .presentationDetents([.medium])
    }
}-e \n\n
=== ./IntentionTests/IntentionTests.swift ===
//
//  IntentionTests.swift
//  IntentionTests
//
//  Created by Benjamin Tryon on 9/16/25.
//

@testable import intention
import XCTest

final class IntentionTests: XCTestCase {

}
-e \n\n
=== ./IntentionTests/MathTests.swift ===
//
//  MathTests.swift
//  IntentionTests
//
//  Created by Benjamin Tryon on 9/16/25.
//

//
//      Write the test (in the IntentionTests target)

//      Create IntentionTests/MathTests.swift (target membership: IntentionTests):
//  Create App/Helpers/Math.swift (target membership: your app target, not the test target):
//  App/Helpers/Math.swift
//  import Foundation

///   Minimal test seam: pure, deterministic
//  struct Math {
//      static func sum(_ a: Int, _ b: Int) -> Int { a + b }
//  }

@testable import intention
import XCTest

final class MathTests: XCTestCase {

   // naming pattern: test_Method_Scenario_Expected
    func test_Sum_TwoNumbers_ReturnSum() {
        XCTAssertEqual(Math.sum(1, 2), 3)
        
//        // Arrange (set up the needed objects)
//        let a = 1, b = 2
//        
//        // Act (run the method you want to test)
//        let result = Math.sum(a, b)
//        
//        // Assert (test that the behavior is as expected)
//        XCTAssertEqual(result, 3)
    }

}
-e \n\n
